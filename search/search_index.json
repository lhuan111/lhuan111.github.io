{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Assignment 1","text":"<p>title: Project Assignment 1 tags: - foldable robotics - walking robots</p>"},{"location":"#ras557-project-assignment-1-klann-style-hexapod","title":"RAS557 Project Assignment 1 \u2014 Klann-style Hexapod","text":"<p>Instructor: Daniel Aukes</p> <p>Team members: Shuai Guo, Lixiao Huang, Yibo Yuan</p> <p>Contents:</p> <ul> <li>Klann linkage kinematics for a single leg (numeric closed-loop solver)</li> <li>A hexapod arrangement (6 legs) with phase offsets</li> <li>Numeric Jacobian (d foot position / d crank angle), torque and power computations</li> <li>An MJCF generator for MuJoCo (approximate multi-body representation)</li> </ul>"},{"location":"#1-project-goal-fit","title":"1 \u2014 Project Goal &amp; Fit","text":"<p>Team goal:</p> <p>Our team\u2019s goal is to design, model, and analyze a Klann-style six-legged walking robot that demonstrates efficient ground locomotion using purely mechanical linkages and minimal actuation. The project aims to replicate bio-inspired gait patterns from hexapodal insects while integrating foldable fabrication techniques for lightweight and easily manufacturable components. The design will be simulated in MuJoCo and analyzed for torque, power, and stability requirements.</p> <p>Candidate organism: Species name, body plan, motion of interest</p> <ul> <li>Organism: Blaberus giganteus (giant cockroach)</li> <li>Body Plan: Hexapodal (six-legged), each leg with two primary rotational joints for swing and lift phases</li> <li>Motion of Interest: Tripod gait used for steady walking and efficient terrestrial locomotion on uneven ground</li> </ul> <p>Scope / Impact / Team fit / Topic fit</p> <ul> <li>Scope: how you constrain the problem for a single semester</li> </ul> <p>To ensure the project is feasible within a single semester, we constrain the design to a planar six-bar Klann linkage per leg, with a single degree of freedom driven by a rotating crank. This limits control complexity while preserving the biologically inspired foot trajectory that mimics insect gaits. The robot will be modeled at tabletop scale (roughly 20\u201325 cm body length), built from folded cardboard or laser-cut polymer, and powered by six independent crank motors. The scope emphasizes kinematics and mechanical efficiency over autonomous control or perception.</p> <ul> <li>Impact: why this matters.</li> </ul> <p>This project demonstrates how bio-inspired mechanical linkages can produce complex legged locomotion with minimal sensors or software. It contributes to foldable robotics by showing that low-cost, flat-fabricated mechanisms can achieve reliable walking behaviors comparable to multi-motor leg designs. The research has practical implications for low-cost search-and-rescue scouting robots, STEM education, and deployable field robots where simplicity, weight, and robustness are critical. Understanding this linkage\u2019s performance also deepens insight into energy-efficient legged motion relevant to both engineered and biological systems.</p> <ul> <li>Team Fit: why your team is suited to this problem.</li> </ul> <p>Our team brings together complementary skills in mechanical design, kinematics, and simulation. One member specializes in mechanism synthesis and CAD modeling, another in physics-based simulation and code development (MuJoCo/Python), and another in fabrication and testing of foldable prototypes. This diverse expertise allows us to connect theoretical modeling with hands-on prototyping and validation, ensuring both analytical rigor and functional design execution.</p> <ul> <li>Topic Fit: how this uses foldable robotics techniques</li> </ul> <p>The project directly employs foldable robotics techniques introduced in class, using layered cardboard or plastic sheets with integrated hinge lines to create planar four- and six-bar linkages. The Klann mechanism\u2019s planar structure is ideally suited for this fabrication method, allowing rapid iteration of designs without costly machining. By combining foldable joints with bio-inspired geometry, we can explore how planar foldable mechanisms achieve lifelike motion while remaining lightweight, scalable, and manufacturable using classroom tools.</p>"},{"location":"#2-background-research","title":"2 \u2014 Background Research","text":"<p>Search Terms</p> <p>To inform our design, we conducted literature searches using the following keywords:</p> <ul> <li><code>cockroach biomechanics ground reaction forces</code></li> <li><code>hexapod gait tripod gait kinematics</code></li> <li><code>Klann linkage walking mechanism</code></li> <li><code>insect leg morphology hexapod locomotion</code></li> <li><code>bio-inspired mechanical leg robots</code></li> <li><code>foldable planar linkage mechanism</code></li> </ul> <p>These searches yielded studies on both biological hexapods (e.g., Blaberus giganteus) and mechanical walkers like the Klann linkage, which replicates insect-style foot trajectories using a planar six-bar mechanism.</p> <p>Representative Citations (IEEE Format)</p> <p>[1] R. J. Full and D. E. Koditschek, \u201cTemplates and anchors: Neuromechanical hypotheses of legged locomotion on land,\u201d Journal of Experimental Biology, vol. 202, no. 23, pp. 3325\u20133332, 1999. [2] K. Klann, \u201cMechanical leg walking device,\u201d U.S. Patent 5,281,151, Jan. 25, 1994. [3] T. McGeer, \u201cPassive dynamic walking,\u201d The International Journal of Robotics Research, vol. 9, no. 2, pp. 62\u201382, 1990. [4] S. Kim, C. Laschi, and B. Trimmer, \u201cSoft robotics: A bioinspired evolution in robotics,\u201d Trends in Biotechnology, vol. 31, no. 5, pp. 287\u2013294, 2013. [5] Schilling, M., Schneider, A., Cruse, H., &amp; Schmitz, J. (2008, September). Local control mechanisms in six-legged walking. In 2008 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 2655-2660). IEEE.</p> <p>Key Biological and Mechanical Insights</p> Parameter Unit Value / Observation Source Typical insect mass (scaled equivalent) kg 0.5\u20131.0 [1] Walking speed (tripod gait) m/s 0.2\u20130.5 [1] Stride length (scaled) m 0.08\u20130.12 [1] Peak ground reaction force per stance leg N ~4 [1] Material for mechanical analog \u2014 Plywood / laser-cut plastic / cardboard \u2014 Mechanism inspiration \u2014 Klann six-bar linkage [2] Actuation \u2014 Servo motors or geared DC motors \u2014 Power source \u2014 Compact 6V\u201312V battery \u2014 <p>Figures and Observations</p> <p>Figure 1. Klann-style six-legged mechanical walker prototype built for this project. </p> <p>Each leg consists of a planar six-bar linkage, driven by a single rotating crank. The leg replicates the ground contact and swing phases of a cockroach-like tripod gait. The body is lightweight plywood with foldable linkage connections, and spherical red feet enhance stability and traction. Pictures below show the front, back, and side views.</p> <p> </p> <p>Project Video:</p> <p>This video shows the robot walking in the real world. </p> <p> </p> <p>3 \u2014 Specifications Table</p> <p>The table below lists key physical and kinematic parameters for the Klann-style six-legged walker. All quantities are expressed in SI units, with values derived from literature on insect locomotion and scaled for the tabletop prototype.</p> Parameter Symbol Unit Value (example) Source / Notes Total robot mass \ud835\udc5a kg 0.8 Measured prototype (plywood + servos) Number of legs \u2014 \u2014 6 Hexapod (tripod gait) Leg mechanism type \u2014 \u2014 Klann 6-bar linkage Planar, single DOF per leg Crank length \ud835\udc3f\u2081 m 0.025 Measured Coupler link 1 \ud835\udc3f\u2082 m 0.060 Measured Coupler link 2 \ud835\udc3f\u2083 m 0.045 Measured Rocker length \ud835\udc3f\u2084 m 0.065 Measured Follower (leg) length \ud835\udc3f\u2085 m 0.090 Measured Body length \ud835\udc3f_b m 0.25 Approx. overall length Walking speed (target) \ud835\udc63 m/s 0.30 From cockroach gait scaling Stride length \ud835\udc60 m 0.10 Derived from mechanism geometry Step frequency \ud835\udc53 Hz 3 Typical tripod gait rhythm Stance fraction \u03b2 \u2014 0.6 Fraction of stride in contact Peak GRF per stance leg \ud835\udc39_leg N 3.9 \\(1.5 \\times (m g)/3\\) Crank angular velocity \u03c9_c rad/s 6.0 Derived from stride frequency Peak crank torque \u03c4_c N\u00b7m 0.35 From Jacobian &amp; force mapping Gear ratio \ud835\udc3a \u2014 10 Motor gearbox ratio Efficiency \u03b7 \u2014 0.7 Typical small gearbox efficiency Safety margin \ud835\udc0c \u2014 2 For motor sizing Rated motor torque \u03c4_m,rated N\u00b7m 0.10 $\\frac{ Power per actuator \ud835\udc43 W 0.7 \\( \u03c4_c \u00d7 \u03c9_c \\) Material \u2014 \u2014 Plywood / 3D-printed polymer Foldable planar structure Actuators \u2014 \u2014 Micro servos (6 total) One per crankshaft Power source \u2014 \u2014 2S Li-ion battery 7.4 V nominal <p>Notes - The above values are representative of the prototype shown in Figures 1\u20132. - Actual values may vary slightly depending on material density and linkage tolerances. - Use the torque and power values in this table for actuator selection and MuJoCo simulation inputs.</p>"},{"location":"#4-mechanism-design-kinematic-model","title":"4 \u2014 Mechanism Design &amp; Kinematic Model","text":""},{"location":"#mechanism-description","title":"Mechanism Description","text":"<p>The Klann linkage is a planar six-bar mechanism designed to transform continuous rotary motion into an approximate leg-like walking trajectory. Each leg consists of: - A fixed ground link connecting two pivots (A and B), - A crank (driven by the motor), - Two coupler links forming a four-bar subloop, - A rocker connected to the ground pivot B, - A follower leg connecting the floating coupler to the foot point.</p> <p>The mechanism\u2019s geometry and motion are optimized so that the foot follows an oval-shaped trajectory, with a nearly straight line during the stance phase and a smooth lift during the swing phase.</p> <p>Mechanism Drawing</p> <p>Draw or model your mechanism externally (e.g., Draw.io). Include link labels (A\u2013F), reference frames, and joint variables (\u03b8\u2081, \u03b8\u2082, \u2026). b=back, f=front.  </p> <p>\\(l_1f\\)=\\(l_1b\\)=\\(l_3f\\)=\\(l_3b\\)=\\(l_5f\\)=\\(l_5b\\)=\\(l_65f\\)=\\(l_6b\\)=\\(l_7f\\)=\\(l_7b\\)=4.2 inch</p> <p>\\(l_2f\\)=\\(l_2b\\)=\\(l_4f\\)=\\(l_4b\\)=\\(l_8f\\)=\\(l_8b\\)=\\(l_9f\\)=\\(l_9b\\)=2.1 inch,</p> <p>\\(l_{10}f\\)= 1 inch</p> <p></p>"},{"location":"#5-force-torque-power-estimation","title":"5 \u2014 Force / Torque / Power Estimation","text":"<p>Use the Jacobian to map end-effector forces to actuator torques, then compute power = torque * angular velocity. Fill in calculated/assumed GRFs and pick key gait states to compute required actuator specs.</p> <pre><code>!pip install mujoco\n\n# Set up GPU rendering.\nfrom google.colab import files\nimport distutils.util\nimport os\nimport subprocess\nif subprocess.run('nvidia-smi').returncode:\n  raise RuntimeError(\n      'Cannot communicate with GPU. '\n      'Make sure you are using a GPU Colab runtime. '\n      'Go to the Runtime menu and select Choose runtime type.')\n\n# Add an ICD config so that glvnd can pick up the Nvidia EGL driver.\n# This is usually installed as part of an Nvidia driver package, but the Colab\n# kernel doesn't install its driver via APT, and as a result the ICD is missing.\n# (https://github.com/NVIDIA/libglvnd/blob/master/src/EGL/icd_enumeration.md)\nNVIDIA_ICD_CONFIG_PATH = '/usr/share/glvnd/egl_vendor.d/10_nvidia.json'\nif not os.path.exists(NVIDIA_ICD_CONFIG_PATH):\n  with open(NVIDIA_ICD_CONFIG_PATH, 'w') as f:\n    f.write(\"\"\"{\n    \"file_format_version\" : \"1.0.0\",\n    \"ICD\" : {\n        \"library_path\" : \"libEGL_nvidia.so.0\"\n    }\n}\n\"\"\")\n\n# Configure MuJoCo to use the EGL rendering backend (requires GPU)\nprint('Setting environment variable to use GPU rendering:')\n%env MUJOCO_GL=egl\n\n# Check if installation was succesful.\ntry:\n  print('Checking that the installation succeeded:')\n  import mujoco\n  mujoco.MjModel.from_xml_string('&lt;mujoco/&gt;')\nexcept Exception as e:\n  raise e from RuntimeError(\n      'Something went wrong during installation. Check the shell output above '\n      'for more information.\\n'\n      'If using a hosted Colab runtime, make sure you enable GPU acceleration '\n      'by going to the Runtime menu and selecting \"Choose runtime type\".')\n\nprint('Installation successful.')\n\n# Other imports and helper functions\nimport time\nimport itertools\nimport numpy as np\n\n# Graphics and plotting.\nprint('Installing mediapy:')\n!command -v ffmpeg &gt;/dev/null || (apt update &amp;&amp; apt install -y ffmpeg)\n!pip install -q mediapy\nimport mediapy as media\nimport matplotlib.pyplot as plt\n\n# More legible printing from numpy.\nnp.set_printoptions(precision=3, suppress=True, linewidth=100)\n\nfrom IPython.display import clear_output\nclear_output()\n\nStep 1: Klann kinematics definition cell\n\n# Compute Jacobian (d foot_pos / d theta_crank) via finite differences\nimport numpy as np\n\n# Example: placeholder function for foot position of a Klann mechanism\n# Replace with your actual linkage geometry\n\ndef klann_positions(theta):\n    A = np.array([0.0, 0.0])\n    r = 0.030\n    crank_end = A + r * np.array([np.cos(theta), np.sin(theta)])\n    l_coupler = 0.065\n    coupler_angle = theta - 0.45\n    X = crank_end + l_coupler * np.array([np.cos(coupler_angle), np.sin(coupler_angle)])\n    l_main = 0.085\n    main_angle = theta + 0.6\n    Y = X + l_main * np.array([np.cos(main_angle), np.sin(main_angle)])\n    l_follower = 0.055\n    follower_angle = main_angle - 0.9\n    follower_end = Y + l_follower * np.array([np.cos(follower_angle), np.sin(follower_angle)])\n    l_foot = 0.035\n    foot_angle = follower_angle - 0.2\n    foot = follower_end + l_foot * np.array([np.cos(foot_angle), np.sin(foot_angle)])\n    return {\n        \"A\": A,\n        \"crank_end\": crank_end,\n        \"X\": X,\n        \"Y\": Y,\n        \"follower_end\": follower_end,\n        \"foot\": foot\n    }\n\n# Numerical derivative\ndef dfoot_dtheta(theta, h=1e-6):\n    p0 = klann_positions(theta)\n    f0 = p0[\"foot\"]\n    p1 = klann_positions(theta + h)\n    f1 = p1[\"foot\"]\n    return (f1 - f0) / h\n\n# Test\ntheta = 0.3\nJtheta = dfoot_dtheta(theta)\nprint(\"d(foot)/d(theta) at theta=0.3:\", Jtheta)\n\nimport mujoco\nimport numpy as np\nimport matplotlib\nimport sympy\nprint(\"\u2705 All core dependencies are available and working!\")\n</code></pre> <p>Step 2: Computer acutuator torque from foot force per lec and power</p> <pre><code># Compute actuator torque from foot force (per leg) and power\ntheta = 0.3\nJt = dfoot_dtheta(theta)\nF_foot = np.array([0.0, 3.924])  # N (vertical)\ntau = np.dot(Jt, F_foot)\nomega = 6.0  # rad/s example\npower = tau * omega\nprint(f\"Crank torque required (Nm) at theta={theta:.3f}: {tau:.4f} N\u00b7m\")\nprint(f\"Mechanical power at crank (W) for omega={omega} rad/s: {power:.4f} W\")\n</code></pre>"},{"location":"#6-plots-figures","title":"6 \u2014 Plots &amp; Figures","text":"<p>Use matplotlib to create plots (GRF plots, kinematic traces, energy/power curves).</p> <p>As we try to solve section 6, we created two versions.</p> <p>Below is version 1 for the whole robot: We added the following constranits:</p> <pre><code>    mjcf.append('  &lt;equality&gt;')\n    mjcf.append('    &lt;weld name=\"weld1\" active=\"true\" body1=\"A\" body2=\"Ap\"')\n    mjcf.append('           relpose=\"0 0 0 1 0 0 0\" anchor=\"0 0 0\" /&gt;')\n    mjcf.append('  &lt;/equality&gt;')\n</code></pre> <p>Below is the code:  </p><pre><code># MJCF generator for Klann hexapod (approximate multi-body representation)\nimport textwrap, os, numpy as _np\nparams_local = {\n    \"l_crank\": 0.025,\n    \"l_coupler1\": 0.06,\n    \"l_coupler2\": 0.045,\n    \"l_follower\": 0.09\n}\ndef generate_klann_hexapod_mjcf(params, phase_offsets=None):\n    if phase_offsets is None:\n        phase_offsets = [0.0, _np.pi, 0.0, _np.pi, 0.0, _np.pi]\n    mjcf = []\n    mjcf.append('&lt;mujoco model=\"klann_hexapod\"&gt;')\n    mjcf.append('  &lt;compiler angle=\"radian\"/&gt;')\n    mjcf.append('  &lt;option gravity=\"0 0 -9.81\"/&gt;')\n    mjcf.append('  &lt;worldbody&gt;')\n    mjcf.append('    &lt;body name=\"torso\" pos=\"0 0 0.06\"&gt;')\n    mjcf.append('      &lt;geom name=\"torso_geom\" type=\"box\" size=\".09 .07 .03\" rgba=\"0.3 0.6 0.8 1\"/&gt;')\n    leg_mounts = [ (0.055, 0.06), (0.0, 0.07), (-0.055, 0.06),\n                   (0.055, -0.06), (0.0, -0.07), (-0.055, -0.06) ]\n    for i,(mx,my) in enumerate(leg_mounts):\n        mjcf.append(f'    &lt;body name=\"leg{i}_mount\" pos=\"{mx} {my} 0.06\"&gt;')\n        mjcf.append(f'      &lt;joint name=\"crank{i}\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append('      &lt;body name=\"crank_link\" pos=\"0 0 0\"&gt;')\n        mjcf.append(f'        &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_crank\"]} 0 0\" size=\"0.006\"/&gt;')\n        mjcf.append(f'        &lt;body name=\"coupler1\" pos=\"{params[\"l_crank\"]} 0 0\"&gt;')\n        mjcf.append('          &lt;joint name=\"j1\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append(f'          &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_coupler1\"]} 0 0\" size=\"0.006\"/&gt;')\n        mjcf.append(f'          &lt;body name=\"coupler2\" pos=\"{params[\"l_coupler1\"]} 0 0\"&gt;')\n        mjcf.append('            &lt;joint name=\"j2\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append(f'            &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_coupler2\"]} 0 0\" size=\"0.006\"/&gt;')\n        mjcf.append(f'            &lt;body name=\"follower\" pos=\"{params[\"l_coupler2\"]} 0 0\"&gt;')\n        mjcf.append('              &lt;joint name=\"j3\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append(f'              &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_follower\"]} 0 0\" size=\"0.008\"/&gt;')\n        mjcf.append(f'              &lt;site name=\"foot\" pos=\"{params[\"l_follower\"]} 0 -0.01\" size=\"0.01\"/&gt;')\n        mjcf.append('            &lt;/body&gt;')\n        mjcf.append('          &lt;/body&gt;')\n        mjcf.append('        &lt;/body&gt;')\n        mjcf.append('      &lt;/body&gt;')\n        mjcf.append('    &lt;/body&gt;')\n    mjcf.append('    &lt;/body&gt;')\n    mjcf.append('  &lt;/worldbody&gt;')\n    mjcf.append('  &lt;actuator&gt;')\n    for i in range(6):\n        mjcf.append(f'    &lt;motor name=\"crankm{i}\" joint=\"crank{i}\" gear=\"100\"/&gt;')\n    mjcf.append('  &lt;/actuator&gt;')\n    mjcf.append('  &lt;equality&gt;')\n    mjcf.append('    &lt;weld name=\"weld1\" active=\"true\" body1=\"A\" body2=\"Ap\"')\n    mjcf.append('           relpose=\"0 0 0 1 0 0 0\" anchor=\"0 0 0\" /&gt;')\n    mjcf.append('  &lt;/equality&gt;')\n    mjcf.append('&lt;/mujoco&gt;')\n    return \"\\n\".join(mjcf)\n\nxml = generate_klann_hexapod_mjcf(params_local)\nopen(\"klann_hexapod.xml\",\"w\").write(xml)\nprint(\"MJCF saved to klann_hexapod.xml (length):\", len(xml))\n\n# Try loading the MJCF in MuJoCo\ntry:\n    import mujoco\n    model = mujoco.MjModel.from_xml_path(\"klann_hexapod.xml\")\n    sim = mujoco.MjSim(model)\n    print(\"MuJoCo loaded mjcf. model.nq=\", model.nq)\n    print(\"MuJoCo ready. For interactive visualization run: mujoco.viewer.launch(sim)\")\nexcept Exception as e:\n    print(\"MuJoCo not available or failed to load in this runtime:\", e)\n    print(\"Proceed to fallback plotting in the next cell.\")\n\n    # Fallback visualization: plot Klann legs for 6 mounting points (pure Python plotting)\nimport matplotlib.pyplot as plt\nleg_mounts = [ (0.055, 0.06), (0.0, 0.07), (-0.055, 0.06),\n               (0.055, -0.06), (0.0, -0.07), (-0.055, -0.06) ]\nplt.figure(figsize=(8,8))\ntorso_x = [-0.09, 0.09, 0.09, -0.09, -0.09]\ntorso_y = [-0.07, -0.07, 0.07, 0.07, -0.07]\nplt.plot(torso_x, torso_y, 'k-')\nfor i,(mx,my) in enumerate(leg_mounts):\n    theta = 0.0 + (np.pi if (i%2)==1 else 0.0)\n    pos = klann_positions(theta)\n    ptsx = [pos[\"A\"][0]+mx, pos[\"crank_end\"][0]+mx, pos[\"X\"][0]+mx, pos[\"Y\"][0]+mx, pos[\"follower_end\"][0]+mx, pos[\"foot\"][0]+mx]\n    ptsy = [pos[\"A\"][1]+my, pos[\"crank_end\"][1]+my, pos[\"X\"][1]+my, pos[\"Y\"][1]+my, pos[\"follower_end\"][1]+my, pos[\"foot\"][1]+my]\n    plt.plot([ptsx[0], ptsx[1]], [ptsy[0], ptsy[1]], 'r-')\n    plt.plot([ptsx[1], ptsx[2]], [ptsy[1], ptsy[2]], 'g-')\n    plt.plot([ptsx[2], ptsx[3]], [ptsy[2], ptsy[3]], 'b-')\n    plt.plot([ptsx[3], ptsx[4]], [ptsy[3], ptsy[4]], 'm-')\n    plt.plot(ptsx[-1], ptsy[-1], 'ko')\nplt.gca().set_aspect('equal', 'box')\nplt.title(\"Hexapod with Klann-style Leg Approx (single phase shown per leg)\")\nplt.xlabel(\"x (m)\")\nplt.ylabel(\"y (m)\")\nplt.show()\n</code></pre><p></p> <p>Sweep crank angle &amp; compute required crank torque for a given vertical foot force </p><pre><code>import numpy as np\nthetas = np.linspace(0, 2*np.pi, 101)\ntorques = []\nF_foot = np.array([0.0, 3.924])\nfor th in thetas:\n    Jt = dfoot_dtheta(th)\n    tau = np.dot(Jt, F_foot)\n    torques.append(tau)\ntorques = np.array(torques)\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(6,3))\nplt.plot(thetas, torques)\nplt.xlabel(\"crank angle (rad)\")\nplt.ylabel(\"required crank torque (N\u00b7m)\")\nplt.title(\"Torque vs Crank Angle (per leg)\")\nplt.grid(True)\nplt.show()\nprint(\"Torque stats: min {:.4f} Nm, max {:.4f} Nm\".format(torques.min(), torques.max()))\n</code></pre><p></p> <p>Below is version 2 based on one leg kinematics:</p> <p>The second version is based on Prof. Aukes' suggestion on working one-leg's kinematics. We do not have xml file for it, and we also ran out of time. </p><pre><code>import numpy as np, math\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass\n\nR_MB = 1.0    # MB crank\nL_BC = 4.2    # long link BC\nL_AC = 4.2    # long link AC\nL_DE = 2.1    # struts: DE = DF\nMD    = 2.1   # |M - D| = 2\n\nINCH_TO_M = 0.0254\n\n# Ground points\nM = np.array([0.0, 0.0])\nD = np.array([-MD, 0.0])   # D is 2 in to the left of M\n\n\ndef B_of_theta(theta: float) -&gt; np.ndarray:\n    \"\"\"Motor-driven point B on the 1-inch crank around M.\"\"\"\n    return M + R_MB*np.array([np.cos(theta), np.sin(theta)])\n\n@dataclass\nclass Pose:\n    A: np.ndarray\n    C: np.ndarray\n    B: np.ndarray\n    E: np.ndarray\n    F: np.ndarray\n\ndef residual(u: np.ndarray, theta: float) -&gt; np.ndarray:\n    \"\"\"\n    f(u,\u03b8) with u=[Ax,Ay,Cx,Cy]:\n      1) |C-B| = L_BC\n      2) |C-A| = L_AC\n      3) |E-D| = L_DE,  E=(A+C)/2\n      4) |F-D| = L_DE,  F=(B+C)/2\n    \"\"\"\n    Ax,Ay,Cx,Cy = u\n    A = np.array([Ax,Ay])\n    C = np.array([Cx,Cy])\n    B = B_of_theta(theta)\n    E = 0.5*(A + C)\n    F = 0.5*(B + C)\n    r1 = np.sum((C - B)**2) - L_BC**2\n    r2 = np.sum((C - A)**2) - L_AC**2\n    r3 = np.sum((E - D)**2) - L_DE**2\n    r4 = np.sum((F - D)**2) - L_DE**2\n    return np.array([r1,r2,r3,r4], dtype=float)\n\ndef Ju_matrix(u: np.ndarray, theta: float) -&gt; np.ndarray:\n    \"\"\"Analytic \u2202f/\u2202u (4x4) for Newton solve.\"\"\"\n    Ax,Ay,Cx,Cy = u\n    A = np.array([Ax,Ay]); C = np.array([Cx,Cy]); B = B_of_theta(theta)\n    E = 0.5*(A + C)\n    F = 0.5*(B + C)\n\n    CB = C - B\n    CA = C - A\n    ED = E - D\n    FD = F - D\n\n    Ju = np.zeros((4,4), dtype=float)\n    # f1: |C-B|^2 -&gt; wrt C\n    Ju[0,2:4] = 2.0*CB\n    # f2: |C-A|^2 -&gt; wrt A and C\n    Ju[1,0:2] = -2.0*CA\n    Ju[1,2:4] =  2.0*CA\n    # f3: |(A+C)/2 - D|^2 -&gt; wrt A and C (both via E)\n    Ju[2,0:2] = ED\n    Ju[2,2:4] = ED\n    # f4: |(B+C)/2 - D|^2 -&gt; wrt C (via F)\n    Ju[3,2:4] = FD\n    return Ju\n\ndef Jtheta_vector(u: np.ndarray, theta: float) -&gt; np.ndarray:\n    \"\"\"Analytic \u2202f/\u2202\u03b8 (4x1). Only f1 and f4 depend on B(\u03b8).\"\"\"\n    Cx,Cy = u[2], u[3]\n    C = np.array([Cx,Cy]); B = B_of_theta(theta)\n    dB = R_MB*np.array([-np.sin(theta), np.cos(theta)])  # dB/d\u03b8\n    CB = C - B\n    F  = 0.5*(B + C)\n    Jth = np.zeros((4,1), dtype=float)\n    # f1: |C-B|^2 -&gt; -2(C-B)\u00b7dB/d\u03b8\n    Jth[0,0] = -2.0 * np.dot(CB, dB)\n    # f4: 2(F-D)\u00b7(\u2202F/\u2202\u03b8) = 2(F-D)\u00b7(0.5 dB/d\u03b8)\n    Jth[3,0] = 2.0 * np.dot(F - D, 0.5*dB)\n    return Jth\n\n\ndef solve_pose(theta: float, guess: np.ndarray=None,\n               max_iter=60, tol=1e-10) -&gt; Pose:\n    B = B_of_theta(theta)\n    if guess is None:\n        # simple heuristic seed near B\n        C0 = B + np.array([-L_BC*0.7,  L_BC*0.3])\n        A0 = C0 + np.array([-L_AC*0.6, -L_AC*0.6])\n        guess = np.hstack([A0, C0])\n\n    u = guess.astype(float).copy()\n    f = residual(u, theta)\n    for _ in range(max_iter):\n        if np.linalg.norm(f) &lt; tol:\n            break\n        Ju = Ju_matrix(u, theta)\n        # Solve normal equations with tiny damping\n        reg = 1e-12*np.eye(4)\n        try:\n            delta = -np.linalg.solve(Ju.T@Ju + reg, Ju.T@f)\n        except np.linalg.LinAlgError:\n            delta = -np.linalg.pinv(Ju) @ f\n        # backtracking line search\n        t = 1.0\n        norm0 = np.linalg.norm(f)\n        while t &gt; 1e-4:\n            u_try = u + t*delta\n            f_try = residual(u_try, theta)\n            if np.linalg.norm(f_try) &lt; norm0*(1 - 1e-4*t):\n                u, f = u_try, f_try\n                break\n            t *= 0.5\n        else:\n            u = u + 1e-3*delta\n            f = residual(u, theta)\n\n    if np.linalg.norm(f) &gt; 1e-6:\n        raise RuntimeError(\"Solve failed or infeasible at this theta.\")\n\n    Ax,Ay,Cx,Cy = u\n    A = np.array([Ax,Ay]); C = np.array([Cx,Cy]); B = B_of_theta(theta)\n    E = 0.5*(A + C); F = 0.5*(B + C)\n    return Pose(A=A, C=C, B=B, E=E, F=F)\n\ndef jacobian_A(theta: float, pose: Pose) -&gt; np.ndarray:\n    \"\"\"\n    From f(u,\u03b8)=0: du/d\u03b8 = -J_u^{-1} J_\u03b8 -&gt; take first two rows (A_x,A_y).\n    Returns (2x1) inches/rad.\n    \"\"\"\n    u = np.hstack([pose.A, pose.C])\n    Ju = Ju_matrix(u, theta)\n    Jth = Jtheta_vector(u, theta)\n    du_dtheta = -np.linalg.solve(Ju, Jth)   # (4x1)\n    return du_dtheta[0:2,:]                 # dA/d\u03b8\n\n# =========================\n# Velocity / Force maps\n# =========================\ndef motor_tau_from_FA(theta: float, F_world_N: np.ndarray, pose: Pose) -&gt; float:\n    J = jacobian_A(theta, pose) * INCH_TO_M\n    return (J.T @ F_world_N.reshape(2,1)).item()   # N\u00b7m\n\ndef motor_speed_for_vA(theta: float, vA_mps: np.ndarray, pose: Pose) -&gt; float:\n    J = jacobian_A(theta, pose) * INCH_TO_M\n    JTJ = (J.T @ J).item()\n    if JTJ &lt; 1e-12:\n        raise RuntimeError(\"Near singular configuration for velocity mapping.\")\n    return (J.T @ vA_mps.reshape(2,1)).item() / JTJ\n\n# =========================\n# Quick viz &amp; demo\n# =========================\ndef plot_pose(theta: float, pose: Pose, ax=None, label_once=False):\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(6,3.8))\n    A,C,B,E,F = pose.A,pose.C,pose.B,pose.E,pose.F\n    # bars\n    ax.plot([M[0], B[0]],[M[1], B[1]], 'C3-', lw=2, label='MB=1' if label_once else None)\n    ax.plot([B[0], C[0]],[B[1], C[1]], 'C0-', lw=2, label='BC=4.2' if label_once else None)\n    ax.plot([A[0], C[0]],[A[1], C[1]], 'C0-', lw=2, label='AC=4.2' if label_once else None)\n    ax.plot([D[0], E[0]],[D[1], E[1]], 'C1-', lw=2, label='DE=2.1' if label_once else None)\n    ax.plot([D[0], F[0]],[D[1], F[1]], 'C1-', lw=2, label='DF=2.1' if label_once else None)\n    # points\n    ax.plot(*M,'ko'); ax.text(*M,' M', va='bottom')\n    ax.plot(*D,'ko'); ax.text(*D,' D', va='bottom')\n    ax.plot(*B,'x', color='C3'); ax.text(B[0], B[1], ' B', va='bottom', color='C3')\n    ax.plot(*C,'x', color='C0'); ax.text(C[0], C[1], ' C', va='bottom', color='C0')\n    ax.plot(*A,'x', color='C2'); ax.text(A[0], A[1], ' A', va='bottom', color='C2')\n    ax.plot(*E,'o', mfc='none', color='C1'); ax.text(E[0], E[1], ' E', va='bottom', color='C1')\n    ax.plot(*F,'o', mfc='none', color='C1'); ax.text(F[0], F[1], ' F', va='bottom', color='C1')\n    ax.set_aspect('equal', adjustable='box')\n    ax.grid(True, ls=':')\n    ax.set_xlabel('x (in)'); ax.set_ylabel('y (in)')\n    ax.set_title('Kinematic Model of One Leg')\n    return ax\n\nif __name__ == \"__main__\":\n    # sweep theta, solve and warm-start\n    TH = np.linspace(-np.pi, np.pi, 540, endpoint=False)\n    poses, thetas = [], []\n    guess = None\n    for th in TH:\n        try:\n            p = solve_pose(th, guess)\n            poses.append(p); thetas.append(th)\n            guess = np.hstack([p.A, p.C])   # warm start\n        except RuntimeError:\n            pass\n\n    # plot a few poses + A locus\n    fig, ax = plt.subplots(figsize=(6.4, 3.8))\n    if poses:\n        idxs = np.linspace(0, len(poses)-1, 4, dtype=int)\n        for i, k in enumerate(idxs):\n            plot_pose(thetas[k], poses[k], ax=ax, label_once=(i==0))\n        A_path = np.array([p.A for p in poses])\n        ax.plot(A_path[:,0], A_path[:,1], '0.6', lw=1, label='A locus')\n        ax.legend()\n    else:\n        ax.text(0.5,0.5,\"No feasible poses with current geometry.\",ha='center',va='center',transform=ax.transAxes)\n    plt.tight_layout(); plt.show()\n\n    # report numbers at one feasible pose (if exists)\n    if poses:\n        k = len(poses)//3\n        th, p = thetas[k], poses[k]\n        J = jacobian_A(th, p) * INCH_TO_M\n        Fg = np.array([0.0, 120.0])  # example GRF\n        vA = np.array([0.40, 0.00])  # desired A speed\n        tau  = motor_tau_from_FA(th, Fg, p)\n        omega = motor_speed_for_vA(th, vA, p)\n        print(f\"\u03b8={np.rad2deg(th):.1f}\u00b0 | A={p.A} in | |J|={np.linalg.norm(J):.3e} m/rad\")\n        print(f\"\u03c4={tau:.2f} N\u00b7m, \u03c9={omega:.2f} rad/s, P\u2248{tau*omega:.2f} W\")\n\n&lt;img width=\"391\" height=\"370\" alt=\"image\" src=\"https://github.com/user-attachments/assets/47de986f-4611-497e-94d3-eeb7b416257e\" /&gt;\n</code></pre><p></p> <p>Version 2 Explanation:</p> <p>How the figure was generated - Mechanism: closed-loop four-bar with two midpoint struts (pure kinematics; no mass, stiffness, or gravity). - Fixed anchors: \\(M=(0,0)\\), \\(D=(-d,0)\\) with \\(d=2\\,\\text{in}\\). - Link lengths: \\(MB=r=1\\,\\text{in}\\), \\(AC=BC=L=4.2\\,\\text{in}\\), \\(DE=DF=s=2.1\\,\\text{in}\\). - For each motor angle \\(\\theta\\),</p> \\[ B(\\theta)=\\big(r\\cos\\theta,\\; r\\sin\\theta\\big). \\] <ul> <li>Unknowns \\(x=[A_x,A_y,C_x,C_y]^T\\) are solved from the closure system</li> </ul> \\[ \\begin{aligned} \\|C-B\\|^2&amp;=L^2,\\qquad \\|C-A\\|^2=L^2, \\\\ \\left\\|\\tfrac{A+C}{2}-D\\right\\|^2&amp;=s^2,\\qquad \\left\\|\\tfrac{B+C}{2}-D\\right\\|^2=s^2, \\end{aligned} \\] <p>which yields \\(A(\\theta),\\; C(\\theta)\\). Midpoints: \\(E=\\tfrac12(A+C)\\), \\(F=\\tfrac12(B+C)\\). Sweeping \\(\\theta\\) and plotting bodies produces colored poses; the gray curve is the locus of \\(A(\\theta)\\).</p> <p>What the figure shows - Red: crank \\(MB\\); blue: long links \\(AC, BC=L\\); orange: midpoint struts \\(DE, DF=s\\). - Labeled points: \\(A,B,C,D,E,F,M\\). - Gray path: foot-point trajectory \\(A(\\theta)\\) generated by geometric coupling of the four-bar and struts.</p> <p>Differential/force relations (for analysis and reporting)</p> <p>Implicit differentiation of \\(F(x,\\theta)=0\\):</p> \\[ \\frac{dx}{d\\theta} = -\\Big(\\frac{\\partial F}{\\partial x}\\Big)^{-1}\\frac{\\partial F}{\\partial \\theta}, \\qquad J_A(\\theta)=\\frac{dA}{d\\theta}\\in\\mathbb{R}^{2\\times 1}. \\] <p>Velocity, torque, and power mappings:</p> \\[ \\dot A = J_A\\,\\dot\\theta,\\qquad \\tau = J_A^{\\!\\top} F_A,\\qquad P=\\tau\\,\\dot\\theta . \\] <p>Units: inches above for geometry; convert to meters when required for computation.</p> <p>3) Motor sizing recipe (practical engineering steps + formula)</p> <p>We compute required motor torque from the foot force via the Jacobian mapping of crank angle to foot position:</p> <p>Motor Torque Calculation and Sizing</p> <p>The required crank torque is derived from the virtual work relationship:</p> \\[ \\tau_{\\text{crank}}(\\theta) = \\mathbf{J}_\\theta(\\theta)^{\\top} \\mathbf{F}_{\\text{foot}} \\] <p>where:</p> <ul> <li><code>J_theta</code> = partial derivative of foot position (2D vector) with respect to crank angle (a 2\u00d71 vector).  </li> <li><code>F_foot</code> = foot force vector in world frame (e.g., vertical support force).</li> </ul> <p>Motor torque accounting for gearbox and efficiency</p> <p>If the motor is connected to the crank through a gearbox of ratio <code>G</code> (gear ratio &gt; 1 multiplies torque), and the overall drivetrain efficiency is <code>\u03b7</code> (0 &lt; \u03b7 \u2264 1), with a safety margin <code>M</code> (e.g., 2), the required motor stall torque rating should be:</p> \\[ \\tau_{\\text{motor,rated}} = \\frac{|\\tau_{\\text{crank,max}}|}{G \\, \\eta} \\times M \\] <p>where:</p> <ul> <li><code>\u03c4_crank,max</code> \u2014 peak crank torque from sweep over crank angle (computed in Cell 8).  </li> <li><code>G</code> \u2014 gearbox ratio (e.g., 10 for 10:1).  </li> <li><code>\u03b7</code> \u2014 drivetrain efficiency (e.g., 0.7).  </li> <li><code>M</code> \u2014 safety margin (e.g., 2).</li> </ul> <p>Motor Speed &amp; Electrical Power</p> <p>If peak mechanical power required at the crank is <code>P_mech = \u03c4_crank * \u03c9_crank</code>, then the required electrical power (ignoring motor electrical losses) is roughly:</p> \\[ P_{elec} \\approx \\frac{P_{mech}}{\\eta} \\] <p>After gearbox, the motor angular rate is <code>\u03c9_motor = G * \u03c9_crank</code> (because the gearbox reduces speed by <code>G</code> when geared for torque).</p> <p>Worked Numeric Example</p> <ul> <li>Suppose <code>\u03c4_crank,max = 0.35 N\u00b7m</code> (from torque sweep).  </li> <li>Choose <code>G = 10</code>, <code>\u03b7 = 0.7</code>, <code>M = 2</code>.</li> </ul> <p>Then the rated motor torque requirement is:</p> \\[ \\tau_{\\text{motor,rated}} = \\frac{0.35}{10 \\times 0.7} \\times 2 = 0.10 \\, \\text{N\u00b7m} \\] <p>and if the crank angular speed is <code>\u03c9_crank = 6 rad/s</code>, then:</p> \\[ \u03c9_{\\text{motor}} = G \\times \u03c9_{\\text{crank}} = 10 \\times 6 = 60 \\text{rad/s} \\ (\\approx 572 RPM) \\] <p>After gearbox, motor angular rate is \u03c9_motor = G * \u03c9_crank (because gearbox reduces speed by G if geared for torque).</p> <p>Then:</p> <pre><code>tau_motor_rated = (0.35 / (10 * 0.7)) * 2 = (0.35 / 7) * 2 = 0.05 * 2 = 0.10 N\u00b7m\n</code></pre> <p>So choose a motor with continuous torque \u2265 0.10 N\u00b7m (plus check stall and peak currents). If motor speed needed: if \u03c9_crank = 6 rad/s, \u03c9_motor = 60 rad/s (~572 RPM). Check motor torque-speed curve to ensure it can supply torque at that speed.</p>"},{"location":"#7-discussion-points","title":"7 \u2014 Discussion Points","text":"<ol> <li>Degrees of freedom and number of motors.</li> <li>How end-effector forces were estimated.</li> <li>How end-effector speeds were estimated.</li> </ol> <p>7.1. Degrees of Freedom and Number of Motors</p> <p>The Klann mechanism used in this design is a planar six-bar linkage that transforms a single rotary input into an approximately linear foot trajectory. Each leg therefore has one degree of freedom (DOF)\u2014the input crank rotation. Since the robot uses six legs, the total system has six actuated DOFs, each driven by one motor connected to the crankshaft of its respective leg. The overall body motion is coordinated through synchronized crank phasing (e.g., tripod gait: left-front, right-middle, left-rear in one phase). Passive joints within each linkage do not require additional motors, which simplifies control and reduces weight and cost compared to a multi-DOF leg design.</p> <p>7.2. How End-Effector Forces Were Estimated</p> <p>End-effector (foot) forces were estimated based on biomechanical scaling and dynamic load distribution during a tripod gait. Assuming the robot mass is 0.8 kg, the total gravitational load is approximately 7.85 N. During stance, three legs support the robot, so each stance leg bears roughly one-third of that load. To account for dynamic impacts and acceleration during gait, a safety factor of 1.5\u00d7 was applied, giving a peak ground reaction force (GRF) of \u2248 3.9 N per leg. This vertical force was used in the Jacobian relationship \\(\\tau = J^T F_{\\text{foot}}\\) to estimate crank torque. The foot force vector was defined in local leg coordinates as \\( [0, 3.9]^T \\) N (purely vertical) for simplicity.</p> <p>7.3. How End-Effector Speeds Were Estimated</p> <p>Foot speeds were derived from the Jacobian matrix of the leg mechanism. By differentiating the foot position vector with respect to crank angle (\\( \\mathbf{J}_\\theta = \\frac{\\partial \\mathbf{x}_{foot}}{\\partial \\theta} \\)) and multiplying by the crank angular velocity (\\( \\dot{\\theta} \\)), the instantaneous foot velocity was computed: $$ \\mathbf{v}{foot} = \\mathbf{J}\\theta \\, \\dot{\\theta} $$ The crank angular velocity was chosen as 6 rad/s, corresponding to a walking speed of approximately 0.3 m/s based on the stride length (0.1 m) and step frequency (\u2248 3 Hz). This kinematic relationship allows prediction of foot motion through the gait cycle and was verified via the MuJoCo simulation, confirming realistic lift and stance trajectories for the desired gait speed.</p>"},{"location":"#project-files","title":"Project Files:","text":"<ul> <li>Option 1: Download the .ipynb file </li> </ul> <p>Download Assignment 1 Notebook (.ipynb)</p> <ul> <li>Option 2: Download the .pdf file</li> </ul> <p>Download Assignment 1 Report (PDF)</p>"},{"location":"Project_Assignment_2/","title":"Assignment 2","text":""},{"location":"Project_Assignment_2/#title-project-assignment-2","title":"title: Project Assignment 2","text":""},{"location":"Project_Assignment_2/#demonstrating-robot-kinematics","title":"Demonstrating Robot Kinematics:","text":""},{"location":"Project_Assignment_2/#measuring-friction","title":"Measuring Friction:","text":""},{"location":"Project_Assignment_2/#downloading-the-dxf-file","title":"Downloading the .dxf file:","text":"<p>Download the layser cutting .dxf file</p>"},{"location":"Project_Assignment_2/#downloading-the-file-making-process-instructions","title":"Downloading the file making process instructions","text":"<p>Download the file making instructions</p>"},{"location":"Project_Assignment_2/#laser-cut-robot-photos","title":"Laser Cut Robot Photos:","text":""},{"location":"charts/","title":"Charts","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre>"},{"location":"esp-32-table/","title":"ESP32 Table","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Found on Espressif.com ESP32-S3-WROOM-1-N4 Datasheet URL ? Do not paste links directly into the table.  Use a link ESP32 S3 Datasheet URL ? Has more detail on functions ESP32 S3 Technical Reference Manual URL ? Has details on I/O multiplexing, USB, and others Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find on Digikey, Jameco, MPJA, or octopart Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? as found in datasheet Module # Available Needed Associated Pins (or * for any) UART ? ? ? external SPI* ? ? ? I2C ? ? ? GPIO ? ? ? ADC ? ? ? LED PWM ? ? ? Motor PWM ? ? ? USB Programmer ? 1 ? ... <p>* The ESP32-S2 has multiple SPI interfaces, but some are for internal use</p>"},{"location":"pic-table/","title":"PIC Table","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Do not paste links directly into the table.  Use a link Datasheet URL(s) ? Do not paste links directly into the table.  Use a link Application Notes URL(s) ? Do not paste links directly into the table.  Use a link Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find in the Microchip online store, or Digikey Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? found on the microcontroller's product page Works with MPLabX? ? Required.  See Microchip Development Tools Works with Microchip Code Configurator? ? Can be validated in MPLabX.  Screenshot required. Module # Available Needed Associated Pins (or * for any) GPIO ? ? ? ADC ? ? ? UART ? ? ? SPI ? ? ? I2C ? ? ? PWM ? ? ? ICSP ? 1 ? ... ... ... ..."},{"location":"component-selection-example/","title":"Component Selection Example","text":""},{"location":"component-selection-example/#examples","title":"Examples","text":""},{"location":"component-selection-example/#style-1","title":"Style 1","text":"<p>This is the example found in the assignment, uses more html</p> <p>Table 1: Example component selection</p> <p>External Clock Module</p> Solution Pros Cons Option 1. XC1259TR-ND surface mount crystal$1/eachlink to product * Inexpensive[^1]* Compatible with PSoC* Meets surface mount constraint of project * Requires external components and support circuitry for interface* Needs special PCB layout. * Option 2. * CTX936TR-ND surface mount oscillator * $1/each * Link to product * Outputs a square wave * Stable over operating temperature  * Direct interface with PSoC (no external circuitry required) range * More expensive * Slow shipping speed <p>Choice: Option 2: CTX936TR-ND surface mount oscillator</p> <p>Rationale: A clock oscillator is easier to work with because it requires no external circuitry in order to interface with the PSoC. This is particularly important because we are not sure of the electrical characteristics of the PCB, which could affect the oscillation of a crystal. While the shipping speed is slow, according to the website if we order this week it will arrive within 3 weeks.</p>"},{"location":"component-selection-example/#style-2","title":"Style 2","text":"<p>Also acceptable, more markdown friendly</p> <p>External Clock Module</p> <ol> <li> <p>XC1259TR-ND surface mount crystal</p> <p></p> <ul> <li>$1/each</li> <li>link to product</li> </ul> Pros Cons Inexpensive Requires external components and support circuitry for interface Compatible with PSoC Needs special PCB layout. Meets surface mount constraint of project </li> <li> <p>CTX936TR-ND surface mount oscillator</p> <p></p> <ul> <li>$1/each</li> <li>Link to product</li> </ul> Pros Cons Outputs a square wave More expensive Stable over operating temperature Slow shipping speed Direct interface with PSoC (no external circuitry required) range </li> </ol> <p>Choice: Option 2: CTX936TR-ND surface mount oscillator</p> <p>Rationale: A clock oscillator is easier to work with because it requires no external circuitry in order to interface with the PSoC. This is particularly important because we are not sure of the electrical characteristics of the PCB, which could affect the oscillation of a crystal. While the shipping speed is slow, according to the website if we order this week it will arrive within 3 weeks.</p>"},{"location":"static/node_modules/mathjax/","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#mathjax","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#beautiful-math-in-all-browsers","title":"Beautiful math in all browsers","text":"<p>MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.  It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems.  It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily.  Simply include MathJax and some mathematics in a web page, and MathJax does the rest.</p> <p>Some of the main features of MathJax include:</p> <ul> <li> <p>High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages</p> </li> <li> <p>Supported in most browsers with no plug-ins, extra fonts, or special   setup for the reader</p> </li> <li> <p>Easy for authors, flexible for publishers, extensible for developers</p> </li> <li> <p>Supports math accessibility, cut-and-paste interoperability, and other   advanced functionality</p> </li> <li> <p>Powerful API for integration with other web applications</p> </li> </ul> <p>See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.</p>"},{"location":"static/node_modules/mathjax/#mathjax-components","title":"MathJax Components","text":"<p>MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS.  Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way.  For usage instructions, see the MathJax documentation.</p> <p>Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server.  There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.</p>"},{"location":"static/node_modules/mathjax/#whats-in-this-repository","title":"What's in this Repository","text":"<p>This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository).  These component files are the ones served by the CDNs that offer MathJax to the web.  In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser.</p> <p>The components are stored in the <code>es5</code> directory, and are in ES5 format for the widest possible compatibility.  In the future, we may make an <code>es6</code> directory containing ES6 versions of the components.</p>"},{"location":"static/node_modules/mathjax/#installation-and-use","title":"Installation and Use","text":""},{"location":"static/node_modules/mathjax/#using-mathjax-components-from-a-cdn-on-the-web","title":"Using MathJax components from a CDN on the web","text":"<p>If you are loading MathJax from a CDN into a web page, there is no need to install anything.  Simply use a <code>script</code> tag that loads MathJax from the CDN.  E.g.,</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>See the MathJax documentation, the MathJax Web Demos, and the MathJax Component Repository for more information.</p>"},{"location":"static/node_modules/mathjax/#hosting-your-own-copy-of-the-mathjax-components","title":"Hosting your own copy of the MathJax Components","text":"<p>If you want to host MathJax from your own server, you can do so by installing the <code>mathjax</code> package using <code>npm</code> and moving the <code>es5</code> directory to an appropriate location on your server:</p> <pre><code>npm install mathjax@3\nmv node_modules/mathjax/es5 &lt;path-to-server-location&gt;/mathjax\n</code></pre> <p>Note that we are still making updates to version 2, so include <code>@3</code> when you install, since the latest chronological version may not be version 3.</p> <p>Alternatively, you can get the files via GitHub:</p> <pre><code>git clone https://github.com/mathjax/MathJax.git mj-tmp\nmv mj-tmp/es5 &lt;path-to-server-location&gt;/mathjax\nrm -rf mj-tmp\n</code></pre> <p>Then (in either case) you can use a script tag like the following:</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"&lt;url-to-your-site&gt;/mathjax/tex-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>where <code>&lt;url-to-your-site&gt;</code> is replaced by the URL to the location where you moved the MathJax files above.</p> <p>See the documentation for details.</p>"},{"location":"static/node_modules/mathjax/#using-mathjax-components-in-a-node-application","title":"Using MathJax components in a node application","text":"<p>To use MathJax components in a node application, install the <code>mathjax</code> package:</p> <pre><code>npm install mathjax@3\n</code></pre> <p>(we are still making updates to version 2, so you should include <code>@3</code> since the latest chronological version may not be version 3).</p> <p>Then require <code>mathjax</code> within your application:</p> <pre><code>require('mathjax').init({ ... }).then((MathJax) =&gt; { ... });\n</code></pre> <p>where the first <code>{ ... }</code> is a MathJax configuration, and the second <code>{ ... }</code> is the code to run after MathJax has been loaded.  E.g.</p> <pre><code>require('mathjax').init({\n  loader: {load: ['input/tex', 'output/svg']}\n}).then((MathJax) =&gt; {\n  const svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true});\n  console.log(MathJax.startup.adaptor.outerHTML(svg));\n}).catch((err) =&gt; console.log(err.message));\n</code></pre> <p>Note: this technique is for node-based application only, not for browser applications.  This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's <code>require()</code> command to load external modules.  This setup will not work properly in the browser, even if you webpack it or bundle it in other ways.</p> <p>See the documentation and the MathJax Node Repository for more details.</p>"},{"location":"static/node_modules/mathjax/#reducing-the-size-of-the-components-directory","title":"Reducing the Size of the Components Directory","text":"<p>Since the <code>es5</code> directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the <code>tex-chtml.js</code> component, then you can remove the <code>tex-mml-chtml.js</code>, <code>tex-svg.js</code>, <code>tex-mml-svg.js</code>, <code>tex-chtml-full.js</code>, and <code>tex-svg-full.js</code> configurations, which will save considerable space.  Indeed, you should be able to remove everything other than <code>tex-chtml.js</code>, and the <code>input/tex/extensions</code>, <code>output/chtml/fonts/woff-v2</code>, <code>adaptors</code>, <code>a11y</code>, and <code>sre</code> directories.  If you are using the results only on the web, you can remove <code>adaptors</code> as well.</p> <p>If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove <code>a11y</code> and <code>sre</code> as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there).</p> <p>If you are using SVG rather than CommonHTML output (e.g., <code>tex-svg.js</code> rather than <code>tex-chtml.js</code>), you can remove the <code>output/chtml/fonts/woff-v2</code> directory.  If you are using MathML input rather than TeX (e.g., <code>mml-chtml.js</code> rather than <code>tex-chtml.js</code>), then you can remove <code>input/tex/extensions</code> as well.</p>"},{"location":"static/node_modules/mathjax/#the-component-files-and-pull-requests","title":"The Component Files and Pull Requests","text":"<p>The <code>es5</code> directory is generated automatically from the contents of the MathJax source repository.  You can rebuild the components using the command</p> <pre><code>npm run make-es5 --silent\n</code></pre> <p>Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the <code>es5</code> directory.  If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository.</p>"},{"location":"static/node_modules/mathjax/#mathjax-community","title":"MathJax Community","text":"<p>The main MathJax website is http://www.mathjax.org, and it includes announcements and other important information.  A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub.</p> <p>Before reporting a bug, please check that it has not already been reported.  Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.</p>"},{"location":"static/node_modules/mathjax/#mathjax-resources","title":"MathJax Resources","text":"<ul> <li>MathJax Documentation</li> <li>MathJax Components</li> <li>MathJax Source Code</li> <li>MathJax Web Examples</li> <li>MathJax Node Examples</li> <li>MathJax Bug Tracker</li> <li>MathJax Users' Group</li> </ul>"},{"location":"subfolder/","title":"This is the index to a subfolder","text":"<p>Things to discuss</p>"},{"location":"subfolder/another-subfile/","title":"This is a secondary sub page","text":"<p>Things to discuss</p>"}]}