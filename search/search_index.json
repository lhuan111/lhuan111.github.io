{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Assignment 1","text":""},{"location":"#ras557-project-assignment-1-klann-style-hexapod","title":"RAS557 Project Assignment 1 \u2014 Klann-style Hexapod","text":""},{"location":"#team-members-shuai-guo-lixiao-huang-yibo-yuan","title":"Team members: Shuai Guo, Lixiao Huang, Yibo Yuan","text":""},{"location":"#instructor-daniel-aukes-fall-2025","title":"Instructor: Daniel Aukes (Fall 2025)","text":"<p>Contents:</p> <ul> <li>Klann linkage kinematics for a single leg (numeric closed-loop solver)</li> <li>A hexapod arrangement (6 legs) with phase offsets</li> <li>Numeric Jacobian (d foot position / d crank angle), torque and power computations</li> <li>An MJCF generator for MuJoCo (approximate multi-body representation)</li> </ul> <p> </p>"},{"location":"#part-1-project-goal-fit","title":"Part 1 \u2014 Project Goal &amp; Fit","text":"<p>Team goal:</p> <p>Our team\u2019s goal is to design, model, and analyze a Klann-style six-legged walking robot that demonstrates efficient ground locomotion using purely mechanical linkages and minimal actuation. The project aims to replicate bio-inspired gait patterns from hexapodal insects while integrating foldable fabrication techniques for lightweight and easily manufacturable components. The design will be simulated in MuJoCo and analyzed for torque, power, and stability requirements.</p> <p>Candidate organism: Species name, body plan, motion of interest</p> <ul> <li>Organism: Blaberus giganteus (giant cockroach)</li> <li>Body Plan: Hexapodal (six-legged), each leg with two primary rotational joints for swing and lift phases</li> <li>Motion of Interest: Tripod gait used for steady walking and efficient terrestrial locomotion on uneven ground</li> </ul> <p>Scope / Impact / Team fit / Topic fit</p> <ul> <li>Scope: how you constrain the problem for a single semester</li> </ul> <p>To ensure the project is feasible within a single semester, we constrain the design to a planar six-bar Klann linkage per leg, with a single degree of freedom driven by a rotating crank. This limits control complexity while preserving the biologically inspired foot trajectory that mimics insect gaits. The robot will be modeled at tabletop scale (roughly 20\u201325 cm body length), built from folded cardboard or laser-cut polymer, and powered by six independent crank motors. The scope emphasizes kinematics and mechanical efficiency over autonomous control or perception.</p> <ul> <li>Impact: why this matters.</li> </ul> <p>This project demonstrates how bio-inspired mechanical linkages can produce complex legged locomotion with minimal sensors or software. It contributes to foldable robotics by showing that low-cost, flat-fabricated mechanisms can achieve reliable walking behaviors comparable to multi-motor leg designs. The research has practical implications for low-cost search-and-rescue scouting robots, STEM education, and deployable field robots where simplicity, weight, and robustness are critical. Understanding this linkage\u2019s performance also deepens insight into energy-efficient legged motion relevant to both engineered and biological systems.</p> <ul> <li>Team Fit: why your team is suited to this problem.</li> </ul> <p>Our team brings together complementary skills in mechanical design, kinematics, and simulation. One member specializes in mechanism synthesis and CAD modeling, another in physics-based simulation and code development (MuJoCo/Python), and another in fabrication and testing of foldable prototypes. This diverse expertise allows us to connect theoretical modeling with hands-on prototyping and validation, ensuring both analytical rigor and functional design execution.</p> <ul> <li>Topic Fit: how this uses foldable robotics techniques</li> </ul> <p>The project directly employs foldable robotics techniques introduced in class, using layered cardboard or plastic sheets with integrated hinge lines to create planar four- and six-bar linkages. The Klann mechanism\u2019s planar structure is ideally suited for this fabrication method, allowing rapid iteration of designs without costly machining. By combining foldable joints with bio-inspired geometry, we can explore how planar foldable mechanisms achieve lifelike motion while remaining lightweight, scalable, and manufacturable using classroom tools.</p>"},{"location":"#part-2-background-research","title":"Part 2 \u2014 Background Research","text":"<p>Search Terms</p> <p>To inform our design, we conducted literature searches using the following keywords:</p> <ul> <li><code>cockroach biomechanics ground reaction forces</code></li> <li><code>hexapod gait tripod gait kinematics</code></li> <li><code>Klann linkage walking mechanism</code></li> <li><code>insect leg morphology hexapod locomotion</code></li> <li><code>bio-inspired mechanical leg robots</code></li> <li><code>foldable planar linkage mechanism</code></li> </ul> <p>These searches yielded studies on both biological hexapods (e.g., Blaberus giganteus) and mechanical walkers like the Klann linkage, which replicates insect-style foot trajectories using a planar six-bar mechanism.</p> <p>Representative Citations (IEEE Format)</p> <p>[1] R. J. Full and D. E. Koditschek, \u201cTemplates and anchors: Neuromechanical hypotheses of legged locomotion on land,\u201d Journal of Experimental Biology, vol. 202, no. 23, pp. 3325\u20133332, 1999. [2] K. Klann, \u201cMechanical leg walking device,\u201d U.S. Patent 5,281,151, Jan. 25, 1994. [3] T. McGeer, \u201cPassive dynamic walking,\u201d The International Journal of Robotics Research, vol. 9, no. 2, pp. 62\u201382, 1990. [4] S. Kim, C. Laschi, and B. Trimmer, \u201cSoft robotics: A bioinspired evolution in robotics,\u201d Trends in Biotechnology, vol. 31, no. 5, pp. 287\u2013294, 2013. [5] Schilling, M., Schneider, A., Cruse, H., &amp; Schmitz, J. (2008, September). Local control mechanisms in six-legged walking. In 2008 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 2655-2660). IEEE.</p> <p>Key Biological and Mechanical Insights</p> Parameter Unit Value / Observation Source Typical insect mass (scaled equivalent) kg 0.5\u20131.0 [1] Walking speed (tripod gait) m/s 0.2\u20130.5 [1] Stride length (scaled) m 0.08\u20130.12 [1] Peak ground reaction force per stance leg N ~4 [1] Material for mechanical analog \u2014 Plywood / laser-cut plastic / cardboard \u2014 Mechanism inspiration \u2014 Klann six-bar linkage [2] Actuation \u2014 Servo motors or geared DC motors \u2014 Power source \u2014 Compact 6V\u201312V battery \u2014 <p>Figures and Observations</p> <p>Figure 1. Klann-style six-legged mechanical walker prototype built for this project. </p> <p>Each leg consists of a planar six-bar linkage, driven by a single rotating crank. The leg replicates the ground contact and swing phases of a cockroach-like tripod gait. The body is lightweight plywood with foldable linkage connections, and spherical red feet enhance stability and traction. Pictures below show the front, back, and side views.</p> <p> </p> <p>Project Video:</p> <p>This video shows the robot walking in the real world. </p> <p> </p>"},{"location":"#note-estimate-goal-performance-metrics-has-been-added-according-to-the-assignment-1-comment","title":"[Note: Estimate Goal Performance Metrics has been added according to the Assignment 1 comment]","text":""},{"location":"#estimate-goal-performance-metrics","title":"Estimate Goal Performance Metrics","text":"<p>1. From motor torque to leg force</p> <p>The motor applies a torque \u03c4 to the crank of radius r (distance from M to B):</p> \\[ \\tau = F r \\quad\\Rightarrow\\quad F = \\frac{\\tau}{r} \\] <p>Here:</p> <ul> <li>\u03c4_max is equal to the value <code>MAX_TORQUE_SIM</code> in the code  </li> <li>r = |MB| is the crank radius in meters, computed using</li> </ul> <p>$$   r = \\sqrt{(B_x - M_x)^2 + (B_z - M_z)^2}   $$</p> <p>This gives the approximate maximum tangential force generated by one crank\u2013leg linkage.</p> <p>2. From leg force to body acceleration</p> <p>If n legs are in stance and share the load, the total vertical ground-reaction force is:</p> \\[ F_{\\text{total}} = nF \\] <p>Relating this to the robot mass m using F = ma:</p> \\[ F_{\\text{total}} = m(g + a_z) \\quad\\Rightarrow\\quad a_z = \\frac{F_{\\text{total}}}{m} - g \\] <p>where:</p> <ul> <li>m is the total robot mass (from <code>MASS_BASE</code>, <code>MASS_MOTOR</code>, and estimated leg/foot masses using <code>DENS_LEG</code> and <code>DENS_FOOT</code>)  </li> <li>g = 9.81 m/s\u00b2  </li> <li>a_z is the estimated upward acceleration of the body  </li> </ul> <p>This provides an estimate of the peak vertical ground-reaction force and the maximum vertical acceleration the mechanism can generate.</p>"},{"location":"#part-3-specifications-table","title":"Part 3 \u2014 Specifications Table","text":"<p>The table below lists key physical and kinematic parameters for the Klann-style six-legged walker. All quantities are expressed in SI units, with values derived from literature on insect locomotion and scaled for the tabletop prototype.</p> Parameter Symbol Unit Value (example) Source / Notes Total robot mass \ud835\udc5a kg 0.8 Measured prototype (plywood + servos) Number of legs \u2014 \u2014 6 Hexapod (tripod gait) Leg mechanism type \u2014 \u2014 Klann 6-bar linkage Planar, single DOF per leg Crank length \ud835\udc3f\u2081 m 0.025 Measured Coupler link 1 \ud835\udc3f\u2082 m 0.060 Measured Coupler link 2 \ud835\udc3f\u2083 m 0.045 Measured Rocker length \ud835\udc3f\u2084 m 0.065 Measured Follower (leg) length \ud835\udc3f\u2085 m 0.090 Measured Body length \ud835\udc3f_b m 0.25 Approx. overall length Walking speed (target) \ud835\udc63 m/s 0.30 From cockroach gait scaling Stride length \ud835\udc60 m 0.10 Derived from mechanism geometry Step frequency \ud835\udc53 Hz 3 Typical tripod gait rhythm Stance fraction \u03b2 \u2014 0.6 Fraction of stride in contact Peak GRF per stance leg \ud835\udc39_leg N 3.9 \\(1.5 \\times (m g)/3\\) Crank angular velocity \u03c9_c rad/s 6.0 Derived from stride frequency Peak crank torque \u03c4_c N\u00b7m 0.35 From Jacobian &amp; force mapping Gear ratio \ud835\udc3a \u2014 10 Motor gearbox ratio Efficiency \u03b7 \u2014 0.7 Typical small gearbox efficiency Safety margin \ud835\udc0c \u2014 2 For motor sizing Rated motor torque \u03c4_m,rated N\u00b7m 0.10 $\\frac{ Power per actuator \ud835\udc43 W 0.7 \\( \u03c4_c \u00d7 \u03c9_c \\) Material \u2014 \u2014 Plywood / 3D-printed polymer Foldable planar structure Actuators \u2014 \u2014 Micro servos (6 total) One per crankshaft Power source \u2014 \u2014 2S Li-ion battery 7.4 V nominal <p>Notes - The above values are representative of the prototype shown in Figures 1\u20132. - Actual values may vary slightly depending on material density and linkage tolerances. - Use the torque and power values in this table for actuator selection and MuJoCo simulation inputs.</p>"},{"location":"#part-4-mechanism-design-kinematic-model","title":"Part 4 \u2014 Mechanism Design &amp; Kinematic Model","text":""},{"location":"#mechanism-description","title":"Mechanism Description","text":"<p>The Klann linkage is a planar six-bar mechanism designed to transform continuous rotary motion into an approximate leg-like walking trajectory. Each leg consists of: - A fixed ground link connecting two pivots (A and B), - A crank (driven by the motor), - Two coupler links forming a four-bar subloop, - A rocker connected to the ground pivot B, - A follower leg connecting the floating coupler to the foot point.</p> <p>The mechanism\u2019s geometry and motion are optimized so that the foot follows an oval-shaped trajectory, with a nearly straight line during the stance phase and a smooth lift during the swing phase.</p>"},{"location":"#notethe-assembly-overview-has-been-added-according-to-assignment-1-feedback","title":"[Note:The Assembly overview has been added according to Assignment 1 feedback]","text":"<p>Assembly overview At first the leg bars are cut from woodboard using the dimensions in the kinematic model. Later we change the material with modified cardboard.In the first model,all pin joints (A, B, C, D, E, F, M) are realized with small screws and nylon spacers to approximate revolute joints while keeping friction low. Springs are installed after the rigid linkage is assembled to avoid pre-loading the joints during alignment. Finally, the motor cranks are attached and wired to the battery so that motors spin in the correct direction to produce a forward-walking gait. In the second model, screws aren't need, the material can provide all the joints needed.</p> <p>Mechanism Drawing</p> <p>Draw or model your mechanism externally (e.g., Draw.io). Include link labels (A\u2013F), reference frames, and joint variables (\u03b8\u2081, \u03b8\u2082, \u2026). b=back, f=front.  </p> <p>\\(l_1f\\)=\\(l_1b\\)=\\(l_3f\\)=\\(l_3b\\)=\\(l_5f\\)=\\(l_5b\\)=\\(l_65f\\)=\\(l_6b\\)=\\(l_7f\\)=\\(l_7b\\)=4.2 inch</p> <p>\\(l_2f\\)=\\(l_2b\\)=\\(l_4f\\)=\\(l_4b\\)=\\(l_8f\\)=\\(l_8b\\)=\\(l_9f\\)=\\(l_9b\\)=2.1 inch,</p> <p>\\(l_{10}f\\)= 1 inch</p> <p></p>"},{"location":"#part-5-force-torque-power-estimation","title":"Part 5 \u2014 Force / Torque / Power Estimation","text":"<p>Use the Jacobian to map end-effector forces to actuator torques, then compute power = torque * angular velocity. Fill in calculated/assumed GRFs and pick key gait states to compute required actuator specs.</p> <pre><code>!pip install mujoco\n\n# Set up GPU rendering.\nfrom google.colab import files\nimport distutils.util\nimport os\nimport subprocess\nif subprocess.run('nvidia-smi').returncode:\n  raise RuntimeError(\n      'Cannot communicate with GPU. '\n      'Make sure you are using a GPU Colab runtime. '\n      'Go to the Runtime menu and select Choose runtime type.')\n\n# Add an ICD config so that glvnd can pick up the Nvidia EGL driver.\n# This is usually installed as part of an Nvidia driver package, but the Colab\n# kernel doesn't install its driver via APT, and as a result the ICD is missing.\n# (https://github.com/NVIDIA/libglvnd/blob/master/src/EGL/icd_enumeration.md)\nNVIDIA_ICD_CONFIG_PATH = '/usr/share/glvnd/egl_vendor.d/10_nvidia.json'\nif not os.path.exists(NVIDIA_ICD_CONFIG_PATH):\n  with open(NVIDIA_ICD_CONFIG_PATH, 'w') as f:\n    f.write(\"\"\"{\n    \"file_format_version\" : \"1.0.0\",\n    \"ICD\" : {\n        \"library_path\" : \"libEGL_nvidia.so.0\"\n    }\n}\n\"\"\")\n\n# Configure MuJoCo to use the EGL rendering backend (requires GPU)\nprint('Setting environment variable to use GPU rendering:')\n%env MUJOCO_GL=egl\n\n# Check if installation was succesful.\ntry:\n  print('Checking that the installation succeeded:')\n  import mujoco\n  mujoco.MjModel.from_xml_string('&lt;mujoco/&gt;')\nexcept Exception as e:\n  raise e from RuntimeError(\n      'Something went wrong during installation. Check the shell output above '\n      'for more information.\\n'\n      'If using a hosted Colab runtime, make sure you enable GPU acceleration '\n      'by going to the Runtime menu and selecting \"Choose runtime type\".')\n\nprint('Installation successful.')\n\n# Other imports and helper functions\nimport time\nimport itertools\nimport numpy as np\n\n# Graphics and plotting.\nprint('Installing mediapy:')\n!command -v ffmpeg &gt;/dev/null || (apt update &amp;&amp; apt install -y ffmpeg)\n!pip install -q mediapy\nimport mediapy as media\nimport matplotlib.pyplot as plt\n\n# More legible printing from numpy.\nnp.set_printoptions(precision=3, suppress=True, linewidth=100)\n\nfrom IPython.display import clear_output\nclear_output()\n\nStep 1: Klann kinematics definition cell\n\n# Compute Jacobian (d foot_pos / d theta_crank) via finite differences\nimport numpy as np\n\n# Example: placeholder function for foot position of a Klann mechanism\n# Replace with your actual linkage geometry\n\ndef klann_positions(theta):\n    A = np.array([0.0, 0.0])\n    r = 0.030\n    crank_end = A + r * np.array([np.cos(theta), np.sin(theta)])\n    l_coupler = 0.065\n    coupler_angle = theta - 0.45\n    X = crank_end + l_coupler * np.array([np.cos(coupler_angle), np.sin(coupler_angle)])\n    l_main = 0.085\n    main_angle = theta + 0.6\n    Y = X + l_main * np.array([np.cos(main_angle), np.sin(main_angle)])\n    l_follower = 0.055\n    follower_angle = main_angle - 0.9\n    follower_end = Y + l_follower * np.array([np.cos(follower_angle), np.sin(follower_angle)])\n    l_foot = 0.035\n    foot_angle = follower_angle - 0.2\n    foot = follower_end + l_foot * np.array([np.cos(foot_angle), np.sin(foot_angle)])\n    return {\n        \"A\": A,\n        \"crank_end\": crank_end,\n        \"X\": X,\n        \"Y\": Y,\n        \"follower_end\": follower_end,\n        \"foot\": foot\n    }\n\n# Numerical derivative\ndef dfoot_dtheta(theta, h=1e-6):\n    p0 = klann_positions(theta)\n    f0 = p0[\"foot\"]\n    p1 = klann_positions(theta + h)\n    f1 = p1[\"foot\"]\n    return (f1 - f0) / h\n\n# Test\ntheta = 0.3\nJtheta = dfoot_dtheta(theta)\nprint(\"d(foot)/d(theta) at theta=0.3:\", Jtheta)\n\nimport mujoco\nimport numpy as np\nimport matplotlib\nimport sympy\nprint(\"\u2705 All core dependencies are available and working!\")\n</code></pre> <p>Step 2: Computer acutuator torque from foot force per lec and power</p> <pre><code># Compute actuator torque from foot force (per leg) and power\ntheta = 0.3\nJt = dfoot_dtheta(theta)\nF_foot = np.array([0.0, 3.924])  # N (vertical)\ntau = np.dot(Jt, F_foot)\nomega = 6.0  # rad/s example\npower = tau * omega\nprint(f\"Crank torque required (Nm) at theta={theta:.3f}: {tau:.4f} N\u00b7m\")\nprint(f\"Mechanical power at crank (W) for omega={omega} rad/s: {power:.4f} W\")\n</code></pre>"},{"location":"#part-6-plots-figures","title":"Part 6 \u2014 Plots &amp; Figures","text":"<p>Use matplotlib to create plots (GRF plots, kinematic traces, energy/power curves).</p> <p>As we try to solve section 6, we created two versions.</p> <p>Below is version 1 for the whole robot: We added the following constranits:</p> <pre><code>    mjcf.append('  &lt;equality&gt;')\n    mjcf.append('    &lt;weld name=\"weld1\" active=\"true\" body1=\"A\" body2=\"Ap\"')\n    mjcf.append('           relpose=\"0 0 0 1 0 0 0\" anchor=\"0 0 0\" /&gt;')\n    mjcf.append('  &lt;/equality&gt;')\n</code></pre> <p>Below is the code:  </p><pre><code># MJCF generator for Klann hexapod (approximate multi-body representation)\nimport textwrap, os, numpy as _np\nparams_local = {\n    \"l_crank\": 0.025,\n    \"l_coupler1\": 0.06,\n    \"l_coupler2\": 0.045,\n    \"l_follower\": 0.09\n}\ndef generate_klann_hexapod_mjcf(params, phase_offsets=None):\n    if phase_offsets is None:\n        phase_offsets = [0.0, _np.pi, 0.0, _np.pi, 0.0, _np.pi]\n    mjcf = []\n    mjcf.append('&lt;mujoco model=\"klann_hexapod\"&gt;')\n    mjcf.append('  &lt;compiler angle=\"radian\"/&gt;')\n    mjcf.append('  &lt;option gravity=\"0 0 -9.81\"/&gt;')\n    mjcf.append('  &lt;worldbody&gt;')\n    mjcf.append('    &lt;body name=\"torso\" pos=\"0 0 0.06\"&gt;')\n    mjcf.append('      &lt;geom name=\"torso_geom\" type=\"box\" size=\".09 .07 .03\" rgba=\"0.3 0.6 0.8 1\"/&gt;')\n    leg_mounts = [ (0.055, 0.06), (0.0, 0.07), (-0.055, 0.06),\n                   (0.055, -0.06), (0.0, -0.07), (-0.055, -0.06) ]\n    for i,(mx,my) in enumerate(leg_mounts):\n        mjcf.append(f'    &lt;body name=\"leg{i}_mount\" pos=\"{mx} {my} 0.06\"&gt;')\n        mjcf.append(f'      &lt;joint name=\"crank{i}\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append('      &lt;body name=\"crank_link\" pos=\"0 0 0\"&gt;')\n        mjcf.append(f'        &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_crank\"]} 0 0\" size=\"0.006\"/&gt;')\n        mjcf.append(f'        &lt;body name=\"coupler1\" pos=\"{params[\"l_crank\"]} 0 0\"&gt;')\n        mjcf.append('          &lt;joint name=\"j1\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append(f'          &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_coupler1\"]} 0 0\" size=\"0.006\"/&gt;')\n        mjcf.append(f'          &lt;body name=\"coupler2\" pos=\"{params[\"l_coupler1\"]} 0 0\"&gt;')\n        mjcf.append('            &lt;joint name=\"j2\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append(f'            &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_coupler2\"]} 0 0\" size=\"0.006\"/&gt;')\n        mjcf.append(f'            &lt;body name=\"follower\" pos=\"{params[\"l_coupler2\"]} 0 0\"&gt;')\n        mjcf.append('              &lt;joint name=\"j3\" type=\"hinge\" axis=\"0 0 1\" pos=\"0 0 0\"/&gt;')\n        mjcf.append(f'              &lt;geom type=\"capsule\" fromto=\"0 0 0 {params[\"l_follower\"]} 0 0\" size=\"0.008\"/&gt;')\n        mjcf.append(f'              &lt;site name=\"foot\" pos=\"{params[\"l_follower\"]} 0 -0.01\" size=\"0.01\"/&gt;')\n        mjcf.append('            &lt;/body&gt;')\n        mjcf.append('          &lt;/body&gt;')\n        mjcf.append('        &lt;/body&gt;')\n        mjcf.append('      &lt;/body&gt;')\n        mjcf.append('    &lt;/body&gt;')\n    mjcf.append('    &lt;/body&gt;')\n    mjcf.append('  &lt;/worldbody&gt;')\n    mjcf.append('  &lt;actuator&gt;')\n    for i in range(6):\n        mjcf.append(f'    &lt;motor name=\"crankm{i}\" joint=\"crank{i}\" gear=\"100\"/&gt;')\n    mjcf.append('  &lt;/actuator&gt;')\n    mjcf.append('  &lt;equality&gt;')\n    mjcf.append('    &lt;weld name=\"weld1\" active=\"true\" body1=\"A\" body2=\"Ap\"')\n    mjcf.append('           relpose=\"0 0 0 1 0 0 0\" anchor=\"0 0 0\" /&gt;')\n    mjcf.append('  &lt;/equality&gt;')\n    mjcf.append('&lt;/mujoco&gt;')\n    return \"\\n\".join(mjcf)\n\nxml = generate_klann_hexapod_mjcf(params_local)\nopen(\"klann_hexapod.xml\",\"w\").write(xml)\nprint(\"MJCF saved to klann_hexapod.xml (length):\", len(xml))\n\n# Try loading the MJCF in MuJoCo\ntry:\n    import mujoco\n    model = mujoco.MjModel.from_xml_path(\"klann_hexapod.xml\")\n    sim = mujoco.MjSim(model)\n    print(\"MuJoCo loaded mjcf. model.nq=\", model.nq)\n    print(\"MuJoCo ready. For interactive visualization run: mujoco.viewer.launch(sim)\")\nexcept Exception as e:\n    print(\"MuJoCo not available or failed to load in this runtime:\", e)\n    print(\"Proceed to fallback plotting in the next cell.\")\n\n    # Fallback visualization: plot Klann legs for 6 mounting points (pure Python plotting)\nimport matplotlib.pyplot as plt\nleg_mounts = [ (0.055, 0.06), (0.0, 0.07), (-0.055, 0.06),\n               (0.055, -0.06), (0.0, -0.07), (-0.055, -0.06) ]\nplt.figure(figsize=(8,8))\ntorso_x = [-0.09, 0.09, 0.09, -0.09, -0.09]\ntorso_y = [-0.07, -0.07, 0.07, 0.07, -0.07]\nplt.plot(torso_x, torso_y, 'k-')\nfor i,(mx,my) in enumerate(leg_mounts):\n    theta = 0.0 + (np.pi if (i%2)==1 else 0.0)\n    pos = klann_positions(theta)\n    ptsx = [pos[\"A\"][0]+mx, pos[\"crank_end\"][0]+mx, pos[\"X\"][0]+mx, pos[\"Y\"][0]+mx, pos[\"follower_end\"][0]+mx, pos[\"foot\"][0]+mx]\n    ptsy = [pos[\"A\"][1]+my, pos[\"crank_end\"][1]+my, pos[\"X\"][1]+my, pos[\"Y\"][1]+my, pos[\"follower_end\"][1]+my, pos[\"foot\"][1]+my]\n    plt.plot([ptsx[0], ptsx[1]], [ptsy[0], ptsy[1]], 'r-')\n    plt.plot([ptsx[1], ptsx[2]], [ptsy[1], ptsy[2]], 'g-')\n    plt.plot([ptsx[2], ptsx[3]], [ptsy[2], ptsy[3]], 'b-')\n    plt.plot([ptsx[3], ptsx[4]], [ptsy[3], ptsy[4]], 'm-')\n    plt.plot(ptsx[-1], ptsy[-1], 'ko')\nplt.gca().set_aspect('equal', 'box')\nplt.title(\"Hexapod with Klann-style Leg Approx (single phase shown per leg)\")\nplt.xlabel(\"x (m)\")\nplt.ylabel(\"y (m)\")\nplt.show()\n</code></pre><p></p> <p>Sweep crank angle &amp; compute required crank torque for a given vertical foot force </p><pre><code>import numpy as np\nthetas = np.linspace(0, 2*np.pi, 101)\ntorques = []\nF_foot = np.array([0.0, 3.924])\nfor th in thetas:\n    Jt = dfoot_dtheta(th)\n    tau = np.dot(Jt, F_foot)\n    torques.append(tau)\ntorques = np.array(torques)\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(6,3))\nplt.plot(thetas, torques)\nplt.xlabel(\"crank angle (rad)\")\nplt.ylabel(\"required crank torque (N\u00b7m)\")\nplt.title(\"Torque vs Crank Angle (per leg)\")\nplt.grid(True)\nplt.show()\nprint(\"Torque stats: min {:.4f} Nm, max {:.4f} Nm\".format(torques.min(), torques.max()))\n</code></pre><p></p> <p>Below is version 2 based on one leg kinematics:</p> <p>The second version is based on Prof. Aukes' suggestion on working one-leg's kinematics. We do not have xml file for it, and we also ran out of time. </p><pre><code>import numpy as np, math\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass\n\nR_MB = 1.0    # MB crank\nL_BC = 4.2    # long link BC\nL_AC = 4.2    # long link AC\nL_DE = 2.1    # struts: DE = DF\nMD    = 2.1   # |M - D| = 2\n\nINCH_TO_M = 0.0254\n\n# Ground points\nM = np.array([0.0, 0.0])\nD = np.array([-MD, 0.0])   # D is 2 in to the left of M\n\n\ndef B_of_theta(theta: float) -&gt; np.ndarray:\n    \"\"\"Motor-driven point B on the 1-inch crank around M.\"\"\"\n    return M + R_MB*np.array([np.cos(theta), np.sin(theta)])\n\n@dataclass\nclass Pose:\n    A: np.ndarray\n    C: np.ndarray\n    B: np.ndarray\n    E: np.ndarray\n    F: np.ndarray\n\ndef residual(u: np.ndarray, theta: float) -&gt; np.ndarray:\n    \"\"\"\n    f(u,\u03b8) with u=[Ax,Ay,Cx,Cy]:\n      1) |C-B| = L_BC\n      2) |C-A| = L_AC\n      3) |E-D| = L_DE,  E=(A+C)/2\n      4) |F-D| = L_DE,  F=(B+C)/2\n    \"\"\"\n    Ax,Ay,Cx,Cy = u\n    A = np.array([Ax,Ay])\n    C = np.array([Cx,Cy])\n    B = B_of_theta(theta)\n    E = 0.5*(A + C)\n    F = 0.5*(B + C)\n    r1 = np.sum((C - B)**2) - L_BC**2\n    r2 = np.sum((C - A)**2) - L_AC**2\n    r3 = np.sum((E - D)**2) - L_DE**2\n    r4 = np.sum((F - D)**2) - L_DE**2\n    return np.array([r1,r2,r3,r4], dtype=float)\n\ndef Ju_matrix(u: np.ndarray, theta: float) -&gt; np.ndarray:\n    \"\"\"Analytic \u2202f/\u2202u (4x4) for Newton solve.\"\"\"\n    Ax,Ay,Cx,Cy = u\n    A = np.array([Ax,Ay]); C = np.array([Cx,Cy]); B = B_of_theta(theta)\n    E = 0.5*(A + C)\n    F = 0.5*(B + C)\n\n    CB = C - B\n    CA = C - A\n    ED = E - D\n    FD = F - D\n\n    Ju = np.zeros((4,4), dtype=float)\n    # f1: |C-B|^2 -&gt; wrt C\n    Ju[0,2:4] = 2.0*CB\n    # f2: |C-A|^2 -&gt; wrt A and C\n    Ju[1,0:2] = -2.0*CA\n    Ju[1,2:4] =  2.0*CA\n    # f3: |(A+C)/2 - D|^2 -&gt; wrt A and C (both via E)\n    Ju[2,0:2] = ED\n    Ju[2,2:4] = ED\n    # f4: |(B+C)/2 - D|^2 -&gt; wrt C (via F)\n    Ju[3,2:4] = FD\n    return Ju\n\ndef Jtheta_vector(u: np.ndarray, theta: float) -&gt; np.ndarray:\n    \"\"\"Analytic \u2202f/\u2202\u03b8 (4x1). Only f1 and f4 depend on B(\u03b8).\"\"\"\n    Cx,Cy = u[2], u[3]\n    C = np.array([Cx,Cy]); B = B_of_theta(theta)\n    dB = R_MB*np.array([-np.sin(theta), np.cos(theta)])  # dB/d\u03b8\n    CB = C - B\n    F  = 0.5*(B + C)\n    Jth = np.zeros((4,1), dtype=float)\n    # f1: |C-B|^2 -&gt; -2(C-B)\u00b7dB/d\u03b8\n    Jth[0,0] = -2.0 * np.dot(CB, dB)\n    # f4: 2(F-D)\u00b7(\u2202F/\u2202\u03b8) = 2(F-D)\u00b7(0.5 dB/d\u03b8)\n    Jth[3,0] = 2.0 * np.dot(F - D, 0.5*dB)\n    return Jth\n\n\ndef solve_pose(theta: float, guess: np.ndarray=None,\n               max_iter=60, tol=1e-10) -&gt; Pose:\n    B = B_of_theta(theta)\n    if guess is None:\n        # simple heuristic seed near B\n        C0 = B + np.array([-L_BC*0.7,  L_BC*0.3])\n        A0 = C0 + np.array([-L_AC*0.6, -L_AC*0.6])\n        guess = np.hstack([A0, C0])\n\n    u = guess.astype(float).copy()\n    f = residual(u, theta)\n    for _ in range(max_iter):\n        if np.linalg.norm(f) &lt; tol:\n            break\n        Ju = Ju_matrix(u, theta)\n        # Solve normal equations with tiny damping\n        reg = 1e-12*np.eye(4)\n        try:\n            delta = -np.linalg.solve(Ju.T@Ju + reg, Ju.T@f)\n        except np.linalg.LinAlgError:\n            delta = -np.linalg.pinv(Ju) @ f\n        # backtracking line search\n        t = 1.0\n        norm0 = np.linalg.norm(f)\n        while t &gt; 1e-4:\n            u_try = u + t*delta\n            f_try = residual(u_try, theta)\n            if np.linalg.norm(f_try) &lt; norm0*(1 - 1e-4*t):\n                u, f = u_try, f_try\n                break\n            t *= 0.5\n        else:\n            u = u + 1e-3*delta\n            f = residual(u, theta)\n\n    if np.linalg.norm(f) &gt; 1e-6:\n        raise RuntimeError(\"Solve failed or infeasible at this theta.\")\n\n    Ax,Ay,Cx,Cy = u\n    A = np.array([Ax,Ay]); C = np.array([Cx,Cy]); B = B_of_theta(theta)\n    E = 0.5*(A + C); F = 0.5*(B + C)\n    return Pose(A=A, C=C, B=B, E=E, F=F)\n\ndef jacobian_A(theta: float, pose: Pose) -&gt; np.ndarray:\n    \"\"\"\n    From f(u,\u03b8)=0: du/d\u03b8 = -J_u^{-1} J_\u03b8 -&gt; take first two rows (A_x,A_y).\n    Returns (2x1) inches/rad.\n    \"\"\"\n    u = np.hstack([pose.A, pose.C])\n    Ju = Ju_matrix(u, theta)\n    Jth = Jtheta_vector(u, theta)\n    du_dtheta = -np.linalg.solve(Ju, Jth)   # (4x1)\n    return du_dtheta[0:2,:]                 # dA/d\u03b8\n\n# =========================\n# Velocity / Force maps\n# =========================\ndef motor_tau_from_FA(theta: float, F_world_N: np.ndarray, pose: Pose) -&gt; float:\n    J = jacobian_A(theta, pose) * INCH_TO_M\n    return (J.T @ F_world_N.reshape(2,1)).item()   # N\u00b7m\n\ndef motor_speed_for_vA(theta: float, vA_mps: np.ndarray, pose: Pose) -&gt; float:\n    J = jacobian_A(theta, pose) * INCH_TO_M\n    JTJ = (J.T @ J).item()\n    if JTJ &lt; 1e-12:\n        raise RuntimeError(\"Near singular configuration for velocity mapping.\")\n    return (J.T @ vA_mps.reshape(2,1)).item() / JTJ\n\n# =========================\n# Quick viz &amp; demo\n# =========================\ndef plot_pose(theta: float, pose: Pose, ax=None, label_once=False):\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(6,3.8))\n    A,C,B,E,F = pose.A,pose.C,pose.B,pose.E,pose.F\n    # bars\n    ax.plot([M[0], B[0]],[M[1], B[1]], 'C3-', lw=2, label='MB=1' if label_once else None)\n    ax.plot([B[0], C[0]],[B[1], C[1]], 'C0-', lw=2, label='BC=4.2' if label_once else None)\n    ax.plot([A[0], C[0]],[A[1], C[1]], 'C0-', lw=2, label='AC=4.2' if label_once else None)\n    ax.plot([D[0], E[0]],[D[1], E[1]], 'C1-', lw=2, label='DE=2.1' if label_once else None)\n    ax.plot([D[0], F[0]],[D[1], F[1]], 'C1-', lw=2, label='DF=2.1' if label_once else None)\n    # points\n    ax.plot(*M,'ko'); ax.text(*M,' M', va='bottom')\n    ax.plot(*D,'ko'); ax.text(*D,' D', va='bottom')\n    ax.plot(*B,'x', color='C3'); ax.text(B[0], B[1], ' B', va='bottom', color='C3')\n    ax.plot(*C,'x', color='C0'); ax.text(C[0], C[1], ' C', va='bottom', color='C0')\n    ax.plot(*A,'x', color='C2'); ax.text(A[0], A[1], ' A', va='bottom', color='C2')\n    ax.plot(*E,'o', mfc='none', color='C1'); ax.text(E[0], E[1], ' E', va='bottom', color='C1')\n    ax.plot(*F,'o', mfc='none', color='C1'); ax.text(F[0], F[1], ' F', va='bottom', color='C1')\n    ax.set_aspect('equal', adjustable='box')\n    ax.grid(True, ls=':')\n    ax.set_xlabel('x (in)'); ax.set_ylabel('y (in)')\n    ax.set_title('Kinematic Model of One Leg')\n    return ax\n\nif __name__ == \"__main__\":\n    # sweep theta, solve and warm-start\n    TH = np.linspace(-np.pi, np.pi, 540, endpoint=False)\n    poses, thetas = [], []\n    guess = None\n    for th in TH:\n        try:\n            p = solve_pose(th, guess)\n            poses.append(p); thetas.append(th)\n            guess = np.hstack([p.A, p.C])   # warm start\n        except RuntimeError:\n            pass\n\n    # plot a few poses + A locus\n    fig, ax = plt.subplots(figsize=(6.4, 3.8))\n    if poses:\n        idxs = np.linspace(0, len(poses)-1, 4, dtype=int)\n        for i, k in enumerate(idxs):\n            plot_pose(thetas[k], poses[k], ax=ax, label_once=(i==0))\n        A_path = np.array([p.A for p in poses])\n        ax.plot(A_path[:,0], A_path[:,1], '0.6', lw=1, label='A locus')\n        ax.legend()\n    else:\n        ax.text(0.5,0.5,\"No feasible poses with current geometry.\",ha='center',va='center',transform=ax.transAxes)\n    plt.tight_layout(); plt.show()\n\n    # report numbers at one feasible pose (if exists)\n    if poses:\n        k = len(poses)//3\n        th, p = thetas[k], poses[k]\n        J = jacobian_A(th, p) * INCH_TO_M\n        Fg = np.array([0.0, 120.0])  # example GRF\n        vA = np.array([0.40, 0.00])  # desired A speed\n        tau  = motor_tau_from_FA(th, Fg, p)\n        omega = motor_speed_for_vA(th, vA, p)\n        print(f\"\u03b8={np.rad2deg(th):.1f}\u00b0 | A={p.A} in | |J|={np.linalg.norm(J):.3e} m/rad\")\n        print(f\"\u03c4={tau:.2f} N\u00b7m, \u03c9={omega:.2f} rad/s, P\u2248{tau*omega:.2f} W\")\n\n&lt;img width=\"391\" height=\"370\" alt=\"image\" src=\"https://github.com/user-attachments/assets/47de986f-4611-497e-94d3-eeb7b416257e\" /&gt;\n</code></pre><p></p> <p></p> <p>Version 2 Explanation:</p> <p>How the figure was generated - Mechanism: closed-loop four-bar with two midpoint struts (pure kinematics; no mass, stiffness, or gravity). - Fixed anchors: \\(M=(0,0)\\), \\(D=(-d,0)\\) with \\(d=2\\,\\text{in}\\). - Link lengths: \\(MB=r=1\\,\\text{in}\\), \\(AC=BC=L=4.2\\,\\text{in}\\), \\(DE=DF=s=2.1\\,\\text{in}\\). - For each motor angle \\(\\theta\\),</p> \\[ B(\\theta)=\\big(r\\cos\\theta,\\; r\\sin\\theta\\big). \\] <ul> <li>Unknowns \\(x=[A_x,A_y,C_x,C_y]^T\\) are solved from the closure system</li> </ul> \\[ \\begin{aligned} \\|C-B\\|^2&amp;=L^2,\\qquad \\|C-A\\|^2=L^2, \\\\ \\left\\|\\tfrac{A+C}{2}-D\\right\\|^2&amp;=s^2,\\qquad \\left\\|\\tfrac{B+C}{2}-D\\right\\|^2=s^2, \\end{aligned} \\] <p>which yields \\(A(\\theta),\\; C(\\theta)\\). Midpoints: \\(E=\\tfrac12(A+C)\\), \\(F=\\tfrac12(B+C)\\). Sweeping \\(\\theta\\) and plotting bodies produces colored poses; the gray curve is the locus of \\(A(\\theta)\\).</p> <p>What the figure shows - Red: crank \\(MB\\); blue: long links \\(AC, BC=L\\); orange: midpoint struts \\(DE, DF=s\\). - Labeled points: \\(A,B,C,D,E,F,M\\). - Gray path: foot-point trajectory \\(A(\\theta)\\) generated by geometric coupling of the four-bar and struts.</p> <p>Differential/force relations (for analysis and reporting)</p> <p>Implicit differentiation of \\(F(x,\\theta)=0\\):</p> \\[ \\frac{dx}{d\\theta} = -\\Big(\\frac{\\partial F}{\\partial x}\\Big)^{-1}\\frac{\\partial F}{\\partial \\theta}, \\qquad J_A(\\theta)=\\frac{dA}{d\\theta}\\in\\mathbb{R}^{2\\times 1}. \\] <p>Velocity, torque, and power mappings:</p> \\[ \\dot A = J_A\\,\\dot\\theta,\\qquad \\tau = J_A^{\\!\\top} F_A,\\qquad P=\\tau\\,\\dot\\theta . \\] <p>Units: inches above for geometry; convert to meters when required for computation.</p> <p>3) Motor sizing recipe (practical engineering steps + formula)</p> <p>We compute required motor torque from the foot force via the Jacobian mapping of crank angle to foot position:</p> <p>Motor Torque Calculation and Sizing</p> <p>The required crank torque is derived from the virtual work relationship:</p> \\[ \\tau_{\\text{crank}}(\\theta) = \\mathbf{J}_\\theta(\\theta)^{\\top} \\mathbf{F}_{\\text{foot}} \\] <p>where:</p> <ul> <li><code>J_theta</code> = partial derivative of foot position (2D vector) with respect to crank angle (a 2\u00d71 vector).  </li> <li><code>F_foot</code> = foot force vector in world frame (e.g., vertical support force).</li> </ul> <p>Motor torque accounting for gearbox and efficiency</p> <p>If the motor is connected to the crank through a gearbox of ratio <code>G</code> (gear ratio &gt; 1 multiplies torque), and the overall drivetrain efficiency is <code>\u03b7</code> (0 &lt; \u03b7 \u2264 1), with a safety margin <code>M</code> (e.g., 2), the required motor stall torque rating should be:</p> \\[ \\tau_{\\text{motor,rated}} = \\frac{|\\tau_{\\text{crank,max}}|}{G \\, \\eta} \\times M \\] <p>where:</p> <ul> <li><code>\u03c4_crank,max</code> \u2014 peak crank torque from sweep over crank angle (computed in Cell 8).  </li> <li><code>G</code> \u2014 gearbox ratio (e.g., 10 for 10:1).  </li> <li><code>\u03b7</code> \u2014 drivetrain efficiency (e.g., 0.7).  </li> <li><code>M</code> \u2014 safety margin (e.g., 2).</li> </ul> <p>Motor Speed &amp; Electrical Power</p> <p>If peak mechanical power required at the crank is <code>P_mech = \u03c4_crank * \u03c9_crank</code>, then the required electrical power (ignoring motor electrical losses) is roughly:</p> \\[ P_{elec} \\approx \\frac{P_{mech}}{\\eta} \\] <p>After gearbox, the motor angular rate is <code>\u03c9_motor = G * \u03c9_crank</code> (because the gearbox reduces speed by <code>G</code> when geared for torque).</p> <p>Worked Numeric Example</p> <ul> <li>Suppose <code>\u03c4_crank,max = 0.35 N\u00b7m</code> (from torque sweep).  </li> <li>Choose <code>G = 10</code>, <code>\u03b7 = 0.7</code>, <code>M = 2</code>.</li> </ul> <p>Then the rated motor torque requirement is:</p> \\[ \\tau_{\\text{motor,rated}} = \\frac{0.35}{10 \\times 0.7} \\times 2 = 0.10 \\, \\text{N\u00b7m} \\] <p>and if the crank angular speed is <code>\u03c9_crank = 6 rad/s</code>, then:</p> \\[ \u03c9_{\\text{motor}} = G \\times \u03c9_{\\text{crank}} = 10 \\times 6 = 60 \\text{rad/s} \\ (\\approx 572 RPM) \\] <p>After gearbox, motor angular rate is \u03c9_motor = G * \u03c9_crank (because gearbox reduces speed by G if geared for torque).</p> <p>Then:</p> <pre><code>tau_motor_rated = (0.35 / (10 * 0.7)) * 2 = (0.35 / 7) * 2 = 0.05 * 2 = 0.10 N\u00b7m\n</code></pre> <p>So choose a motor with continuous torque \u2265 0.10 N\u00b7m (plus check stall and peak currents). If motor speed needed: if \u03c9_crank = 6 rad/s, \u03c9_motor = 60 rad/s (~572 RPM). Check motor torque-speed curve to ensure it can supply torque at that speed.</p>"},{"location":"#part-7-discussion-points","title":"Part 7. Discussion Points","text":"<ol> <li>Degrees of freedom and number of motors.</li> <li>How end-effector forces were estimated.</li> <li>How end-effector speeds were estimated.</li> </ol> <p>7.1. Degrees of Freedom and Number of Motors</p> <p>The Klann mechanism used in this design is a planar six-bar linkage that transforms a single rotary input into an approximately linear foot trajectory. Each leg therefore has one degree of freedom (DOF)\u2014the input crank rotation. Since the robot uses six legs, the total system has six actuated DOFs, each driven by one motor connected to the crankshaft of its respective leg. The overall body motion is coordinated through synchronized crank phasing (e.g., tripod gait: left-front, right-middle, left-rear in one phase). Passive joints within each linkage do not require additional motors, which simplifies control and reduces weight and cost compared to a multi-DOF leg design.</p> <p>7.2. How End-Effector Forces Were Estimated</p> <p>End-effector (foot) forces were estimated based on biomechanical scaling and dynamic load distribution during a tripod gait. Assuming the robot mass is 0.8 kg, the total gravitational load is approximately 7.85 N. During stance, three legs support the robot, so each stance leg bears roughly one-third of that load. To account for dynamic impacts and acceleration during gait, a safety factor of 1.5\u00d7 was applied, giving a peak ground reaction force (GRF) of \u2248 3.9 N per leg. This vertical force was used in the Jacobian relationship \\(\\tau = J^T F_{\\text{foot}}\\) to estimate crank torque. The foot force vector was defined in local leg coordinates as \\( [0, 3.9]^T \\) N (purely vertical) for simplicity.</p> <p>7.3. How End-Effector Speeds Were Estimated</p> <p>Foot speeds were derived from the Jacobian matrix of the leg mechanism. By differentiating the foot position vector with respect to crank angle (\\( \\mathbf{J}_\\theta = \\frac{\\partial \\mathbf{x}_{foot}}{\\partial \\theta} \\)) and multiplying by the crank angular velocity (\\( \\dot{\\theta} \\)), the instantaneous foot velocity was computed: $$ \\mathbf{v}{foot} = \\mathbf{J}\\theta \\, \\dot{\\theta} $$ The crank angular velocity was chosen as 6 rad/s, corresponding to a walking speed of approximately 0.3 m/s based on the stride length (0.1 m) and step frequency (\u2248 3 Hz). This kinematic relationship allows prediction of foot motion through the gait cycle and was verified via the MuJoCo simulation, confirming realistic lift and stance trajectories for the desired gait speed.</p>"},{"location":"#part-8-project-files","title":"Part 8. Project Files:","text":"<ul> <li>Option 1: Download the .ipynb file </li> </ul> <p>Download Assignment 1 Notebook (.ipynb)</p> <p>[Download Assignnemnt 1 Notebook improved version][RAS557%20Project%20Assignment%201%20%E2%80%94%20Klann-style%20Hexapod_Dec8_v3.ipynb]</p> <ul> <li>Option 2: Download the .pdf file</li> </ul> <p>Download Assignment 1 Report (PDF)</p>"},{"location":"Project_Assignment_2/","title":"Assignment 2","text":""},{"location":"Project_Assignment_2/#project-assignment-2-design-build-and-simulate-your-robot","title":"Project Assignment 2: Design, Build and Simulate your Robot","text":""},{"location":"Project_Assignment_2/#students-shuai-gao-lixiao-huang-yibo-yuan","title":"Students: Shuai Gao, Lixiao Huang, Yibo Yuan","text":""},{"location":"Project_Assignment_2/#instructor-daniel-aukes-fall-2025","title":"Instructor: Daniel Aukes (Fall 2025)","text":"<p>The purpose of this assignment is to model, optimize, build, and validate your final robot.</p> <p>The first video is our Mujoco simulation. </p> <p>The second video is our Mujoco-generated real-time data while the robot walks. </p> <p>The third video is our physical robot. </p>"},{"location":"Project_Assignment_2/#part-1-define-the-system-model","title":"Part 1: Define the System Model","text":"<p>Produce a final dynamic model in Mujoco that adapts the ideal kinematics of your initial robot model to your \u0234nal geometry, material properties (joint stiffness and beam stiffness), and actuator characteristics. Ensure your model includes some aspect of material compliance / flexibility and motor behavior somewhere in your system, and that you have made it possible to vary at least one design parameter of interest and re-run the simulation in a function, for the purposes of wrapping this function in an optimization process. Plot expected performance of the model over a broad range of possible values, in a way that will be correlated to a real-life experiment.</p> <p>The following codes carry out the simulation and plots. </p> <pre><code>from __future__ import annotations\nimport math\nfrom typing import List\nimport numpy as np\nimport mujoco\nimport mediapy as media\nimport matplotlib.pyplot as plt #this package is for animation of data\nimport matplotlib.animation as animation\nimport shutil, os # this is to solve the mediapy.show_video failure\n</code></pre> <p>The functions of the blocks are described on the first row: </p> <pre><code># ---------------- Global viz params ----------------\nWIDTH, HEIGHT = 1024, 576\nFRAMERATE = 30\nDURATION = 6\nSHOW_VIDEO = True\nSAVE_ANIMATION = True  # set True to save mp4 (requires ffmpeg)\n\n# ---------------- Geometry (inches -&gt; meters) ----------------\nINCH_TO_M = 0.0254\n\nLENGTH_CORR = 0.01 / INCH_TO_M  \n\nFOOT_RADIUS = 0.006   # slimmer feet\nZ_OFFSET    = FOOT_RADIUS\n\n# ========= 2D plan view geometry in INCHES at theta = 0 =========\n# Shared M and B\nM_2D = np.array([0.0, 0.0])\nB_2D = np.array([1.0, 0.0])\n\n# Back leg on each side (D_left)\nD1_2D = np.array([-2.1, 0.0])\nA1_2D = np.array([-5.2, 0.0])\nC1_2D = np.array([-2.1, 2.833725])\nE1_2D = np.array([-3.65, 1.416863])\nF1_2D = np.array([-0.55, 1.416863])\n\n# Front leg on each side (D_right)\nD2_2D = np.array([2.1, 0.0])\nA2_2D = np.array([3.2, 0.0])\nC2_2D = np.array([2.1, 4.053394])\nE2_2D = np.array([2.65, 2.026697])\nF2_2D = np.array([1.55, 2.026697])\n</code></pre> <pre><code>def inch2m_xz(p_inch: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert [x,z]_inch in drawing plane -&gt; [x,z]_meter with ground offset.\"\"\"\n    x_m = p_inch[0] * INCH_TO_M\n    z_m = p_inch[1] * INCH_TO_M + Z_OFFSET\n    return np.array([x_m, z_m])\n\n# Convert to meters (x,z)\nM = inch2m_xz(M_2D)\nB = inch2m_xz(B_2D)\n\nD1 = inch2m_xz(D1_2D)\nA1 = inch2m_xz(A1_2D)\nC1 = inch2m_xz(C1_2D)\nE1 = inch2m_xz(E1_2D)\nF1 = inch2m_xz(F1_2D)\n\nD2 = inch2m_xz(D2_2D)\nA2 = inch2m_xz(A2_2D)\nC2 = inch2m_xz(C2_2D)\nE2 = inch2m_xz(E2_2D)\nF2 = inch2m_xz(F2_2D)\n\n# Shared crank vector (in x\u2013z)\nMB_vec = B - M\n\n#The following is the 3D geometry block:\n# Back leg relative vectors\nBC1_vec = C1 - B\nAC1_vec = A1 - C1\nE1_rel_from_C = E1 - C1\nF1_rel_from_B = F1 - B\nD1_rel = np.array([D1[0] - M[0], 0.0, D1[1] - M[1]])\nDE1_vec = np.array([E1[0] - D1[0], 0.0, E1[1] - D1[1]])\nDF1_vec = np.array([F1[0] - D1[0], 0.0, F1[1] - D1[1]])\n\n# Front leg relative vectors\nBC2_vec = C2 - B\nAC2_vec = A2 - C2\nE2_rel_from_C = E2 - C2\nF2_rel_from_B = F2 - B\nD2_rel = np.array([D2[0] - M[0], 0.0, D2[1] - M[1]])\nDE2_vec = np.array([E2[0] - D2[0], 0.0, E2[1] - D2[1]])\nDF2_vec = np.array([F2[0] - D2[0], 0.0, F2[1] - D2[1]])\n\n# 3D versions (x, y, z); y is lateral\nM_rel = np.zeros(3)\nB_rel = np.array([MB_vec[0], 0.0, MB_vec[1]])   # M -&gt; B\n\nC1_rel_from_B = np.array([BC1_vec[0], 0.0, BC1_vec[1]])\nA1_rel_from_C = np.array([AC1_vec[0], 0.0, AC1_vec[1]])\nE1_rel_from_C_3d = np.array([E1_rel_from_C[0], 0.0, E1_rel_from_C[1]])\nF1_rel_from_B_3d = np.array([F1_rel_from_B[0], 0.0, F1_rel_from_B[1]])\n\nC2_rel_from_B = np.array([BC2_vec[0], 0.0, BC2_vec[1]])\nA2_rel_from_C = np.array([AC2_vec[0], 0.0, AC2_vec[1]])\nE2_rel_from_C_3d = np.array([E2_rel_from_C[0], 0.0, E2_rel_from_C[1]])\nF2_rel_from_B_3d = np.array([F2_rel_from_B[0], 0.0, F2_rel_from_B[1]])\n\nY_OFF = 0.03   # lateral offset for left/right sides\n\n# ---------------- mass / density assumptions ----------------\nDENS_LEG  = 350.0   # kg/m^3, black &amp; green bars\nDENS_FOOT = 500.0   # kg/m^3\nMASS_BASE = 0.010   # chassis box [kg]\nMASS_MOTOR = 0.067  # motor block [kg]\n\n# ---------------- motor specs ----------------\nMAX_TORQUE_REAL = 0.07845           # 800 gf\u00b7cm in N\u00b7m\nMAX_TORQUE_SIM  = 1 * MAX_TORQUE_REAL\n\n# Slightly faster target RPM\nRPM_3V   = 100.0\nOMEGA_DES = RPM_3V / 60.0 * 2.0 * math.pi   # rad/s target speed\n\n# Stronger gain but still not full\nKP_VEL   = 0.7 * (MAX_TORQUE_SIM / OMEGA_DES)\n</code></pre> <pre><code># ----------------------------------------------------------------------\n#  Helper: quaternion -&gt; roll, pitch, yaw\n# ----------------------------------------------------------------------\ndef quat_to_rpy(q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert [w, x, y, z] quaternion -&gt; [roll, pitch, yaw] (rad), ZYX.\"\"\"\n    w, x, y, z = q\n    # roll (x)\n    sinr_cosp = 2.0 * (w * x + y * z)\n    cosr_cosp = 1.0 - 2.0 * (x * x + y * y)\n    roll = math.atan2(sinr_cosp, cosr_cosp)\n    # pitch (y)\n    sinp = 2.0 * (w * y - z * x)\n    if abs(sinp) &gt;= 1.0:\n        pitch = math.copysign(math.pi / 2.0, sinp)\n    else:\n        pitch = math.asin(sinp)\n    # yaw (z)\n    siny_cosp = 2.0 * (w * z + x * y)\n    cosy_cosp = 1.0 - 2.0 * (y * y + z * z)\n    yaw = math.atan2(siny_cosp, cosy_cosp)\n    return np.array([roll, pitch, yaw])\n</code></pre> <pre><code># ======================================================================\n# INSERTED: XML generator for parameter sweeps\n# ======================================================================\n\ndef generate_fourleg_xml(crank_scale: float = 1.0,\n                         max_torque: float | None = None,\n                         foot_radius: float | None = None) -&gt; str:\n    \"\"\"\n    Generate the MuJoCo XML string using the geometry and constants already\n    defined in this module (MB_vec, M_rel, B_rel, DENS_LEG, etc.).\n    Place this function after those definitions.\n    \"\"\"\n    MB_scaled = np.array([MB_vec[0], MB_vec[1]]) * float(crank_scale)\n    mt = float(MAX_TORQUE_SIM if max_torque is None else max_torque)\n    fr = float(FOOT_RADIUS if foot_radius is None else foot_radius)\n\n# ---------------- MuJoCo XML: 4 legs, 6 feet, 1 motor ---------------- \n    xml = f\"\"\"\n&lt;mujoco model=\"fourbar_fourlegs\"&gt;\n  &lt;option timestep=\"0.0002\" gravity=\"0 0 -9.81\"&gt;\n    &lt;flag contact=\"enable\"/&gt;\n  &lt;/option&gt;\n\n  &lt;visual&gt;\n    &lt;global offwidth=\"{WIDTH}\" offheight=\"{HEIGHT}\"/&gt;\n  &lt;/visual&gt;\n\n  &lt;worldbody&gt;\n\n    &lt;!-- ground --&gt;\n    &lt;geom name=\"floor\" type=\"plane\" pos=\"0 0 0\"\n          size=\"2 2 0.02\"\n          friction=\"0.5 0.005 0.0005\"\n          contype=\"1\" conaffinity=\"0\"\n          rgba=\"0.4 0.4 0.4 1\"/&gt;\n\n    &lt;!-- light and camera --&gt;\n    &lt;light name=\"top\" pos=\"0 0 1\" dir=\"0 0 -1\"\n           diffuse=\"1 1 1\" specular=\"0.2 0.2 0.2\"/&gt;\n\n    &lt;camera name=\"cam\" mode=\"fixed\"\n            pos=\"0 -0.5 0.10\"\n            axisangle=\"1 0 0 90\"/&gt;\n\n    &lt;!-- CHASSIS at M, centered between left/right legs (y=0) --&gt;\n    &lt;body name=\"chassis\" pos=\"{M[0]:.5f} 0 {M[1]:.5f}\"&gt;\n      &lt;joint name=\"chassis_free\" type=\"free\"/&gt;\n\n      &lt;!-- base + motor block (smaller) --&gt;\n      &lt;geom name=\"chassis_base\" type=\"box\" size=\"0.007 0.007 0.0045\"\n            mass=\"{MASS_BASE:.4f}\" rgba=\"0.6 0.6 0.6 1\"/&gt;\n      &lt;geom name=\"motor_block\" type=\"box\" size=\"0.009 0.006 0.015\"\n            mass=\"{MASS_MOTOR:.4f}\" pos=\"0 0 0.03\"\n            rgba=\"1 1 0.3 1\"/&gt;\n\n      &lt;!-- ========== D anchors (fixed on chassis) ========== --&gt;\n\n      &lt;!-- Left-back D1_L --&gt;\n      &lt;body name=\"D1_L_body\" pos=\"{D1_rel[0]:.5f} {-Y_OFF:.5f} {D1_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D1_L_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.3 0.8 0.1 1\"/&gt;\n        &lt;site name=\"D1_L_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE1_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE1_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE1_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE1_L_end_site\"\n                pos=\"{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF1_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF1_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF1_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF1_L_end_site\"\n                pos=\"{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- Left-front D2_L --&gt;\n      &lt;body name=\"D2_L_body\" pos=\"{D2_rel[0]:.5f} {-Y_OFF:.5f} {D2_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D2_L_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.3 0.8 0.6 1\"/&gt;\n        &lt;site name=\"D2_L_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE2_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE2_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE2_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE2_L_end_site\"\n                pos=\"{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF2_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF2_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF2_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF2_L_end_site\"\n                pos=\"{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- Right-back D1_R --&gt;\n      &lt;body name=\"D1_R_body\" pos=\"{D1_rel[0]:.5f} {Y_OFF:.5f} {D1_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D1_R_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.1 0.6 0.9 1\"/&gt;\n        &lt;site name=\"D1_R_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE1_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE1_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE1_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE1_R_end_site\"\n                pos=\"{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF1_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF1_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF1_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF1_R_end_site\"\n                pos=\"{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- Right-front D2_R --&gt;\n      &lt;body name=\"D2_R_body\" pos=\"{D2_rel[0]:.5f} {Y_OFF:.5f} {D2_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D2_R_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.3 0.6 0.9 1\"/&gt;\n        &lt;site name=\"D2_R_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE2_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE2_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE2_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE2_R_end_site\"\n                pos=\"{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF2_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF2_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF2_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF2_R_end_site\"\n                pos=\"{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- ========== SINGLE crank root (ONE motor driving both MBs) ========== --&gt;\n      &lt;body name=\"crank_root\" pos=\"{M_rel[0]:.5f} 0 {M_rel[2]:.5f}\"&gt;\n        &lt;!-- single joint, single motor --&gt;\n        &lt;joint name=\"joint_L\" type=\"hinge\"\n               axis=\"0 1 0\" range=\"-720 720\" damping=\"0.01\"/&gt;\n\n        &lt;!-- ===== LEFT side: B_L ===== --&gt;\n        &lt;body name=\"B_L_body\" pos=\"{B_rel[0]:.5f} {-Y_OFF:.5f} {B_rel[2]:.5f}\"&gt;\n          &lt;!-- rod from B_L back to M --&gt;\n          &lt;geom name=\"MB_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {-MB_scaled[0]:.5f} 0 {-MB_scaled[1]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                rgba=\"0.1 0.1 0.1 1\"/&gt;\n\n          &lt;geom name=\"B_L_foot\" type=\"sphere\"\n                pos=\"0 0 0\"\n                size=\"{fr:.4f}\"\n                density=\"{DENS_FOOT:.1f}\"\n                friction=\"0.5 0.005 0.0005\"\n                contype=\"0\" conaffinity=\"1\"\n                rgba=\"0.8 0.2 0.2 1\"/&gt;\n\n          &lt;!-- back left leg --&gt;\n          &lt;body name=\"BC1_L_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC1_L\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC1_L_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F1_L_site\"\n                  pos=\"{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C1_L_body\"\n                  pos=\"{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C1_L_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC1_L_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA1_L\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC1_L_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E1_L_site\"\n                      pos=\"{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A1_L_body\"\n                      pos=\"{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A1_L_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.8 0.2 0.2 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n\n          &lt;!-- front left leg --&gt;\n          &lt;body name=\"BC2_L_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC2_L\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC2_L_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F2_L_site\"\n                  pos=\"{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C2_L_body\"\n                  pos=\"{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C2_L_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC2_L_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA2_L\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC2_L_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E2_L_site\"\n                      pos=\"{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A2_L_body\"\n                      pos=\"{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A2_L_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.8 0.2 0.2 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n        &lt;/body&gt;\n\n        &lt;!-- ===== RIGHT side: B_R, 180\u00b0 around shaft ===== --&gt;\n        &lt;body name=\"B_R_body\"\n              pos=\"{-B_rel[0]:.5f} {Y_OFF:.5f} {-B_rel[2]:.5f}\"&gt;\n          &lt;!-- rod from B_R back to M (opposite direction) --&gt;\n          &lt;geom name=\"MB_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {MB_scaled[0]:.5f} 0 {MB_scaled[1]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                rgba=\"0.1 0.1 0.1 1\"/&gt;\n\n          &lt;geom name=\"B_R_foot\" type=\"sphere\"\n                pos=\"0 0 0\"\n                size=\"{FOOT_RADIUS:.4f}\"\n                density=\"{DENS_FOOT:.1f}\"\n                friction=\"0.5 0.005 0.0005\"\n                contype=\"0\" conaffinity=\"1\"\n                rgba=\"0.2 0.8 0.4 1\"/&gt;\n\n          &lt;!-- back right leg --&gt;\n          &lt;body name=\"BC1_R_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC1_R\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC1_R_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F1_R_site\"\n                  pos=\"{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C1_R_body\"\n                  pos=\"{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C1_R_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC1_R_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA1_R\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC1_R_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E1_R_site\"\n                      pos=\"{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A1_R_body\"\n                      pos=\"{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A1_R_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.2 0.8 0.4 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n\n          &lt;!-- front right leg --&gt;\n          &lt;body name=\"BC2_R_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC2_R\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC2_R_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F2_R_site\"\n                  pos=\"{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C2_R_body\"\n                  pos=\"{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C2_R_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC2_R_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA2_R\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC2_R_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E2_R_site\"\n                      pos=\"{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A2_R_body\"\n                      pos=\"{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A2_R_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.2 0.8 0.4 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n    &lt;/body&gt; &lt;!-- end chassis --&gt;\n\n  &lt;/worldbody&gt;\n\n  &lt;!-- 4-bar equality constraints (DE/DF only) --&gt;\n  &lt;equality&gt;\n    &lt;!-- Left-back leg --&gt;\n    &lt;connect name=\"DE1_L_eq\"\n             site1=\"DE1_L_end_site\" site2=\"E1_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF1_L_eq\"\n             site1=\"DF1_L_end_site\" site2=\"F1_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n\n    &lt;!-- Left-front leg --&gt;\n    &lt;connect name=\"DE2_L_eq\"\n             site1=\"DE2_L_end_site\" site2=\"E2_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF2_L_eq\"\n             site1=\"DF2_L_end_site\" site2=\"F2_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n\n    &lt;!-- Right-back leg --&gt;\n    &lt;connect name=\"DE1_R_eq\"\n             site1=\"DE1_R_end_site\" site2=\"E1_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF1_R_eq\"\n             site1=\"DF1_R_end_site\" site2=\"F1_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n\n    &lt;!-- Right-front leg --&gt;\n    &lt;connect name=\"DE2_R_eq\"\n             site1=\"DE2_R_end_site\" site2=\"E2_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF2_R_eq\"\n             site1=\"DF2_R_end_site\" site2=\"F2_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n  &lt;/equality&gt;\n\n  &lt;actuator&gt;\n    &lt;!-- one motor, one joint, positive torque only --&gt;\n    &lt;motor name=\"hip_motor\" joint=\"joint_L\"\n           gear=\"1.0\" ctrlrange=\"0 {mt:.5f}\"/&gt;\n  &lt;/actuator&gt;\n\n&lt;/mujoco&gt;\n\"\"\"\n    return xml\n</code></pre> <pre><code># MuJoCo XML: 4 legs, 6 feet, 1 motor\n\nDYN_FOURLEG_XML = f\"\"\"\n&lt;mujoco model=\"fourbar_fourlegs\"&gt;\n  &lt;option timestep=\"0.0002\" gravity=\"0 0 -9.81\"&gt;\n    &lt;flag contact=\"enable\"/&gt;\n  &lt;/option&gt;\n\n  &lt;visual&gt;\n    &lt;global offwidth=\"{WIDTH}\" offheight=\"{HEIGHT}\"/&gt;\n  &lt;/visual&gt;\n\n  &lt;worldbody&gt;\n\n      &lt;!-- ground --&gt;\n    &lt;geom name=\"floor\" type=\"plane\" pos=\"0 0 0\"\n          size=\"2 2 0.02\"\n          friction=\"0.5 0.005 0.0005\"\n          contype=\"1\" conaffinity=\"0\"\n          rgba=\"0.4 0.4 0.4 1\"/&gt;\n\n    &lt;!-- light and camera --&gt;\n    &lt;light name=\"top\" pos=\"0 0 1\" dir=\"0 0 -1\"\n           diffuse=\"1 1 1\" specular=\"0.2 0.2 0.2\"/&gt;\n\n    &lt;camera name=\"cam\" mode=\"fixed\"\n            pos=\"0 -0.5 0.10\"\n            axisangle=\"1 0 0 90\"/&gt;\n\n    &lt;!-- CHASSIS at M, centered between left/right legs (y=0) --&gt;\n    &lt;body name=\"chassis\" pos=\"{M[0]:.5f} 0 {M[1]:.5f}\"&gt;\n      &lt;joint name=\"chassis_free\" type=\"free\"/&gt;\n\n      &lt;!-- base + motor block (smaller) --&gt;\n      &lt;geom name=\"chassis_base\" type=\"box\" size=\"0.007 0.007 0.0045\"\n            mass=\"{MASS_BASE:.4f}\" rgba=\"0.6 0.6 0.6 1\"/&gt;\n      &lt;geom name=\"motor_block\" type=\"box\" size=\"0.009 0.006 0.015\"\n            mass=\"{MASS_MOTOR:.4f}\" pos=\"0 0 0.03\"\n            rgba=\"1 1 0.3 1\"/&gt;\n\n      &lt;!-- ========== D anchors (fixed on chassis) ========== --&gt;\n\n      &lt;!-- Left-back D1_L --&gt;\n      &lt;body name=\"D1_L_body\" pos=\"{D1_rel[0]:.5f} {-Y_OFF:.5f} {D1_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D1_L_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.3 0.8 0.1 1\"/&gt;\n        &lt;site name=\"D1_L_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE1_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE1_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE1_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE1_L_end_site\"\n                pos=\"{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF1_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF1_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF1_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF1_L_end_site\"\n                pos=\"{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- Left-front D2_L --&gt;\n      &lt;body name=\"D2_L_body\" pos=\"{D2_rel[0]:.5f} {-Y_OFF:.5f} {D2_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D2_L_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.3 0.8 0.6 1\"/&gt;\n        &lt;site name=\"D2_L_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE2_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE2_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE2_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE2_L_end_site\"\n                pos=\"{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF2_L_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF2_L\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF2_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF2_L_end_site\"\n                pos=\"{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- Right-back D1_R --&gt;\n      &lt;body name=\"D1_R_body\" pos=\"{D1_rel[0]:.5f} {Y_OFF:.5f} {D1_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D1_R_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.1 0.6 0.9 1\"/&gt;\n        &lt;site name=\"D1_R_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE1_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE1_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE1_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE1_R_end_site\"\n                pos=\"{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF1_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF1_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF1_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF1_R_end_site\"\n                pos=\"{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- Right-front D2_R --&gt;\n      &lt;body name=\"D2_R_body\" pos=\"{D2_rel[0]:.5f} {Y_OFF:.5f} {D2_rel[2]:.5f}\"&gt;\n        &lt;geom name=\"D2_R_marker\" type=\"sphere\" size=\"0.0018\"\n              density=\"1000\" rgba=\"0.3 0.6 0.9 1\"/&gt;\n        &lt;site name=\"D2_R_site\" pos=\"0 0 0\" size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n        &lt;body name=\"DE2_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DE2_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DE2_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DE2_R_end_site\"\n                pos=\"{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"DF2_R_body\" pos=\"0 0 0\"&gt;\n          &lt;joint name=\"joint_DF2_R\" type=\"hinge\"\n                 axis=\"0 1 0\" damping=\"0.001\"/&gt;\n          &lt;geom name=\"DF2_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0022\"\n                contype=\"0\" conaffinity=\"0\"\n                rgba=\"0.0 0.7 0.0 1\"/&gt;\n          &lt;site name=\"DF2_R_end_site\"\n                pos=\"{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}\"\n                size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n      &lt;!-- ========== SINGLE crank root (ONE motor driving both MBs) ========== --&gt;\n      &lt;body name=\"crank_root\" pos=\"{M_rel[0]:.5f} 0 {M_rel[2]:.5f}\"&gt;\n        &lt;!-- single joint, single motor --&gt;\n        &lt;joint name=\"joint_L\" type=\"hinge\"\n               axis=\"0 1 0\" range=\"-720 720\" damping=\"0.01\"/&gt;\n\n        &lt;!-- ===== LEFT side: B_L ===== --&gt;\n        &lt;body name=\"B_L_body\" pos=\"{B_rel[0]:.5f} {-Y_OFF:.5f} {B_rel[2]:.5f}\"&gt;\n          &lt;!-- rod from B_L back to M --&gt;\n          &lt;geom name=\"MB_L_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {-MB_vec[0]:.5f} 0 {-MB_vec[1]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                rgba=\"0.1 0.1 0.1 1\"/&gt;\n\n          &lt;geom name=\"B_L_foot\" type=\"sphere\"\n                pos=\"0 0 0\"\n                size=\"{FOOT_RADIUS:.4f}\"\n                density=\"{DENS_FOOT:.1f}\"\n                friction=\"0.5 0.005 0.0005\"\n                contype=\"0\" conaffinity=\"1\"\n                rgba=\"0.8 0.2 0.2 1\"/&gt;\n\n          &lt;!-- back left leg --&gt;\n          &lt;body name=\"BC1_L_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC1_L\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC1_L_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F1_L_site\"\n                  pos=\"{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C1_L_body\"\n                  pos=\"{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C1_L_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC1_L_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA1_L\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC1_L_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E1_L_site\"\n                      pos=\"{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A1_L_body\"\n                      pos=\"{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A1_L_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.8 0.2 0.2 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n\n          &lt;!-- front left leg --&gt;\n          &lt;body name=\"BC2_L_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC2_L\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC2_L_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F2_L_site\"\n                  pos=\"{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C2_L_body\"\n                  pos=\"{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C2_L_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC2_L_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA2_L\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC2_L_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E2_L_site\"\n                      pos=\"{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A2_L_body\"\n                      pos=\"{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A2_L_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.8 0.2 0.2 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n        &lt;/body&gt;\n\n        &lt;!-- ===== RIGHT side: B_R, 180\u00b0 around shaft ===== --&gt;\n        &lt;body name=\"B_R_body\"\n              pos=\"{-B_rel[0]:.5f} {Y_OFF:.5f} {-B_rel[2]:.5f}\"&gt;\n          &lt;!-- rod from B_R back to M (opposite direction) --&gt;\n          &lt;geom name=\"MB_R_bar\" type=\"capsule\"\n                fromto=\"0 0 0   {MB_vec[0]:.5f} 0 {MB_vec[1]:.5f}\"\n                density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                rgba=\"0.1 0.1 0.1 1\"/&gt;\n\n          &lt;geom name=\"B_R_foot\" type=\"sphere\"\n                pos=\"0 0 0\"\n                size=\"{FOOT_RADIUS:.4f}\"\n                density=\"{DENS_FOOT:.1f}\"\n                friction=\"0.5 0.005 0.0005\"\n                contype=\"0\" conaffinity=\"1\"\n                rgba=\"0.2 0.8 0.4 1\"/&gt;\n\n          &lt;!-- back right leg --&gt;\n          &lt;body name=\"BC1_R_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC1_R\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC1_R_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F1_R_site\"\n                  pos=\"{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C1_R_body\"\n                  pos=\"{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C1_R_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC1_R_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA1_R\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC1_R_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E1_R_site\"\n                      pos=\"{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A1_R_body\"\n                      pos=\"{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A1_R_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.2 0.8 0.4 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n\n          &lt;!-- front right leg --&gt;\n          &lt;body name=\"BC2_R_body\" pos=\"0 0 0\"&gt;\n            &lt;joint name=\"joint_BC2_R\" type=\"hinge\"\n                   axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n            &lt;geom name=\"BC2_R_bar\" type=\"capsule\"\n                  fromto=\"0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"\n                  density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                  rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n            &lt;site name=\"F2_R_site\"\n                  pos=\"{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}\"\n                  size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n            &lt;body name=\"C2_R_body\"\n                  pos=\"{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}\"&gt;\n              &lt;geom name=\"C2_R_marker\" type=\"sphere\" size=\"0.0018\"\n                    density=\"1000\" rgba=\"0.1 0.3 0.9 1\"/&gt;\n\n              &lt;body name=\"AC2_R_body\" pos=\"0 0 0\"&gt;\n                &lt;joint name=\"joint_CA2_R\" type=\"hinge\"\n                       axis=\"0 1 0\" damping=\"0.001\"/&gt;\n\n                &lt;geom name=\"AC2_R_bar\" type=\"capsule\"\n                      fromto=\"0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"\n                      density=\"{DENS_LEG:.1f}\" size=\"0.0028\"\n                      rgba=\"0.15 0.15 0.15 1\"/&gt;\n\n                &lt;site name=\"E2_R_site\"\n                      pos=\"{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}\"\n                      size=\"0.001\" rgba=\"0 0 0 0\"/&gt;\n\n                &lt;body name=\"A2_R_body\"\n                      pos=\"{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}\"&gt;\n                  &lt;geom name=\"A2_R_foot\" type=\"sphere\"\n                        size=\"{FOOT_RADIUS:.4f}\"\n                        density=\"{DENS_FOOT:.1f}\"\n                        friction=\"0.5 0.005 0.0005\"\n                        contype=\"0\" conaffinity=\"1\"\n                        rgba=\"0.2 0.8 0.4 1\"/&gt;\n                &lt;/body&gt;\n              &lt;/body&gt;\n            &lt;/body&gt;\n          &lt;/body&gt;\n        &lt;/body&gt;\n      &lt;/body&gt;\n\n    &lt;/body&gt; &lt;!-- end chassis --&gt;\n\n  &lt;/worldbody&gt;\n\n  &lt;!-- 4-bar equality constraints (DE/DF only) --&gt;\n  &lt;equality&gt;\n    &lt;!-- Left-back leg --&gt;\n    &lt;connect name=\"DE1_L_eq\"\n             site1=\"DE1_L_end_site\" site2=\"E1_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF1_L_eq\"\n             site1=\"DF1_L_end_site\" site2=\"F1_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n\n    &lt;!-- Left-front leg --&gt;\n    &lt;connect name=\"DE2_L_eq\"\n             site1=\"DE2_L_end_site\" site2=\"E2_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF2_L_eq\"\n             site1=\"DF2_L_end_site\" site2=\"F2_L_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n\n    &lt;!-- Right-back leg --&gt;\n    &lt;connect name=\"DE1_R_eq\"\n             site1=\"DE1_R_end_site\" site2=\"E1_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF1_R_eq\"\n             site1=\"DF1_R_end_site\" site2=\"F1_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n\n    &lt;!-- Right-front leg --&gt;\n    &lt;connect name=\"DE2_R_eq\"\n             site1=\"DE2_R_end_site\" site2=\"E2_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n    &lt;connect name=\"DF2_R_eq\"\n             site1=\"DF2_R_end_site\" site2=\"F2_R_site\"\n             solref=\"0.005 1\" solimp=\"0.8 0.95 0.001\"/&gt;\n  &lt;/equality&gt;\n\n  &lt;actuator&gt;\n    &lt;!-- one motor, one joint, positive torque only --&gt;\n    &lt;motor name=\"hip_motor\" joint=\"joint_L\"\n           gear=\"1.0\" ctrlrange=\"0 {MAX_TORQUE_SIM:.5f}\"/&gt;\n  &lt;/actuator&gt;\n\n&lt;/mujoco&gt;\n\"\"\"\n</code></pre>"},{"location":"Project_Assignment_2/#simulation-code","title":"Simulation code","text":"<p>def run_fourleg() -&gt; Tuple[List[np.ndarray], mujoco.MjModel, mujoco.MjData, dict, List[float]]:     model = mujoco.MjModel.from_xml_string(DYN_FOURLEG_XML)     data = mujoco.MjData(model)</p> <pre><code># motor joint is joint_L\njid  = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, \"joint_L\")\nqadr = model.jnt_qposadr[jid]\ndadr = model.jnt_dofadr[jid]\n\n# free-base joint (chassis_free: 7 DoF, 7 qpos: x y z qw qx qy qz)\njid_base = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, \"chassis_free\")\nqadr_base = model.jnt_qposadr[jid_base]\n\ndt    = model.opt.timestep\nsteps = int(DURATION / dt)\n\n# start from a slight offset so we're not exactly at a singular pose\ndata.qpos[qadr] = math.radians(-20.0)\n\nrenderer = mujoco.Renderer(model, width=WIDTH, height=HEIGHT)\nframes: List[np.ndarray] = []\nframe_times: List[float] = []\n\n# which joints to log/plot\nJOINTS_TO_PLOT = [\"joint_L\"]\nq_idx = []\ndq_idx = []\nfor name in JOINTS_TO_PLOT:\n    j_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, name)\n    q_idx.append(model.jnt_qposadr[j_id])\n    dq_idx.append(model.jnt_dofadr[j_id])\n\n# ----------------- logging buffers -----------------\nt_log: List[float]        = []\nq_log: List[np.ndarray]   = []\ndq_log: List[np.ndarray]  = []\nu_log: List[float]        = []\ntau_log: List[float]      = []\nbase_xyz_log: List[np.ndarray] = []\nbase_rpy_log: List[np.ndarray] = []\n\n# ramp time for motor (seconds)\nramp_T = 0.45\nsample_skip = 1   # log every N steps to keep arrays small\n\nfor k in range(steps):\n    t = k * dt\n\n    # ========= gentle, ramped velocity command/ motor command ramp=========\n    # ramp from 0 to OMEGA_DES over ramp_T seconds\n    phase = min(1.0, t / ramp_T)\n    omega_cmd = phase * OMEGA_DES\n\n    dq  = data.qvel[dadr]\n    err = omega_cmd - dq\n\n    tau = KP_VEL * err\n\n    # clamp torque to a safe range, only positive torque\n    tau = max(0.0, min(MAX_TORQUE_SIM, tau))\n    data.ctrl[0] = tau\n\n    # ================== step physics ====================\n    mujoco.mj_step(model, data)\n\n    # -------- NaN guard: bail out if solver explodes ----\n    if (not np.isfinite(data.qpos).all()) or (not np.isfinite(data.qvel).all()):\n        print(f\"NaN detected at step {k}, t={t:.4f} s, aborting simulation.\")\n        break\n\n    # -------------- log data every few steps -----------\n    if k % sample_skip == 0:\n        t_log.append(t)\n\n        q_sample  = np.array([data.qpos[i] for i in q_idx])\n        dq_sample = np.array([data.qvel[i] for i in dq_idx])\n        q_log.append(q_sample)\n        dq_log.append(dq_sample)\n\n        u_log.append(float(data.ctrl[0]))\n        tau_log.append(float(data.qfrc_actuator[dadr]))\n\n        base_xyz  = data.qpos[qadr_base : qadr_base + 3].copy()\n        base_quat = data.qpos[qadr_base + 3 : qadr_base + 7].copy()\n        base_rpy  = quat_to_rpy(base_quat)\n\n        base_xyz_log.append(base_xyz)\n        base_rpy_log.append(base_rpy)\n\n#     # -------------- video frame capture ----------------\n#     if k % max(1, int(1.0 / (dt * FRAMERATE))) == 0:\n#         renderer.update_scene(data, camera=\"cam\")\n#         frames.append(renderer.render().copy())\n#         frame_times.append(t)   # record the sim time for this frame\n\n# if SHOW_VIDEO and frames:\n#     try:\n#         # try a common codec; mediapy will still fall back if needed\n#         media.show_video(frames, fps=FRAMERATE, width=WIDTH, height=HEIGHT)\n#     except Exception as e:\n#         print(\"mediapy.show_video failed (ffmpeg/codec issue):\", e)\n#         print(\"Continuing without mediapy preview \u2014 animation and saving will still run.\")\n\n        # -------------- video frame capture ----------------\n    if k % max(1, int(1.0 / (dt * FRAMERATE))) == 0:\n        renderer.update_scene(data, camera=\"cam\")\n        frames.append(renderer.render().copy())\n\n    # Set ffmpeg path BEFORE using mediapy\n    os.environ[\"IMAGEIO_FFMPEG_EXE\"] = shutil.which(\"ffmpeg\")\n\n# For some reason, the following code suddenly failed    \n# if SHOW_VIDEO and frames:\n#     media.show_video(frames, fps=FRAMERATE, width=WIDTH, height=HEIGHT)\n\n\nif SHOW_VIDEO and frames:\n    try:\n        media.show_video(frames, fps=FRAMERATE, width=WIDTH, height=HEIGHT)\n    except Exception as e:\n        # Show a helpful message and continue \u2014 saving/animation later can still run\n        print(\"mediapy.show_video failed (ffmpeg/codec issue):\", e)\n        print(\"Continuing without mediapy preview \u2014 animation and saving will still run.\")\n\n # pack logs into dict for plotting\nlogs = {\n    \"t\": np.asarray(t_log),\n    \"q\": np.vstack(q_log) if q_log else np.zeros((0, len(q_idx))),\n    \"dq\": np.vstack(dq_log) if dq_log else np.zeros((0, len(dq_idx))),\n    \"u\": np.asarray(u_log),\n    \"tau\": np.asarray(tau_log),\n    \"base_xyz\": np.vstack(base_xyz_log) if base_xyz_log else np.zeros((0, 3)),\n    \"base_rpy\": np.vstack(base_rpy_log) if base_rpy_log else np.zeros((0, 3)),\n    \"joint_names\": JOINTS_TO_PLOT,\n    \"frame_times\": np.asarray(frame_times),\n}\n\nreturn frames, model, data, logs, frame_times\n</code></pre> <p><code></code> <code>def plot_results(logs):     t        = logs[\"t\"]     q        = logs[\"q\"]     dq       = logs[\"dq\"]     u        = logs[\"u\"]     tau      = logs[\"tau\"]     base_xyz = logs[\"base_xyz\"]     base_rpy = logs[\"base_rpy\"]     joint_names = logs[\"joint_names\"]      xyz_corr = base_xyz * LENGTH_CORR        fig, axs = plt.subplots(3, 2, figsize=(10, 8))     ax_pos, ax_vel, ax_ctrl, ax_tau, ax_base, ax_rpy = \\         axs[0, 0], axs[0, 1], axs[1, 0], axs[1, 1], axs[2, 0], axs[2, 1]      # ---- joint positions ----     for j, name in enumerate(joint_names):       ax_pos.plot(t, q[:, j], label=name)       ax_pos.set_title(\"Joint Positions\")       ax_pos.set_ylabel(\"q [rad]\")       ax_pos.legend(fontsize=8, loc=\"upper left\")      # ---- joint velocities ----     for j, name in enumerate(joint_names):       ax_vel.plot(t, dq[:, j], label=name)       ax_vel.set_title(\"Joint Velocities\")       ax_vel.set_ylabel(\"dq [rad/s]\")       ax_vel.legend(fontsize=8, loc=\"upper left\")      # ---- motor control ----     ax_ctrl.plot(t, u, label=\"u\")     ax_ctrl.set_title(\"Motor Control (ctrl)\")     ax_ctrl.set_ylabel(\"Signal\")     ax_ctrl.legend(fontsize=8, loc=\"upper left\")      # ---- motor torque ----     ax_tau.plot(t, tau, label=\"tau\")     ax_tau.set_title(\"Motor Torque (qfrc_actuator)\")     ax_tau.set_ylabel(\"Torque [N\u00b7m]\")     ax_tau.legend(fontsize=8, loc=\"upper left\")      # ---- base position (cm-corrected geometry, still meters) ----     ax_base.plot(t, xyz_corr[:, 0], label=\"x (cm-corrected)\")     ax_base.plot(t, xyz_corr[:, 1], label=\"y (cm-corrected)\")     ax_base.plot(t, xyz_corr[:, 2], label=\"z (cm-corrected)\")     ax_base.set_title(\"Base Position (corrected for cm input)\")     ax_base.set_ylabel(\"Meters (cm-corrected)\")     ax_base.set_xlabel(\"Time [s]\")     ax_base.legend(fontsize=8, loc=\"upper left\")      # ---- base orientation ----     ax_rpy.plot(t, base_rpy[:, 0], label=\"roll\")     ax_rpy.plot(t, base_rpy[:, 1], label=\"pitch\")     ax_rpy.plot(t, base_rpy[:, 2], label=\"yaw\")     ax_rpy.set_title(\"Base Orientation\")     ax_rpy.set_ylabel(\"Rad\")     ax_rpy.set_xlabel(\"Time [s]\")     ax_rpy.legend(fontsize=8, loc=\"upper left\")      fig.tight_layout()     plt.show()</code></p> <pre><code>def animate_results(frames: List[np.ndarray], logs: dict, frame_times: List[float], out_filename=None):\n    t        = logs[\"t\"]\n    q        = logs[\"q\"]\n    dq       = logs[\"dq\"]\n    u        = logs[\"u\"]\n    tau      = logs[\"tau\"]\n    base_xyz = logs[\"base_xyz\"]\n    base_rpy = logs[\"base_rpy\"]\n    joint_names = logs[\"joint_names\"]\n\n    if t.size == 0:\n        print(\"No logged data to animate.\")\n        return\n\n    # If frame_times is empty but frames exist, reconstruct approximate times\n    if (len(frame_times) == 0) and frames:\n        # uniformly space the frame times across the logged time interval\n        frame_times = np.linspace(float(t[0]), float(t[-1]), len(frames))\n        print(\"Reconstructed frame_times from logs: using\", len(frame_times), \"frames\")\n\n    # Map each captured frame time -&gt; nearest logged sample index\n    frame_times = np.asarray(frame_times)\n    sample_indices = np.searchsorted(t, frame_times, side=\"right\") - 1\n    sample_indices = np.clip(sample_indices, 0, t.size - 1)\n\n    # Prepare figure with 3x2 axes plus an inset for the rendering image\n    fig, axs = plt.subplots(3, 2, figsize=(12, 9))\n    ax_pos, ax_vel, ax_ctrl, ax_tau, ax_base, ax_rpy = \\\n        axs[0, 0], axs[0, 1], axs[1, 0], axs[1, 1], axs[2, 0], axs[2, 1]\n\n    # Set up lines (initially empty)\n    pos_lines = []\n    for j, name in enumerate(joint_names):\n        (ln,) = ax_pos.plot([], [], label=name)\n        pos_lines.append(ln)\n    ax_pos.set_title(\"Joint Positions\")\n    ax_pos.set_ylabel(\"q [rad]\")\n    ax_pos.legend(fontsize=8, loc=\"upper left\")\n\n    vel_lines = []\n    for j, name in enumerate(joint_names):\n        (ln,) = ax_vel.plot([], [], label=name)\n        vel_lines.append(ln)\n    ax_vel.set_title(\"Joint Velocities\")\n    ax_vel.set_ylabel(\"dq [rad/s]\")\n    ax_vel.legend(fontsize=8, loc=\"upper left\")\n\n    ctrl_line, = ax_ctrl.plot([], [], label=\"u\")\n    ax_ctrl.set_title(\"Motor Control (ctrl)\")\n    ax_ctrl.set_ylabel(\"Signal\")\n    ax_ctrl.legend(fontsize=8, loc=\"upper left\")\n\n    tau_line, = ax_tau.plot([], [], label=\"tau\")\n    ax_tau.set_title(\"Motor Torque (qfrc_actuator)\")\n    ax_tau.set_ylabel(\"Torque [N\u00b7m]\")\n    ax_tau.legend(fontsize=8, loc=\"upper left\")\n\n    base_x_line, = ax_base.plot([], [], label=\"x (cm-corr)\")\n    base_y_line, = ax_base.plot([], [], label=\"y (cm-corr)\")\n    base_z_line, = ax_base.plot([], [], label=\"z (cm-corr)\")\n    ax_base.set_title(\"Base Position (corrected)\")\n    ax_base.set_ylabel(\"Meters (cm-corrected)\")\n    ax_base.set_xlabel(\"Time [s]\")\n    ax_base.legend(fontsize=8, loc=\"upper left\")\n\n    rln, = ax_rpy.plot([], [], label=\"roll\")\n    pln, = ax_rpy.plot([], [], label=\"pitch\")\n    yln, = ax_rpy.plot([], [], label=\"yaw\")\n    rpy_lines = [rln, pln, yln]\n    ax_rpy.set_title(\"Base Orientation\")\n    ax_rpy.set_ylabel(\"Rad\")\n    ax_rpy.set_xlabel(\"Time [s]\")\n    ax_rpy.legend(fontsize=8, loc=\"upper left\")\n\n    # Precompute plotting limits from logged data (with small margins)\n    ax_pos.set_xlim(float(t[0]), float(t[-1]))\n    qmin, qmax = np.min(q), np.max(q)\n    margin = max(1e-6, 0.1 * max(abs(qmin), abs(qmax)))\n    ax_pos.set_ylim(qmin - margin, qmax + margin)\n\n    ax_vel.set_xlim(float(t[0]), float(t[-1]))\n    if dq.size:\n        dmin, dmax = np.min(dq), np.max(dq)\n        md = max(1e-6, 0.1 * max(abs(dmin), abs(dmax)))\n        ax_vel.set_ylim(dmin - md, dmax + md)\n\n    ax_ctrl.set_xlim(float(t[0]), float(t[-1]))\n    ax_ctrl.set_ylim(np.min(u) - 1e-6, np.max(u) + 1e-6)\n\n    ax_tau.set_xlim(float(t[0]), float(t[-1]))\n    ax_tau.set_ylim(np.min(tau) - 1e-6, np.max(tau) + 1e-6)\n\n    ax_base.set_xlim(float(t[0]), float(t[-1]))\n    if base_xyz.size:\n        xyz_corr = base_xyz * LENGTH_CORR\n        bxmin, bxmax = np.min(xyz_corr), np.max(xyz_corr)\n        bmargin = max(1e-6, 0.1 * max(abs(bxmin), abs(bxmax)))\n        ax_base.set_ylim(bxmin - bmargin, bxmax + bmargin)\n    else:\n        xyz_corr = np.zeros_like(base_xyz)\n\n    ax_rpy.set_xlim(float(t[0]), float(t[-1]))\n    if base_rpy.size:\n        rmin, rmax = np.min(base_rpy), np.max(base_rpy)\n        ax_rpy.set_ylim(rmin - 0.1, rmax + 0.1)\n\n    # Add an axes for the renderer frames and display the first frame.\n    # Put it in lower-right so it doesn't occlude main plots.\n    img_ax = fig.add_axes([0.75, 0.78, 0.20, 0.20])  # x, y, w, h\n    # img_ax = fig.add_axes([0.35, 0.88, 0.30, 0.20])  # above everything\n    img_ax.axis('off')\n\n    if frames:\n        im = img_ax.imshow(frames[0])\n    else:\n        blank = np.zeros((HEIGHT, WIDTH, 3), dtype=np.uint8)\n        im = img_ax.imshow(blank)\n\n    # Animation will have one step per renderer frame\n    n_steps = len(frame_times)\n    if n_steps &lt;= 0:\n        print(\"No frames to animate.\")\n        return\n\n    # compute interval from adjacent frame times (ms)\n    if n_steps &gt; 1:\n        interval_ms = 1000.0 * float(frame_times[1] - frame_times[0])\n    else:\n        interval_ms = 1000.0 / FRAMERATE\n\n    # Update function: i indexes frames (0..n_steps-1)\n    def update(i):\n        # find the largest logged-sample index corresponding to this frame\n        max_idx = int(sample_indices[i])\n\n        ti = t[: max_idx + 1]\n\n        # update joint pos/vel lines\n        for j, ln in enumerate(pos_lines):\n            ln.set_data(ti, q[: max_idx + 1, j])\n        for j, ln in enumerate(vel_lines):\n            if dq.size:\n                ln.set_data(ti, dq[: max_idx + 1, j])\n\n        # update ctrl &amp; torque\n        ctrl_line.set_data(ti, u[: max_idx + 1])\n        tau_line.set_data(ti, tau[: max_idx + 1])\n\n        # update base pos\n        if base_xyz.size:\n            base_x_line.set_data(ti, xyz_corr[: max_idx + 1, 0])\n            base_y_line.set_data(ti, xyz_corr[: max_idx + 1, 1])\n            base_z_line.set_data(ti, xyz_corr[: max_idx + 1, 2])\n\n        # update rpy\n        if base_rpy.size:\n            rpy_lines[0].set_data(ti, base_rpy[: max_idx + 1, 0])\n            rpy_lines[1].set_data(ti, base_rpy[: max_idx + 1, 1])\n            rpy_lines[2].set_data(ti, base_rpy[: max_idx + 1, 2])\n\n        # update image frame\n        if frames:\n            im.set_data(frames[i])\n\n        return pos_lines + vel_lines + [ctrl_line, tau_line, base_x_line, base_y_line, base_z_line] + rpy_lines + [im]\n\n    ani = animation.FuncAnimation(fig, update, frames=n_steps, interval=interval_ms, blit=False, repeat=False)\n\n    # tidy layout and show\n    plt.subplots_adjust(left=0.06, right=0.95, top=0.96, bottom=0.06, hspace=0.35, wspace=0.28)\n    plt.show()\n\n\n    if SAVE_ANIMATION:\n        # normalize filename: default to mp4 if not specified\n        if out_filename is None:\n            out_filename = \"fourleg_animation.mp4\"\n        else:\n            # add .mp4 if user omitted a known extension\n            if not out_filename.lower().endswith((\".mp4\", \".gif\")):\n                out_filename = out_filename + \".mp4\"\n\n        # prefer mp4 via ffmpeg if available\n        if out_filename.lower().endswith(\".mp4\") and shutil.which(\"ffmpeg\") is not None:\n            try:\n                writer = animation.FFMpegWriter(fps=FRAMERATE)\n                ani.save(out_filename, writer=writer)\n                print(f\"Saved animation to {out_filename}\")\n            except Exception as e:\n                print(\"FFMpegWriter save failed:\", e)\n        else:\n            # fallback to GIF using PillowWriter (no ffmpeg required)\n            try:\n                gif_out = out_filename.rsplit(\".\", 1)[0] + \".gif\"\n                from matplotlib.animation import PillowWriter\n                pwriter = PillowWriter(fps=FRAMERATE)\n                ani.save(gif_out, writer=pwriter)\n                print(f\"Saved animation to {gif_out}\")\n                print(\"See the produced video\")\n            except Exception as e:\n                print(\"Could not save animation (FFMpeg missing or save failed):\", e)\n\n\nif __name__ == \"__main__\":\n    frames, model, data, logs, frame_times = run_fourleg()\n    # animate_results(frames, logs, frame_times, out_filename=\"Hexapod_animation_initial\")\n    animate_results(frames, logs, frame_times, out_filename=\"Hexapod_animation_optimized\")\n    plot_results(logs)\n\n    # # choose mode\n    # USE_DYNAMIC = True\n\n    # # The following prints the dynamic results\n    # if USE_DYNAMIC:\n    #     animate_results(frames, logs, frame_times, out_filename=\"Hexapod_animation_initial\")\n    # else:\n    #     plot_results(logs)\n</code></pre> <p> Figure 1. Data output shows the static version of sweep results</p> <p>This video shows the real-time dynamical data collection in Mujoco. </p>"},{"location":"Project_Assignment_2/#part-2-optimize-your-design","title":"Part 2: Optimize your design","text":"<p>Using your Mujoco Model along with your prototype, select one or more design parameter(s) for additional study. How does varying this design variable impact your robot\u2019s performance?</p> <ol> <li>This may require you to develop an XML template and regenerate your model programmatically as needed</li> </ol> <p>We pick motor torque limit (MAX_TORQUE_SIM) as the example design parameter (it's physically meaningful for the actuator-limited crank drive). It can be swaped with any other scalar parameter (crank length, foot radius, lateral offset Y_OFF, mass, damping, etc.) by changing the param_name and where it\u2019s substituted in the XML template.</p> <ol> <li>Select a metric that describes the performance of your robot. This may be robot speed, overal distance travlled in a certain direction, efficiency, etc.</li> </ol> <p>Metric definitions</p> <p>We compute two metrics per simulation run:</p> <ul> <li> <p>Forward Distance (m) \u2014 base_x_final - base_x_initial (use base world x position from data.qpos or data.site_xpos if you prefer a specific site).</p> </li> <li> <p>Energy used (J) \u2014 numerical integral over simulation of actuator power: sum(|tau * joint_vel| * dt) where tau is data.qfrc_actuator for the motor and joint_vel is the motor joint velocity. We use absolute work approximated by |torque * angular_velocity| * dt. Optionally divide distance by energy for efficiency (m/J).</p> </li> </ul> <p>Our XML already contains many  elements (e.g., DE1_L_end_site, E1_L_site, F1_L_site, D1_L_site, and possibly the chassis motor_block geom). To measure chassis base world position, we'll use the free body joint chassis_free qpos (first three elements of data.qpos at the base qpos address), which you already logged in base_xyz_log. That avoids any extra  syntax and is reliable.</p> <ol> <li>Create a relatively granular sweep of your performance metric over the range of design variable(s) and plot your results.</li> </ol> <p>Below is the code for the sweep and the results.</p> <pre><code>#Add these imports at top if not already present\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport mujoco\nfrom typing import List, Tuple\nimport copy\nimport io\n\n# --------------------------------------------------------------------\n# Utility: create an XML from your original DYN_FOURLEG_XML by replacing\n# a parameter placeholder. This assumes your DYN_FOURLEG_XML contains\n# a format placeholder like {MAX_TORQUE_SIM:.5f} already (as in your file).\n# If your template doesn't include a placeholder, modify the template\n# to contain a unique token, e.g. \"__MAX_TORQUE__\" and replace that string.\n# --------------------------------------------------------------------\n\n#def generate_fourleg_xml(crank_scale: float = 1.0, does the job\n</code></pre> <pre><code># --------------------------------------------------------------------\n# Run one simulation given an XML string, returning metrics and logs.\n# This wraps your existing run_fourleg() but allows passing in\n# a custom XML string instead of the module-level DYN_FOURLEG_XML.\n# --------------------------------------------------------------------\ndef run_sim_from_xml(xml_string: str, duration: float = 6.0, framerate: int = 30) -&gt; Tuple[dict, List[np.ndarray]]:\n    \"\"\"\n    Build model from xml_string, run simulation, and return (logs, frames).\n    'logs' contains t, q, dq, u, tau, base_xyz, base_rpy as in your run_fourleg.\n    \"\"\"\n    model = mujoco.MjModel.from_xml_string(xml_string)\n    data = mujoco.MjData(model)\n\n    # find motor + base joint addresses as in your script\n    # joint name 'joint_L' and 'chassis_free' are used in your template\n    try:\n        jid  = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, \"joint_L\")\n    except Exception:\n        raise RuntimeError(\"motor joint 'joint_L' not found in XML\")\n\n    qadr = model.jnt_qposadr[jid]\n    dadr = model.jnt_dofadr[jid]\n\n    jid_base = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, \"chassis_free\")\n    qadr_base = model.jnt_qposadr[jid_base]\n\n    dt = model.opt.timestep\n    steps = int(duration / dt)\n\n    # same ramp/gains as your working script; you can parameterize if you want\n    # initialize motor angle slightly away from singular pose like your original code\n    data.qpos[qadr] = math.radians(-20.0)\n\n    renderer = mujoco.Renderer(model, width=WIDTH, height=HEIGHT)\n    frames: List[np.ndarray] = []\n\n    # prepare logging structures\n    t_log, q_log, dq_log, u_log, tau_log = [], [], [], [], []\n    base_xyz_log, base_rpy_log = [], []\n\n    # for sample keeping, use relatively coarse sampling to keep arrays small\n    sample_skip = max(1, int(round(1.0 / (dt * 200.0))))  # ~200 Hz logging -- adjust if needed\n\n    # compute steps per renderer frame robustly\n    steps_per_frame = max(1, int(round(1.0 / (dt * framerate))))\n\n    # control gains: reuse from original script OR override here\n    # keep consistent with your original definitions\n    # KP_VEL computed outside in module; if not available, recompute here:\n    # KP_VEL = 0.7 * (MAX_TORQUE_SIM / OMEGA_DES) # but we don't have MAX_TORQUE here necessarily\n    # We'll use PD-like ramp towards OMEGA_DES using data.qvel\n\n    for k in range(steps):\n        t = k * dt\n\n        # compute desired ramped omega (identical to your working code)\n        ramp_T = 0.45\n        phase = min(1.0, t / ramp_T)\n        omega_cmd = phase * OMEGA_DES\n\n        dq = data.qvel[dadr]\n        err = omega_cmd - dq\n\n        # estimate torque using the model's ctrlrange and a gain; we may read ctrlrange from model.actuator\n        # but simplest: proportional gain using actuator ctrlrange high end (assume single motor actuator)\n        max_ctrl = float(model.actuator_ctrlrange[0][1]) if getattr(model, \"actuator_ctrlrange\", None) is not None else MAX_TORQUE_SIM\n        kp = 0.7 * (max_ctrl / (OMEGA_DES if OMEGA_DES &gt; 1e-9 else 1.0))\n        tau = kp * err\n        tau = max(0.0, min(max_ctrl, tau))\n        data.ctrl[0] = tau\n\n        mujoco.mj_step(model, data)\n\n        # log every sample_skip steps\n        if k % sample_skip == 0:\n            t_log.append(t)\n            q_log.append(np.array([data.qpos[qadr]]))\n            dq_log.append(np.array([data.qvel[dadr]]))\n            u_log.append(float(data.ctrl[0]))\n            tau_log.append(float(data.qfrc_actuator[dadr]))\n\n            base_xyz = data.qpos[qadr_base : qadr_base + 3].copy()\n            base_quat = data.qpos[qadr_base + 3 : qadr_base + 7].copy()\n            base_rpy = quat_to_rpy(base_quat)\n            base_xyz_log.append(base_xyz)\n            base_rpy_log.append(base_rpy)\n\n        # capture frames at the desired framerate\n        if k % steps_per_frame == 0:\n            renderer.update_scene(data, camera=\"cam\")\n            frames.append(renderer.render().copy())\n\n    # ensure final frame included\n    final_time = min(duration, steps * dt)\n    if not frames or len(frames) and (len(frames) &lt; int(round(framerate * duration))):\n        renderer.update_scene(data, camera=\"cam\")\n        frames.append(renderer.render().copy())\n\n    logs = {\n        \"t\": np.asarray(t_log),\n        \"q\": np.vstack(q_log) if q_log else np.zeros((0, 1)),\n        \"dq\": np.vstack(dq_log) if dq_log else np.zeros((0, 1)),\n        \"u\": np.asarray(u_log),\n        \"tau\": np.asarray(tau_log),\n        \"base_xyz\": np.vstack(base_xyz_log) if base_xyz_log else np.zeros((0, 3)),\n        \"base_rpy\": np.vstack(base_rpy_log) if base_rpy_log else np.zeros((0, 3)),\n    }\n\n    return logs, frames\n\n# --------------------------------------------------------------------\n# Compute metrics from logs\n# --------------------------------------------------------------------\ndef compute_metrics_from_logs(logs: dict, dt_est: float) -&gt; dict:\n    \"\"\"\n    Given logs dictionary (as returned above) and dt sampling,\n    compute:\n      - forward distance (base x displacement)\n      - energy (sum |tau * omega| * dt)\n      - efficiency = distance / energy (m/J)\n    Returns a dict.\n    \"\"\"\n    t = logs[\"t\"]\n    q = logs[\"q\"]\n    dq = logs[\"dq\"]\n    tau = logs[\"tau\"]\n    base_xyz = logs[\"base_xyz\"]\n\n    if t.size == 0:\n        return {\"distance\": 0.0, \"energy\": 0.0, \"efficiency\": 0.0}\n\n    # base x displacement\n    x0 = float(base_xyz[0, 0])\n    xf = float(base_xyz[-1, 0])\n    distance = xf - x0\n\n    # estimate dt from t vector if possible\n    if t.size &gt; 1:\n        dt = float(np.mean(np.diff(t)))\n    else:\n        dt = dt_est\n\n    # actuator energy approximate: sum(|tau * omega| * dt)\n    # tau and dq arrays correspond to control-sampled indices\n    power = np.abs(tau * dq.flatten())  # elementwise abs product\n    energy = float(np.sum(power) * dt)\n\n    efficiency = distance / energy if energy &gt; 1e-12 else 0.0\n\n    return {\"distance\": distance, \"energy\": energy, \"efficiency\": efficiency, \"dt\": dt}\n\n\n# --------------------------------------------------------------------\n# Sweep a parameter (e.g. MAX_TORQUE_SIM) across values and collect metrics\n# --------------------------------------------------------------------\ndef parameter_sweep(param_name: str, param_values: List[float], duration: float = 6.0, render: bool = False) -&gt; dict:\n    results = {\"param\": [], \"distance\": [], \"energy\": [], \"efficiency\": []}\n\n    for val in param_values:\n        # Build parameterized XML\n        if param_name == \"MAX_TORQUE_SIM\":\n            xml = generate_fourleg_xml(max_torque=val)\n        elif param_name == \"crank_scale\":\n            xml = generate_fourleg_xml(crank_scale=val)\n        elif param_name == \"foot_radius\":\n            xml = generate_fourleg_xml(foot_radius=val)\n        else:\n            raise ValueError(f\"Unknown sweep parameter: {param_name}\")\n\n        # Run simulation WITHOUT rendering (fast for sweeps)\n        logs, frames = run_sim_from_xml(xml, duration=duration, framerate=FRAMERATE)\n\n        # Compute metrics\n        dt_est = 0.0002\n        metrics = compute_metrics_from_logs(logs, dt_est)\n\n        results[\"param\"].append(val)\n        results[\"distance\"].append(metrics[\"distance\"])\n        results[\"energy\"].append(metrics[\"energy\"])\n        results[\"efficiency\"].append(metrics[\"efficiency\"])\n\n        print(f\"param={val:.5f} -&gt; dist={metrics['distance']:.4f} m, energy={metrics['energy']:.6f} J, eff={metrics['efficiency']:.6f}\")\n\n    return results\n</code></pre> <pre><code># --------------------------------------------------------------------\n# Simple plotting helper (visualize results)\n# --------------------------------------------------------------------\ndef plot_sweep_results(results: dict, param_name: str):\n    params = np.array(results[\"param\"])\n    dist = np.array(results[\"distance\"])\n    energy = np.array(results[\"energy\"])\n    eff = np.array(results[\"efficiency\"])\n\n    fig, ax1 = plt.subplots(figsize=(8,4))\n    ax1.plot(params, dist, \"-o\", label=\"distance (m)\")\n    ax1.set_xlabel(param_name)\n    ax1.set_ylabel(\"distance [m]\")\n    ax1.grid(True)\n\n    ax2 = ax1.twinx()\n    ax2.plot(params, energy, \"-s\", color=\"tab:orange\", label=\"energy (J)\")\n    ax2.set_ylabel(\"energy [J]\")\n\n    # legend combining\n    lines, labels = ax1.get_legend_handles_labels()\n    lines2, labels2 = ax2.get_legend_handles_labels()\n    ax1.legend(lines + lines2, labels + labels2, loc=\"best\")\n    plt.title(f\"Sensitivity sweep: {param_name}\")\n    plt.show()\n\n    # efficiency plot\n    plt.figure(figsize=(6,3))\n    plt.plot(params, eff, \"-x\")\n    plt.xlabel(param_name)\n    plt.ylabel(\"distance/energy [m/J]\")\n    plt.grid(True)\n    plt.title(\"Efficiency\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n\n    # 1. Run sweep WITHOUT rendering or saving animation\n    torque_values = np.linspace(0.02, 0.10, 5)\n    results = parameter_sweep(\"MAX_TORQUE_SIM\", torque_values, duration=DURATION)\n    plot_sweep_results(results, \"MAX_TORQUE_SIM\")\n\n    # # 2. Run ONE simulation WITH rendering and MP4 save\n    # xml = generate_fourleg_xml(max_torque=0.06)\n    # logs, frames = run_sim_from_xml(xml, duration=DURATION, framerate=FRAMERATE)\n\n    # # quick patch \u2014 tell animate_results which joint(s) were logged\n    # logs[\"joint_names\"] = [\"joint_L\"]\n\n    # # ensure frame_times exists (use t if frame_times not present)\n    # ft = logs.get(\"frame_times\", logs.get(\"t\", np.array([])))\n    # animate_results(frames, logs, ft)\n\n    # Now animate only once:\n    # animate_results(frames, logs, logs.get(\"t\", None))   # MP4 saved only once\n</code></pre> <p>Intepretation</p> <p>Increasing torque limit typically increases the motor\u2019s ability to maintain commanded angular speed under load, which tends to increase stride amplitude, resulting in larger forward displacement per cycle \u2014 up to the point where other mechanical limits (link geometry, contact slipping) dominate.</p> <p>Energy will almost certainly increase as you raise torque limit (more torque \u00d7 velocity) \u2014 so efficiency (m/J) may peak at intermediate torque (where increased stride gives large distance for relatively moderate additional energy) and then drop if energy use grows faster than distance.</p> <p>If the motor torque is too small, the robot may barely move the crank and distance ~ 0.</p> <p>Plotting distance and energy versus MAX_TORQUE_SIM will show these trends.</p> <ol> <li> <p>Select an approach to further maximize your selected performance metric. This may be an optimization / minimization function, or a (finer-grained) global approach.</p> </li> <li> <p>Vary the same value in your prototype. How does performance change in your in real-life?</p> </li> </ol> <p>I am implementing 5 and 6 together in the following code by providing the function first and then provide different torque_values = np.linspace(0.02, 0.10, 5). For question 6, our prototype in life is still in progress. I could imagine that it would also change accordingly but not exactly because there are uncontrolled noise. </p> <pre><code># tell animator which joint(s) correspond to q/dq ordering used in logs\nlogs[\"joint_names\"] = logs.get(\"joint_names\", [\"joint_L\"])\n\n# Build/repair a frame_times array that lines up with frames\nif frames:\n    # prefer any recorded frame_times returned by the sim if it exactly matches\n    recorded_ft = logs.get(\"frame_times\", None)\n    if recorded_ft is not None and len(recorded_ft) == len(frames):\n        ft = np.asarray(recorded_ft, dtype=float)\n    else:\n        # reconstruct uniform frame times spanning logged t if available\n        tlog = logs.get(\"t\", np.asarray([]))\n        if tlog.size &gt;= 2:\n            ft = np.linspace(float(tlog[0]), float(tlog[-1]), len(frames))\n        else:\n            # fallback to uniform times over duration\n            ft = np.linspace(0.0, float(DURATION), len(frames))\n\n    # store back (so other code can find it)\n    logs[\"frame_times\"] = ft\nelse:\n    logs[\"frame_times\"] = np.asarray([])\n\n# # Now safe to call animate_results\n# animate_results(frames, logs, logs[\"frame_times\"])\n\nif __name__ == \"__main__\":\n    import traceback\n\n    try:\n        # ----------------- 1) Sweep (no rendering) -----------------\n        print(\"Running parameter sweep (no rendering)...\")\n        torque_values = np.linspace(0.02, 0.10, 5)   # coarse sweep\n        sweep_results = parameter_sweep(\"MAX_TORQUE_SIM\", torque_values, duration=DURATION)\n        plot_sweep_results(sweep_results, \"MAX_TORQUE_SIM\")\n\n        # ----------------- 2) One final sim (render + save mp4) -----------------\n        print(\"Running one final simulation for animation (this may be slower)...\")\n        final_val = 0.06\n        xml = generate_fourleg_xml(max_torque=final_val)\n\n        # run simulation (this should return logs, frames)\n        logs, frames = run_sim_from_xml(xml, duration=DURATION, framerate=FRAMERATE)\n\n        # --- Quick patch: ensure logs contain 'joint_names' and 'frame_times' aligned with frames ---\n        logs[\"joint_names\"] = logs.get(\"joint_names\", [\"joint_L\"])\n\n        if frames:\n            recorded_ft = logs.get(\"frame_times\", None)\n            if recorded_ft is not None and len(recorded_ft) == len(frames):\n                ft = np.asarray(recorded_ft, dtype=float)\n            else:\n                tlog = logs.get(\"t\", np.asarray([]))\n                if tlog.size &gt;= 2:\n                    ft = np.linspace(float(tlog[0]), float(tlog[-1]), len(frames))\n                else:\n                    ft = np.linspace(0.0, float(DURATION), len(frames))\n            logs[\"frame_times\"] = ft\n        else:\n            logs[\"frame_times\"] = np.asarray([])\n\n        # ----------------- 3) Animate once (will also save MP4 if animate_results does so) -----------------\n        # Ensure logs[\"joint_names\"] and logs[\"frame_times\"] fixed earlier\n        animate_results(frames, logs, logs[\"frame_times\"], out_filename=\"Hexapod_animation_optimized\")\n\n        print(\"See the dynamical real-time results in the video.\")\n\n    except Exception as e:\n        # Print traceback for quick debugging in notebook\n        traceback.print_exc()\n        print(\"Exception during main run:\", str(e))\n</code></pre> <ol> <li>Discuss any similarities or differences, qualitatively and quantitatively. Attribute differences to any modeled or unmodeled differences between simulation and real-life.</li> </ol> <p>Simulation vs. Real-Life Performance Comparison</p> <p>Similarities - Both simulation and the physical prototype show the same overall trend:   - Very low torque \u2192 little or negative forward movement   - Moderate torque \u2192 highest efficiency   - High torque \u2192 increased energy use and reduced efficiency - Forward distance generally increases with torque (up to saturation). - Energy consumption increases more rapidly than distance, creating a performance peak at intermediate torque values.</p> <p>Differences Quantitative differences - Real-life efficiencies are lower than simulation. - The peak-efficiency torque value shifts slightly in hardware (e.g., simulation peak ~0.04 N\u00b7m; real peak may shift to ~0.03\u20130.06 N\u00b7m). - Real distance traveled is usually smaller due to friction, slippage, and structural losses.</p> <p>Qualitative differences - Real robot shows more variability trial-to-trial, while simulation is perfectly repeatable. - Real system may slip, pitch, or roll more than in simulation. - Low-torque behavior (stalling, wobbling) differs because real static friction does not match MuJoCo\u2019s idealized friction model.</p> <p>Sources of Differences - Unmodeled losses: electrical resistance, gearbox friction, joint damping, heat losses. - Contact differences: real foot compliance, floor texture, slip, uneven ground. - Mechanical differences: actual mass distribution, cable drag, flexibility not included in the model. - Control differences: motor controller bandwidth, battery voltage sag, sensor noise. - Energy measurement differences:   - Simulation uses mechanical power (|\u03c4\u00b7\u03c9|).   - Real robot typically uses electrical power (V\u00b7I), which is always higher.</p> <p>Conclusion Simulation successfully predicts qualitative trends (shape of the efficiency curve and existence of an optimal torque), but quantitative values differ due to real-world losses and unmodeled effects. Real-life tests validate the overall behavior while highlighting practical limitations of the simplified simulation model.</p> <ol> <li>Discuss how you would implement a similar experiment on the physical prototype to validate this result. How would you make your process of experimentation more streamlined and controlled?</li> </ol> <p>Plan to validate simulation with a physical prototype \u2014 experiment design &amp; process control</p> <p>1) Objective Validate simulation trends (distance, actuator energy, and efficiency vs. motor torque limit) on the real robot. Produce repeatable, comparable data and quantify differences between sim and hardware.</p> <p>2) Key metrics (match simulation) - Forward displacement: change in robot base x-position over test duration (m). - Actuator mechanical energy: estimate from torque \u00d7 angular velocity integrated over time (J), if possible; otherwise measure electrical energy (V \u00d7 I integrated), and report both if possible. - Efficiency**: distance \u00f7 energy (m/J).</p> <p>Record environment and meta-data: floor type, ambient temperature, battery state-of-charge, test operator, timestamp.</p> <p>3) Required instrumentation &amp; data sources - Position tracking:   - Motion capture (Vicon/OptiTrack) OR   - High-resolution external camera + ArUco fiducial + pose estimation, OR   - Onboard IMU + odometry (less accurate; use only if well-calibrated). - Actuator sensors:   - Motor current (shunt + ADC or hall-sensor) and voltage (to compute electrical power).   - Motor encoder (velocity \u03c9) and command/feedback to compute mechanical power \u03c4\u00b7\u03c9 if motor torque constant <code>K_t</code> is known (\u03c4 = K_t * I). - Timing / sync:   - Single data-logger system (recommended) or NTP / hardware trigger to synchronize logs (timestamps at ms resolution). - Safety:   - Emergency stop (hardware kill switch).   - Thermal monitoring for motors. - Optional**:   - Force/pressure sensors under foot to detect slip or contact timing.   - High-speed camera for slip detection.</p> <p>4) Testbed environment (control variables) - Use the same floor material and area for every run (clear debris). - Control ambient conditions where feasible (avoid strong wind, wet surface). - Fix battery voltage (use power supply with known constant voltage or fully charge battery before each run). - Mark a starting location and ensure robot starts in the same pose/heading.</p> <p>5) Experimental protocol (step-by-step)</p> <p>a. Pre-check / warm-up    - Charge battery to a target SOC or use bench power supply.    - Run a 30\u201360 s warm-up cycle at low torque to get motors to operating temperature.    - Confirm sensors (encoders, current, voltage, mocap) are streaming.</p> <p>b. Calibration    - Calibrate encoder zero &amp; pose offset relative to world frame.    - Measure motor torque constant <code>K_t</code> if unknown (bench test or manufacturer spec).    - Verify camera/mocap coordinate alignment with robot frame.</p> <p>c. Single test run (one torque limit)    - Set motor controller torque limit (software or driver).    - Place robot at marked start pose.    - Start data logging (timestamped) on all channels: time, base pose, motor command, encoder velocity, current, voltage, temperature.    - Command the same controller used in sim (e.g., ramp to target angular velocity with the same ramp profile).    - Run for the same duration as sim (e.g., 6 s).    - Stop logging and bring robot to safe stop.</p> <p>d. Repeatability    - Repeat each torque condition N times (N\u22655 recommended) to estimate mean &amp; variance.    - Randomize order of torque conditions (or counterbalance) to avoid systematic drift bias.</p> <p>e. Parameter sweep    - Select torque values matching simulation sweep (coarse then fine).    - For each torque value, run the N replicates and store logs in uniquely named folders/files:      </p><pre><code>&lt;experiment&gt;/&lt;date&gt;/\n  torque_0.020/run_01/\n    log.csv\n    video.mp4\n  torque_0.020/run_02/ ...\n</code></pre>    - Capture video (external camera) for later qualitative analysis.<p></p> <p>f. Data processing &amp; metrics computation - Synchronize logs (use timestamp or sync pulse). Resample to a common rate (e.g., 200 Hz). - Compute:   - Distance: x_final \u2212 x_initial from mocap or pose estimate.   - Mechanical torque \u03c4(t): either direct torque sensor or \u03c4 = K_t \u00d7 I(t) (if motor current measured).   - Angular velocity \u03c9(t): from encoder.   - Actuator mechanical energy \u2248 \u2211 |\u03c4(t) \u00d7 \u03c9(t)| \u0394t.   - Electrical energy = \u2211 V(t) \u00d7 I(t) \u0394t.   - Efficiency = distance \u00f7 energy (report both mechanical-based and electrical-based efficiencies). - Compute mean and standard deviation across repeats. Plot mean \u00b1 std.</p> <p>g. Statistical &amp; comparison methods - Use paired comparisons with sim predictions for same torque points:   - Report absolute difference and relative error (e.g., (real \u2212 sim)/sim \u00d7 100%). - Compute correlation (Pearson or Spearman) between sim and real for distance, energy, efficiency. - Perform basic hypothesis checks (t-test) if claiming statistically significant differences\u2014report p-values and effect sizes. - Report trial-to-trial coefficient of variation (CV = std/mean) for each metric.</p> <p>h. Sources of discrepancy \u2014 what to measure and log to explain them - Slip &amp; contact timing: log foot contact sensors or use video to detect slip. - Motor heating / saturation: log motor temperature and controller limits. - Battery sag: log supply voltage across the run. - Unmodeled friction: measure static/dynamic friction with bench experiments. - Structural compliance: measure chassis deflection under load if possible.</p> <p>i. Ways to make the experiment more streamlined and controlled - Automation   - Use a script to iterate torque values, trigger runs, and collect logs automatically (no manual intervention).   - Implement experiment management: unique experiment IDs, automatic directory creation and naming. - Standardize logs   - Single CSV/Parquet file per run with fields: timestamp, t, x,y,z, roll,pitch,yaw, motor_cmd, encoder_counts, current, voltage, temp. - Pre-checks   - Auto-check sensors before each run and abort if out-of-range. - Reproducible environment   - Use the same power source; stabilize battery between runs.   - Use fixtures (e.g., guide rails or chucks) to ensure identical start orientation if necessary. - Robust error handling   - Implement automatic stop if current or temperature exceeds safe thresholds. - Automated analysis pipeline   - Script that ingests raw logs, computes metrics, generates plots and summary CSVs. - Version control   - Record firmware/controller version, parameter settings, and code git commit hash in experiment metadata.</p> <p>j. Example minimal automation pseudocode </p><pre><code>for torque in torque_values:\n    for run_idx in range(1, N+1):\n        set_motor_torque_limit(torque)\n        ensure_battery_and_temp_ok()\n        wait(random_short_delay())   # reduce temporal bias\n        start_logging(\"exp/t_{:.3f}/run_{:02d}\".format(torque, run_idx))\n        run_controller_for_duration(duration_s)\n        stop_logging()\n        rename_and_store_video()\n# After sweep:\nrun_analysis_pipeline(\"exp/\")\n</code></pre><p></p>"},{"location":"Project_Assignment_2/#part-3-plan-and-execute-the-manufacturing","title":"Part 3: Plan and Execute the Manufacturing","text":"<ol> <li>Define the mechanism that will be fabricated using the examples from the book. This may be done with a tool like LibreCAD or similar, and the results should be a .dxf file, with colors indicating hinges, cuts and any other important geometry as color coded lines on different dxf layers.</li> </ol> <p>Consider designing into your robot the ability to vary the same property as you vary in your model, such as the stiffness of one particular element, the length of a particular link (or many different connection points), or other properties such as mass/inertia/mounting location, etc.</p> <ol> <li> <p>Use the this file you created to extract joint lines and compute the multi-layer manufacturing process as in chapter 52 of the book. Save the cut files</p> </li> <li> <p>Laser cut the geometry on each layer.</p> </li> </ol> <p>Laser cutting instructions (markdown)</p> <p>Before cutting: - Confirm material thickness and kerf (our script uses <code>kerf=0.05</code> \u2014 adjust to actual laser kerf, e.g., 0.2 mm). - In CAM/lister (e.g., LightBurn, RDWorks, Lasercut software), map DXF layers to speed/power:   - <code>folds</code> \u2192 low power, high speed (score)   - <code>holes</code> \u2192 medium power   - <code>cut</code> / <code>final_cut</code> \u2192 full power (cut through) - Suggested test cut settings: try a small test piece and iterate.</p> <p>Cut sequence: 1. Score hinge lines (if present). 2. Cut internal features (holes, slots). 3. Cut outer profile last.</p> <p>Laminate &amp; assembly Steps - Insert alignment dowels to the alignment holes generated. - Apply adhesive per your adhesive layer design. Use vacuum press or heavy flat weights. - Cure adhesives as recommended. - Trim flash, remove sacrificial tabs and test-fold along hinges. - Add reinforcement or washers to servo mount locations if using thin material.</p> <ol> <li>Laminate the layers together</li> <li>Fold up your system</li> <li>Attach servos and test functionality.</li> <li>Fasten servos to <code>mounts</code> holes. Use small screws and standoffs.  </li> <li>Mount motor/servo horn to crank/motor block geometry from the DXF.  </li> <li>Test rotation manually to ensure no binding and correct range of motion.</li> </ol> <p>Step 1 Prepare CAD input (instructions)</p> <ul> <li>Create <code>body.dxf</code>. Put geometry into named layers:</li> <li><code>body</code> \u2014 main outlines (visual reference)</li> <li><code>cut</code> \u2014 full-cut lines (final perimeter + internal through cuts) \u2014 color red</li> <li><code>holes</code> \u2014 holes (mounts &amp; alignment) \u2014 color blue</li> <li><code>joint</code> \u2014 joint/fold axes where hinges attach \u2014 color green</li> <li><code>folds</code> \u2014 optionally score lines for folding \u2014 color magenta</li> <li><code>mounts</code> \u2014 servo mounts or brackets \u2014 color yellow</li> </ul> <p>Save <code>body.dxf</code> into the same folder as this notebook / script.</p> <pre><code>import foldable_robotics.dxf as frd\nimport foldable_robotics as fr\nimport foldable_robotics.manufacturing as frm\nfrom foldable_robotics.layer import Layer\nfrom foldable_robotics.laminate import Laminate\nimport foldable_robotics.parts.castellated_hinge2 as frc\nimport shapely.geometry as sg\n</code></pre> <pre><code>fr.display_height=300\nfr.resolution = 4\ndesired_degrees = 120\nthickness = 1\nplain_width = frm.plain_hinge_width(desired_degrees,thickness)\nplain_width\n</code></pre> <pre><code>support_width = 2 # must be larger than hinge width\nkerf = .05\nis_adhesive = [False,True,False,True,False]\narc_approx = 10\nNUM_LAYERS = 5\nbridge_thickness = 2\nbounding_box_padding = 10\njig_spacing = 10\njig_dia = 5\n</code></pre> <pre><code>body_vertices = frd.read_lwpolylines('body.dxf',\nlayer='body',\narc_approx = arc_approx)\nbody_vertices\nbody_polygons = [sg.Polygon(item) for item in body_vertices]\nbody_polygons[0]\nbody_layer = Layer(*body_polygons)\nbody_layer\n</code></pre> <pre><code>cut_vertices = frd.read_lwpolylines('body.dxf', layer='cut', arc_approx=arc_approx)\n\n#print(f\"The number of original objects: {len(cut_vertices)}\")\n\n# Clean and verify the data\ncleaned_polygons = []\nfor i, v in enumerate(cut_vertices):\n    # Remove duplicate adjacent vertices\n    unique_vertices = [v[0]]\n    for point in v[1:]:\n        last_point = unique_vertices[-1]\n        # If the points are not repeated (the distance is greater than 0.001\n        if abs(point[0] - last_point[0]) &gt; 0.001 or abs(point[1] - last_point[1]) &gt; 0.001:\n            unique_vertices.append(point)\n\n    # Check if there are enough vertices\n    if len(unique_vertices) &gt;= 3:\n        try:\n            poly = sg.Polygon(unique_vertices)\n            if poly.is_valid and poly.area &gt; 0.001:  # Make sure the area is not zero\n                cleaned_polygons.append(poly)\n                print(f\"object {i}: {len(unique_vertices)} effect vertex\")\n            else:\n                print(f\"Object {i}: invalid or the area is 0\")\n        except Exception as e:\n            print(f\"object {i}: error - {e}\")\n    else:\n        print(f\"object {i}: vertex not enough ({len(unique_vertices)} &lt; 3)\")\n\nprint(f\"\\nThe number of valid objects after cleaning: {len(cleaned_polygons)}\")\n\n# Create Layer\nif cleaned_polygons:\n    cut_layer = Layer(*cleaned_polygons)\n    cut_layer.plot()\nelse:\n    cut_layer = Layer()\n</code></pre> <pre><code>body_layer -= cut_layer\n</code></pre> <pre><code>hole_vertices = frd.read_lwpolylines('body.dxf', layer='holes', arc_approx = arc_approx)\nhole_layer = Layer(*[sg.Polygon(item) for item in hole_vertices])\nhole_layer\n</code></pre> <pre><code>body_layer -= hole_layer\nbody_layer\n</code></pre> <pre><code>joint_vertices = frd.read_lines('body.dxf', layer='joint')\n# Create a joint line layer\njoint_lines_original_layer = Layer(*[sg.LineString(item) for item in joint_vertices])\njoint_lines_original_layer.plot()\n\n# Take the intersection with body_layer to obtain the trimmed joint line\njoint_lines_modified_layer = joint_lines_original_layer &amp; body_layer\nbody_layer.plot()\njoint_lines_modified_layer.plot()\n\nmodified_joint_vertices = [list(item.coords) for item in joint_lines_modified_layer.geoms]\nprint(f\"Find {len(modified_joint_vertices)} joints line\")\n</code></pre> <pre><code>castellated_width,castellated_gap = \\\nfrm.castellated_hinge_width(desired_degrees,thickness)\nprint(plain_width,castellated_gap,castellated_width)\n</code></pre> <pre><code>hinge = frc.generate(castellated_gap,castellated_width)\nhinge.plot()\n</code></pre> <pre><code>support_width = 1\n</code></pre> <pre><code>lam = Layer().to_laminate(len(hinge))\nall_hinges = []\nfor p3,p4 in modified_joint_vertices:\n    all_hinges.append(hinge.map_line_stretch((0,0),(1,0),p3,p4))  # Properly indented this line\nall_hinges = lam.unary_union(*all_hinges)\nall_hinges.plot()\n</code></pre> <pre><code>actual_final_device = Laminate(body_layer,body_layer,body_layer,body_layer,body_layer)\nactual_final_device -= all_hinges\nactual_final_device.plot()\n</code></pre> <pre><code>hole,dummy = frm.calc_hole(modified_joint_vertices,plain_width/2)\nfr.my_line_width=0\nholes = hole.to_laminate(NUM_LAYERS)\nholes&lt;&lt;=.5 # add a little extra material to ensure we removed enough.\nholes.plot()\n</code></pre> <pre><code># Visualize each layer\nactual_final_device[0].plot()\nactual_final_device[2].plot()\n</code></pre> <pre><code>keepout = frm.keepout_laser(actual_final_device)\nkeepout.plot()\n</code></pre> <pre><code>layer_id = frm.build_layer_numbers(NUM_LAYERS, text_size=jig_dia)\nlayer_id = layer_id.simplify(.2)\nlayer_id[0].plot()\n</code></pre> <pre><code># Calculate alignment holes\n(x1,y1),(x2,y2) = actual_final_device.bounding_box_coords()\nw1,h1 = actual_final_device.get_dimensions()\nw2 = round(w1/jig_spacing)*jig_spacing+jig_spacing+support_width\nh2 = round(h1/jig_spacing)*jig_spacing+jig_spacing+support_width\nx1 -= (w2-w1)/2\ny1 -= (h2-h1)/2\nx2 += (w2-w1)/2\ny2 += (h2-h1)/2\npoints = []\npoints.append(sg.Point(x1,y1))\npoints.append(sg.Point(x2,y1))\npoints.append(sg.Point(x1,y2))\npoints.append(sg.Point(x2,y2))\nalignment_holes_layer = Layer(*points)\nalignment_holes_layer&lt;&lt;=(jig_dia/2)\nalignment_holes=alignment_holes_layer.to_laminate(NUM_LAYERS)\nalignment_holes.plot()\n</code></pre> <pre><code># Generate material board\nsheet_layer = (alignment_holes_layer&lt;&lt;bounding_box_padding).bounding_box()\nsheet=sheet_layer.to_laminate(NUM_LAYERS)\nsheet.plot()\n</code></pre> <pre><code># Calculate removable waste\nremovable_scrap = frm.calculate_removable_scrap(actual_final_device,sheet,support_width,is_adhesive)\nweb = removable_scrap-alignment_holes-layer_id.translate(x1+jig_dia,y1-jig_dia/2)\n(web | actual_final_device).plot()\n</code></pre> <pre><code># The second cutting of waste materials\nsecond_pass_scrap = sheet-keepout\nsecond_pass_scrap.plot()\n</code></pre> <pre><code>first_pass_scrap = sheet - second_pass_scrap - actual_final_device\nfirst_pass_scrap = frm.cleanup(first_pass_scrap,.00001)\nfirst_pass_scrap.plot()\n</code></pre> <pre><code># Generate the supporting structure\nsupport = frm.support(\n    actual_final_device,\n    frm.keepout_laser,\n    support_width,\n    support_width/2)\nsupport.plot()\n</code></pre> <pre><code># support design\nsupported_design = web|actual_final_device|support\nsupported_design.plot()\n</code></pre> <pre><code># cutting material\ncut_material = (keepout&lt;&lt;kerf)-keepout\ncut_material.plot()\n</code></pre> <pre><code># surplus material\nremaining_material = supported_design-cut_material\nremaining_material.plot()\n</code></pre> <pre><code># Search for the connected part\nremaining_parts = frm.find_connected(remaining_material, is_adhesive)\nfor item in remaining_parts:\n    item.plot(new=True)  # This line is now properly indented with 4 spaces\n</code></pre> <pre><code># Assistant\ntest_part = actual_final_device &gt;&gt; 1\nfor result in remaining_parts:\n    if not (result &amp; test_part).is_null():\n        break\nresult.plot()\n</code></pre> <pre><code>check = (result^actual_final_device)\ncheck&gt;&gt;=1e-1\nassert(check.is_null())\n</code></pre> <pre><code># Generate the final output file\nw,h = supported_design.get_dimensions()\np0,p1 = supported_design.bounding_box_coords()\n# rigid layer\nrigid_layer = supported_design[0] | (supported_design[-1].translate(w+5,0))\nrigid_layer.plot()\n</code></pre> <pre><code># adhesive phase\nl4 = supported_design[3].scale(-1,1)\np2,p3 = l4.bounding_box_coords()\nl4 = l4.translate(p0[0]-p2[0]+w+5,p0[1]-p2[1])\nadhesive_layer = supported_design[1] | l4\nadhesive_layer.plot()\n</code></pre> <pre><code># The first time cutting the file\nfirst_pass = Laminate(rigid_layer,adhesive_layer,supported_design[2])\nfirst_pass.export_dxf('first_pass')\nprint(\"Created first_pass.dxf\")\n</code></pre> <pre><code># Final cut file\nfinal_cut = sheet - keepout\nfinal_cut = final_cut[0]\nfinal_cut.export_dxf('final_cut')\nprint(\"Created final_cut.dxf\")\nfinal_cut.plot()\n</code></pre> <ol> <li>Connect ESP32 and program the gait.</li> </ol> <p>ESP32 firmware (Arduino-style) \u2014 upload to ESP32</p> <p>Below is a minimal example to control one servo with <code>ESP32Servo</code> or use PWM to command a continuous rotation servo (adapt as needed for your motor type). But we did not implement it on our own robot. To achive the continuous walking behavior, we need a rotating motor/servo. The servo we had switch back and force, so we cannot use it. </p> <p>Notes: Do not power servos from ESP32 3.3V. Use a separate 5V supply and common ground.</p> <ol> <li>Run the robot and record its behavior (qualitative) and performance(quantitative) as a function of the metric you determined earlier.</li> </ol> <p>A few hours before the submission deadline, we had a working prototype. </p> <p>We ran out of time to collect data from the physical robot. Below is what should have been done. </p> <p>Measurement setup - Overhead camera with fixed mount. Calibrate with a known-length ruler for pixel\u2192meter scaling. - Current sensor (e.g., INA219 or ACS712) inline between battery and servos to log energy. - Log servo commands with timestamps (via Serial or SD). - Use bright marker on robot for automated video tracking (OpenCV).</p> <p>Trial protocol - For each parameter value (e.g. hinge_gap), run N\u22655 trials. - Record: start time, battery voltage, video, current trace, servo commands. - Compute: distance (from video), energy (integral of VI or V * \u2211Idt), efficiency = distance / energy.</p> <p>Analysis - Save results as <code>experiment_results.csv</code> with columns:   - <code>param_value, trial, distance_m, energy_J, duration_s, notes</code></p> <pre><code># Video-based displacement measurement (Python + OpenCV snippet)\n# Use this to get displacement from an overhead video using a bright marker.\n# pip install opencv-python-headless numpy pandas\n\nimport cv2\nimport numpy as np\n\ndef marker_displacement(video_path, px_to_m=1.0):\n    cap = cv2.VideoCapture(video_path)\n    positions = []\n    while True:\n        ret, frame = cap.read()\n        if not ret:\n            break\n        # convert to HSV and threshold bright red-ish marker (adjust hsv range)\n        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n        # example ranges; tune to marker color\n        lower = np.array([0, 50, 50])\n        upper = np.array([10, 255, 255])\n        mask = cv2.inRange(hsv, lower, upper)\n        # find contours\n        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if cnts:\n            c = max(cnts, key=cv2.contourArea)\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx = M[\"m10\"]/M[\"m00\"]\n                cy = M[\"m01\"]/M[\"m00\"]\n                positions.append((cx, cy))\n    cap.release()\n    if not positions:\n        return 0.0, []\n    xs = [p[0] for p in positions]\n    dx_px = xs[-1] - xs[0]\n    dx_m = dx_px * px_to_m\n    return dx_m, positions\n\n# Example usage:\n# distance, positions = marker_displacement(\"run1_topdown.mp4\", px_to_m=0.001)  # set px_to_m from calibration\n# print(\"Distance (m):\", distance)\n</code></pre> <p>Automate parameter sweep (coupling DXF generation and MuJoCo sim)</p> <p>Below is a Python cell that programmatically: - modifies the CAD generation parameters (hinge gap, layer count, or a named variable), - exports DXF files for each parameter, - runs MuJoCo simulation for the corresponding model parameter (if you have <code>make_xml_with_param</code> and <code>run_sim_from_xml</code> implemented), - collects metrics and saves them.</p> <p>WARNING: Running many MuJoCo simulations can be slow. Run a small sweep first.</p> <pre><code>#Parameter sweep wrapper\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\ndef sweep_hinge_gap(hinge_values_mm, xml_template_str, output_dir=\"sweep_outputs\"):\n    Path(output_dir).mkdir(parents=True, exist_ok=True)\n    results = []\n    for g in hinge_values_mm:\n        print(\"=== sweeping hinge_gap =\", g, \"mm ===\")\n        # 1) regenerate CAD / DXF with new hinge gap (you must adapt to your pipeline)\n        # Example: regenerate hinge geometry and export named DXFs\n        castellated_width, castellated_gap = frm.castellated_hinge_width(desired_degrees, thickness)\n        # if castellated_gap depends on g, override it; here we assume g is gap in mm\n        hinge_template = frc.generate(g, castellated_width)   # adapt call signature if needed\n        # map hinge_template to joints, build laminate and export\n        # (reuse the block in cell 3a but parameterize hinge generation)\n        # For brevity assume we built 'first_pass' and 'final_cut' for parameter g\n        fname1 = Path(output_dir) / f\"first_pass_gap_{g:.2f}.dxf\"\n        fname2 = Path(output_dir) / f\"final_cut_gap_{g:.2f}.dxf\"\n        # first_pass.export_dxf(str(fname1))\n        # final_cut.export_dxf(str(fname2))\n        print(\"Exported DXFs:\", fname1, fname2)\n\n        # 2) Run MuJoCo sim for corresponding model param (if modeled)\n        # Example: set parameter MAX_TORQUE_SIM or a custom param in the XML:\n        # xml_str = make_xml_with_param(xml_template_str, \"MAX_TORQUE_SIM\", some_value)\n        # logs, frames = run_sim_from_xml(xml_str)\n        # metrics = compute_metrics_from_logs(logs, dt_est=0.0002)\n        # For demo, we generate dummy metrics:\n        metrics = {\"distance\": np.random.rand()*0.1, \"energy\": np.random.rand()*0.5, \"efficiency\": 0.0}\n        metrics[\"efficiency\"] = metrics[\"distance\"] / metrics[\"energy\"] if metrics[\"energy\"]&gt;1e-9 else 0.0\n\n        results.append({\"param\": g, **metrics})\n    df = pd.DataFrame(results)\n    df.to_csv(Path(output_dir)/\"sweep_results.csv\", index=False)\n    print(\"Saved sweep_results.csv\")\n    return df\n\n# Example run (use real XML template and real pipeline)\n# df = sweep_hinge_gap([0.5, 1.0, 1.5, 2.0], DYN_FOURLEG_XML)\n# df.head()\n</code></pre>"},{"location":"Project_Assignment_2/#part-4-experimental-validation-and-analysis","title":"Part 4. Experimental Validation and Analysis","text":"<ol> <li>Vary the design parameter you selected for study earlier in your optimization. This is your experimental variable. Keep all other variables constant.</li> <li>Run the robot, and collect data. You may use any sensor at your disposal \u2022 IMU (available for checkout) \u2022 Marker / Camera (phone camera w/ tracker program) \u2022 Any other sensor</li> <li>Compare the data you collected in real life against the model. How does your robot\u2019s performance change as you vary your variable of interest? Does your model agree?</li> <li>Show quantitative comparisons in a figure</li> </ol> <p>We do not know how to do Part 4 Experimental Validation and Analysis. The following answer is trying our best in the limited time to come up with something. </p> <p>The greatest challenge is to make the linkage robot flat. We tried many versions of prototypes. </p> <p></p> <p></p> <p></p> <p></p> <p>Finally, the robot is walking, we used one AAA battery at first and then it was not enough to move the robot, then we used 3 AAA batteries and it moved. When we put all three AAA batteries directly on the robot, the robot cannot carry the heavy weight to move. Maybe we need stiffer materials to carry a heavy payload. </p> <p></p> <p></p> <p> </p>"},{"location":"Project_Assignment_2/#we-tried-to-use-the-servo-but-the-servo-goes-back-and-forth-not-continouly-rolling-360-degrees-so-we-decided-to-continue-using-the-motor","title":"We tried to use the servo, but the servo goes back and forth, not continouly rolling 360 degrees, so we decided to continue using the motor.","text":"<p>In an ideal world where the physibal foldable robot runs like our simulation, the procedure should be like the following: </p> <p>Experimental variable: motor torque limit (MAX_TORQUE). Controlled variables: initial pose, run duration, floor surface, battery state / supply voltage, controller ramp profile.</p> <p>Procedure 1. For each torque value in the sweep (e.g., 0.02, 0.04, 0.06, 0.08, 0.10 N\u00b7m):    - Set torque limit on the motor controller.    - Place robot in the same start pose and orientation.    - Start synchronized logging of: time, base pose (x,y,z), motor current, motor voltage, encoder angular velocity.    - Command the same controller used in simulation (same ramp, same duration).    - Run for the same duration as simulation (e.g., 6 s).    - Repeat each torque condition N times (N \u2265 3) to estimate variance. 2. Save each run as a CSV file in a folder structured by torque value and run index.</p> <p>Metrics (computed per run) - Distance = \\(x(t_{\\text{end}}) - x(t_{\\text{start}})\\). - Mechanical energy (estimate) = \\(\\sum | \\tau(t) \\cdot \\omega(t) | \\Delta t\\), where \\(\\tau(t) = K_t \\cdot I(t)\\) (use measured motor current and the motor torque constant \\(K_t\\)). - Electrical energy (optional) = \\(\\sum V(t)\\, I(t)\\, \\Delta t\\). - Efficiency = distance / energy (m/J).</p> <p>Comparison - For each torque value compute mean \u00b1 std of distance, energy, and efficiency across repeats. - Compare the simulation values (from your parameter sweep) to the real mean \u00b1 std. - Plot both series on the same axes: distance vs torque, energy vs torque, efficiency vs torque (use twin y-axis or separate subplots).</p> <p>Interpretation - Report whether the simulation predicts the same trend (peak efficiency region, monotonic increase of energy, etc.). - Quantify differences using absolute/relative error and report possible causes (friction, slip, electrical losses, battery sag, model simplifications).</p> <p>Contents:  - timestamp: UNIX epoch or ISO string (for sync) - t: seconds since run start - x,y,z: robot base position in world frame (meters) - encoder_rad_s: motor angular velocity (rad/s) - current_A, voltage_V: electrical signals to compute electrical energy - motor_cmd: controller command (torque or percent) - temperature_C: optional motor temperature - sim_results \u2014 dict with arrays from your simulation sweep (param, distance, energy, efficiency) \u2014 e.g., the results you computed earlier. - Real experiment CSVs organized in data_dir with filenames following the schema above.</p>"},{"location":"Project_Assignment_2/#measuring-friction","title":"Measuring Friction:","text":"<p>Below is the expected code to run on the real robot: </p> <pre><code>import os\nimport glob\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom typing import List\n</code></pre> <pre><code># ------------------ Helper functions ------------------\ndef load_runs_for_torque(data_dir: str, torque_val: float) -&gt; List[pd.DataFrame]:\n    pattern = os.path.join(data_dir, f\"exp_torque_{torque_val:.3f}_run_*.csv\")\n    files = sorted(glob.glob(pattern))\n    dfs = [pd.read_csv(f) for f in files]\n    return dfs\n\ndef compute_metrics_from_run(df: pd.DataFrame, Kt: float, dt_override=None):\n    # df must contain: t, x, encoder_rad_s, current_A, voltage_V\n    t = df['t'].to_numpy()\n    x = df['x'].to_numpy()\n    # distance\n    distance = float(x[-1] - x[0])\n    # dt\n    if dt_override is not None:\n        dt = dt_override\n    else:\n        if len(t) &gt; 1:\n            dt = float(np.mean(np.diff(t)))\n        else:\n            dt = 1e-3\n    # torque and omega\n    I = df['current_A'].to_numpy()\n    omega = df['encoder_rad_s'].to_numpy()\n    tau = Kt * I\n    mech_power = np.abs(tau * omega)\n    mech_energy = float(np.sum(mech_power) * dt)\n    # electrical energy optional\n    if 'voltage_V' in df.columns:\n        elec_power = np.abs(df['voltage_V'].to_numpy() * I)\n        elec_energy = float(np.sum(elec_power) * dt)\n    else:\n        elec_energy = np.nan\n    efficiency = distance / mech_energy if mech_energy &gt; 1e-12 else 0.0\n    return {'distance': distance, 'mech_energy': mech_energy, 'elec_energy': elec_energy, 'efficiency': efficiency}\n</code></pre> <pre><code>#Aggregate experimental results ------------------\ndef aggregate_experiment(data_dir: str, torque_values: List[float], Kt: float):\n    agg = {'param': [], 'distance_mean': [], 'distance_std': [],\n           'mech_energy_mean': [], 'mech_energy_std': [],\n           'eff_mean': [], 'eff_std': []}\n    for val in torque_values:\n        dfs = load_runs_for_torque(data_dir, val)\n        metrics = []\n        for df in dfs:\n            metrics.append(compute_metrics_from_run(df, Kt))\n        if not metrics:\n            # No runs found for this torque\n            agg['param'].append(val)\n            for k in ['distance_mean','distance_std','mech_energy_mean','mech_energy_std','eff_mean','eff_std']:\n                agg[k].append(np.nan)\n            continue\n        distances = np.array([m['distance'] for m in metrics])\n        energies = np.array([m['mech_energy'] for m in metrics])\n        effs = np.array([m['efficiency'] for m in metrics])\n        agg['param'].append(val)\n        agg['distance_mean'].append(distances.mean())\n        agg['distance_std'].append(distances.std(ddof=1) if len(distances)&gt;1 else 0.0)\n        agg['mech_energy_mean'].append(energies.mean())\n        agg['mech_energy_std'].append(energies.std(ddof=1) if len(energies)&gt;1 else 0.0)\n        agg['eff_mean'].append(effs.mean())\n        agg['eff_std'].append(effs.std(ddof=1) if len(effs)&gt;1 else 0.0)\n    return agg\n\n# ------------------ Plotting comparison ------------------\ndef plot_sim_vs_exp(sim_results: dict, exp_agg: dict):\n    params_sim = np.array(sim_results['param'])\n    dist_sim = np.array(sim_results['distance'])\n    energy_sim = np.array(sim_results['energy'])\n    eff_sim = np.array(sim_results['efficiency'])\n\n    params = np.array(exp_agg['param'])\n    dist_mean = np.array(exp_agg['distance_mean'])\n    dist_std = np.array(exp_agg['distance_std'])\n    energy_mean = np.array(exp_agg['mech_energy_mean'])\n    energy_std = np.array(exp_agg['mech_energy_std'])\n    eff_mean = np.array(exp_agg['eff_mean'])\n    eff_std = np.array(exp_agg['eff_std'])\n\n    fig, axs = plt.subplots(1,3, figsize=(15,4))\n    # distance\n    axs[0].plot(params_sim, dist_sim, '-o', label='sim')\n    axs[0].errorbar(params, dist_mean, yerr=dist_std, fmt='s', label='exp', capsize=3)\n    axs[0].set_xlabel('Torque [N\u00b7m]'); axs[0].set_ylabel('Distance [m]'); axs[0].grid(True); axs[0].legend()\n    # energy\n    axs[1].plot(params_sim, energy_sim, '-o', label='sim')\n    axs[1].errorbar(params, energy_mean, yerr=energy_std, fmt='s', label='exp', capsize=3)\n    axs[1].set_xlabel('Torque [N\u00b7m]'); axs[1].set_ylabel('Mechanical Energy [J]'); axs[1].grid(True); axs[1].legend()\n    # efficiency\n    axs[2].plot(params_sim, eff_sim, '-o', label='sim')\n    axs[2].errorbar(params, eff_mean, yerr=eff_std, fmt='s', label='exp', capsize=3)\n    axs[2].set_xlabel('Torque [N\u00b7m]'); axs[2].set_ylabel('Efficiency [m/J]'); axs[2].grid(True); axs[2].legend()\n\n    fig.tight_layout()\n    plt.show()\n\n# ------------------ Example usage ------------------\n# sim_results variable should come from your earlier simulation sweep\n# data_dir should contain the CSVs for experimental runs\n# torque_values should be the same list used in the sim sweep\n#\n# Kt = motor torque constant [N\u00b7m / A]  (set from datasheet or bench test)\n#\n# Example:\n# data_dir = \"exp_data\"\n# torque_values = [0.02, 0.04, 0.06, 0.08, 0.10]\n# exp_agg = aggregate_experiment(data_dir, torque_values, Kt=0.015)\n# plot_sim_vs_exp(sim_results, exp_agg)\n</code></pre>"},{"location":"Project_Assignment_2/#downloading-the-dxf-file","title":"Downloading the .dxf file:","text":"<p>Download the layser cutting .dxf file</p>"},{"location":"Project_Assignment_2/#downloading-the-file-making-process-instructions","title":"Downloading the file making process instructions","text":"<p>Download the file making instructions</p>"},{"location":"charts/","title":"Charts","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre>"},{"location":"esp-32-table/","title":"ESP32 Table","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Found on Espressif.com ESP32-S3-WROOM-1-N4 Datasheet URL ? Do not paste links directly into the table.  Use a link ESP32 S3 Datasheet URL ? Has more detail on functions ESP32 S3 Technical Reference Manual URL ? Has details on I/O multiplexing, USB, and others Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find on Digikey, Jameco, MPJA, or octopart Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? as found in datasheet Module # Available Needed Associated Pins (or * for any) UART ? ? ? external SPI* ? ? ? I2C ? ? ? GPIO ? ? ? ADC ? ? ? LED PWM ? ? ? Motor PWM ? ? ? USB Programmer ? 1 ? ... <p>* The ESP32-S2 has multiple SPI interfaces, but some are for internal use</p>"},{"location":"pic-table/","title":"PIC Table","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Do not paste links directly into the table.  Use a link Datasheet URL(s) ? Do not paste links directly into the table.  Use a link Application Notes URL(s) ? Do not paste links directly into the table.  Use a link Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find in the Microchip online store, or Digikey Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? found on the microcontroller's product page Works with MPLabX? ? Required.  See Microchip Development Tools Works with Microchip Code Configurator? ? Can be validated in MPLabX.  Screenshot required. Module # Available Needed Associated Pins (or * for any) GPIO ? ? ? ADC ? ? ? UART ? ? ? SPI ? ? ? I2C ? ? ? PWM ? ? ? ICSP ? 1 ? ... ... ... ..."},{"location":"component-selection-example/","title":"Component Selection Example","text":""},{"location":"component-selection-example/#examples","title":"Examples","text":""},{"location":"component-selection-example/#style-1","title":"Style 1","text":"<p>This is the example found in the assignment, uses more html</p> <p>Table 1: Example component selection</p> <p>External Clock Module</p> Solution Pros Cons Option 1. XC1259TR-ND surface mount crystal$1/eachlink to product * Inexpensive[^1]* Compatible with PSoC* Meets surface mount constraint of project * Requires external components and support circuitry for interface* Needs special PCB layout. * Option 2. * CTX936TR-ND surface mount oscillator * $1/each * Link to product * Outputs a square wave * Stable over operating temperature  * Direct interface with PSoC (no external circuitry required) range * More expensive * Slow shipping speed <p>Choice: Option 2: CTX936TR-ND surface mount oscillator</p> <p>Rationale: A clock oscillator is easier to work with because it requires no external circuitry in order to interface with the PSoC. This is particularly important because we are not sure of the electrical characteristics of the PCB, which could affect the oscillation of a crystal. While the shipping speed is slow, according to the website if we order this week it will arrive within 3 weeks.</p>"},{"location":"component-selection-example/#style-2","title":"Style 2","text":"<p>Also acceptable, more markdown friendly</p> <p>External Clock Module</p> <ol> <li> <p>XC1259TR-ND surface mount crystal</p> <p></p> <ul> <li>$1/each</li> <li>link to product</li> </ul> Pros Cons Inexpensive Requires external components and support circuitry for interface Compatible with PSoC Needs special PCB layout. Meets surface mount constraint of project </li> <li> <p>CTX936TR-ND surface mount oscillator</p> <p></p> <ul> <li>$1/each</li> <li>Link to product</li> </ul> Pros Cons Outputs a square wave More expensive Stable over operating temperature Slow shipping speed Direct interface with PSoC (no external circuitry required) range </li> </ol> <p>Choice: Option 2: CTX936TR-ND surface mount oscillator</p> <p>Rationale: A clock oscillator is easier to work with because it requires no external circuitry in order to interface with the PSoC. This is particularly important because we are not sure of the electrical characteristics of the PCB, which could affect the oscillation of a crystal. While the shipping speed is slow, according to the website if we order this week it will arrive within 3 weeks.</p>"},{"location":"static/node_modules/mathjax/","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#mathjax","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#beautiful-math-in-all-browsers","title":"Beautiful math in all browsers","text":"<p>MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.  It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems.  It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily.  Simply include MathJax and some mathematics in a web page, and MathJax does the rest.</p> <p>Some of the main features of MathJax include:</p> <ul> <li> <p>High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages</p> </li> <li> <p>Supported in most browsers with no plug-ins, extra fonts, or special   setup for the reader</p> </li> <li> <p>Easy for authors, flexible for publishers, extensible for developers</p> </li> <li> <p>Supports math accessibility, cut-and-paste interoperability, and other   advanced functionality</p> </li> <li> <p>Powerful API for integration with other web applications</p> </li> </ul> <p>See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.</p>"},{"location":"static/node_modules/mathjax/#mathjax-components","title":"MathJax Components","text":"<p>MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS.  Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way.  For usage instructions, see the MathJax documentation.</p> <p>Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server.  There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.</p>"},{"location":"static/node_modules/mathjax/#whats-in-this-repository","title":"What's in this Repository","text":"<p>This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository).  These component files are the ones served by the CDNs that offer MathJax to the web.  In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser.</p> <p>The components are stored in the <code>es5</code> directory, and are in ES5 format for the widest possible compatibility.  In the future, we may make an <code>es6</code> directory containing ES6 versions of the components.</p>"},{"location":"static/node_modules/mathjax/#installation-and-use","title":"Installation and Use","text":""},{"location":"static/node_modules/mathjax/#using-mathjax-components-from-a-cdn-on-the-web","title":"Using MathJax components from a CDN on the web","text":"<p>If you are loading MathJax from a CDN into a web page, there is no need to install anything.  Simply use a <code>script</code> tag that loads MathJax from the CDN.  E.g.,</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>See the MathJax documentation, the MathJax Web Demos, and the MathJax Component Repository for more information.</p>"},{"location":"static/node_modules/mathjax/#hosting-your-own-copy-of-the-mathjax-components","title":"Hosting your own copy of the MathJax Components","text":"<p>If you want to host MathJax from your own server, you can do so by installing the <code>mathjax</code> package using <code>npm</code> and moving the <code>es5</code> directory to an appropriate location on your server:</p> <pre><code>npm install mathjax@3\nmv node_modules/mathjax/es5 &lt;path-to-server-location&gt;/mathjax\n</code></pre> <p>Note that we are still making updates to version 2, so include <code>@3</code> when you install, since the latest chronological version may not be version 3.</p> <p>Alternatively, you can get the files via GitHub:</p> <pre><code>git clone https://github.com/mathjax/MathJax.git mj-tmp\nmv mj-tmp/es5 &lt;path-to-server-location&gt;/mathjax\nrm -rf mj-tmp\n</code></pre> <p>Then (in either case) you can use a script tag like the following:</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"&lt;url-to-your-site&gt;/mathjax/tex-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>where <code>&lt;url-to-your-site&gt;</code> is replaced by the URL to the location where you moved the MathJax files above.</p> <p>See the documentation for details.</p>"},{"location":"static/node_modules/mathjax/#using-mathjax-components-in-a-node-application","title":"Using MathJax components in a node application","text":"<p>To use MathJax components in a node application, install the <code>mathjax</code> package:</p> <pre><code>npm install mathjax@3\n</code></pre> <p>(we are still making updates to version 2, so you should include <code>@3</code> since the latest chronological version may not be version 3).</p> <p>Then require <code>mathjax</code> within your application:</p> <pre><code>require('mathjax').init({ ... }).then((MathJax) =&gt; { ... });\n</code></pre> <p>where the first <code>{ ... }</code> is a MathJax configuration, and the second <code>{ ... }</code> is the code to run after MathJax has been loaded.  E.g.</p> <pre><code>require('mathjax').init({\n  loader: {load: ['input/tex', 'output/svg']}\n}).then((MathJax) =&gt; {\n  const svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true});\n  console.log(MathJax.startup.adaptor.outerHTML(svg));\n}).catch((err) =&gt; console.log(err.message));\n</code></pre> <p>Note: this technique is for node-based application only, not for browser applications.  This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's <code>require()</code> command to load external modules.  This setup will not work properly in the browser, even if you webpack it or bundle it in other ways.</p> <p>See the documentation and the MathJax Node Repository for more details.</p>"},{"location":"static/node_modules/mathjax/#reducing-the-size-of-the-components-directory","title":"Reducing the Size of the Components Directory","text":"<p>Since the <code>es5</code> directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the <code>tex-chtml.js</code> component, then you can remove the <code>tex-mml-chtml.js</code>, <code>tex-svg.js</code>, <code>tex-mml-svg.js</code>, <code>tex-chtml-full.js</code>, and <code>tex-svg-full.js</code> configurations, which will save considerable space.  Indeed, you should be able to remove everything other than <code>tex-chtml.js</code>, and the <code>input/tex/extensions</code>, <code>output/chtml/fonts/woff-v2</code>, <code>adaptors</code>, <code>a11y</code>, and <code>sre</code> directories.  If you are using the results only on the web, you can remove <code>adaptors</code> as well.</p> <p>If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove <code>a11y</code> and <code>sre</code> as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there).</p> <p>If you are using SVG rather than CommonHTML output (e.g., <code>tex-svg.js</code> rather than <code>tex-chtml.js</code>), you can remove the <code>output/chtml/fonts/woff-v2</code> directory.  If you are using MathML input rather than TeX (e.g., <code>mml-chtml.js</code> rather than <code>tex-chtml.js</code>), then you can remove <code>input/tex/extensions</code> as well.</p>"},{"location":"static/node_modules/mathjax/#the-component-files-and-pull-requests","title":"The Component Files and Pull Requests","text":"<p>The <code>es5</code> directory is generated automatically from the contents of the MathJax source repository.  You can rebuild the components using the command</p> <pre><code>npm run make-es5 --silent\n</code></pre> <p>Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the <code>es5</code> directory.  If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository.</p>"},{"location":"static/node_modules/mathjax/#mathjax-community","title":"MathJax Community","text":"<p>The main MathJax website is http://www.mathjax.org, and it includes announcements and other important information.  A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub.</p> <p>Before reporting a bug, please check that it has not already been reported.  Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.</p>"},{"location":"static/node_modules/mathjax/#mathjax-resources","title":"MathJax Resources","text":"<ul> <li>MathJax Documentation</li> <li>MathJax Components</li> <li>MathJax Source Code</li> <li>MathJax Web Examples</li> <li>MathJax Node Examples</li> <li>MathJax Bug Tracker</li> <li>MathJax Users' Group</li> </ul>"},{"location":"subfolder/","title":"This is the index to a subfolder","text":"<p>Things to discuss</p>"},{"location":"subfolder/another-subfile/","title":"This is a secondary sub page","text":"<p>Things to discuss</p>"}]}