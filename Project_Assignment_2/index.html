<!DOCTYPE html><html lang="en" class="no-js"><head>
    

<meta name="robots" content="nofollow">


      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://lhuan111.github.io/Project_Assignment_2/">
      
      
        <link rel="prev" href="..">
      
      
      
      <link rel="icon" href="../static/FRlogo2.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.18">
            

        

    
      
        <title>Assignment 2 - RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    


  <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"><script src="../assets/javascripts/glightbox.min.js"></script><style id="glightbox-style">
            html.glightbox-open { overflow: initial; height: 100%; }
            .gslide-title { margin-top: 0px; user-select: text; }
            .gslide-desc { color: #666; user-select: text; }
            .gslide-image img { background: white; }
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color); }
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color); }
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color); }
        </style></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#project-assignment-2-design-build-and-simulate-your-robot" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot" class="md-header__button md-logo" aria-label="RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot" data-md-component="logo">
      
  <img src="../static/FRlogo2.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Assignment 2
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"></path></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://lhuan111.github.io" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
  </div>
  <div class="md-source__repository">
    Lhuan111
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
    
  
  Assignment 1

      </a>
    </li>
  

      
        
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="./" class="md-tabs__link">
        
  
    
  
  Assignment 2

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot" class="md-nav__button md-logo" aria-label="RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot" data-md-component="logo">
      
  <img src="../static/FRlogo2.png" alt="logo">

    </a>
    RAS557 Foldable Robotics Project Website: Klann-Style Hexpod Robot
  </label>
  
    <div class="md-nav__source">
      <a href="https://lhuan111.github.io" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
  </div>
  <div class="md-source__repository">
    Lhuan111
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Assignment 1
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Assignment 2
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Assignment 2
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#students-shuai-gao-lixiao-huang-yibo-yuan" class="md-nav__link">
    <span class="md-ellipsis">
      Students: Shuai Gao, Lixiao Huang, Yibo Yuan
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#instructor-daniel-aukes-fall-2025" class="md-nav__link">
    <span class="md-ellipsis">
      Instructor: Daniel Aukes (Fall 2025)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#part-1-define-the-system-model" class="md-nav__link">
    <span class="md-ellipsis">
      Part 1: Define the System Model
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#students-shuai-gao-lixiao-huang-yibo-yuan" class="md-nav__link">
    <span class="md-ellipsis">
      Students: Shuai Gao, Lixiao Huang, Yibo Yuan
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#instructor-daniel-aukes-fall-2025" class="md-nav__link">
    <span class="md-ellipsis">
      Instructor: Daniel Aukes (Fall 2025)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#part-1-define-the-system-model" class="md-nav__link">
    <span class="md-ellipsis">
      Part 1: Define the System Model
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://lhuan111.github.io/edit/main/docs/Project_Assignment_2.md" title="Edit this page" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"></path></svg>
    </a>
  
  


<h1 id="project-assignment-2-design-build-and-simulate-your-robot">Project Assignment 2: Design, Build and Simulate your Robot</h1>
<h4 id="students-shuai-gao-lixiao-huang-yibo-yuan">Students: Shuai Gao, Lixiao Huang, Yibo Yuan</h4>
<h4 id="instructor-daniel-aukes-fall-2025">Instructor: Daniel Aukes (Fall 2025)</h4>
<p><strong>The purpose of this assignment is to model, optimize, build, and validate your final robot.</strong></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/21Ap_L2Syjo" title="Simulation" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/k89TbkdRb_I" title="Dynamical Data" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/GtDq5xMh6zY" title="Physical Robot" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>

<h2 id="part-1-define-the-system-model">Part 1: Define the System Model</h2>
<p>Produce a final dynamic model in Mujoco that adapts the ideal kinematics of your initial robot model to your ȴnal geometry, material properties (joint stiffness and beam stiffness), and actuator characteristics. Ensure your model includes some aspect of material compliance / flexibility and motor behavior somewhere in your system, and that you have made it possible to vary at least one design parameter of interest and re-run the simulation in a function, for the purposes of wrapping this function in an optimization process. Plot expected performance of the model over a broad range of possible values, in a way that will be correlated to a real-life experiment.</p>
<p>The following codes carry out the simulation and plots. </p>
<div class="highlight"><pre><span></span><code>from __future__ import annotations
import math
from typing import List

import numpy as np
import mujoco
import mediapy as media
import matplotlib.pyplot as plt

#this package is for animation of data
import matplotlib.animation as animation

import shutil

import shutil, os # this is to solve the mediapy.show_video failure
</code></pre></div>
<p>The functions of the blocks are described on the first row: </p>
<div class="highlight"><pre><span></span><code># ---------------- Global viz params ----------------
WIDTH, HEIGHT = 1024, 576
FRAMERATE = 30
DURATION = 6
SHOW_VIDEO = True
SAVE_ANIMATION = True  # set True to save mp4 (requires ffmpeg)

# ---------------- Geometry (inches -&gt; meters) ----------------
INCH_TO_M = 0.0254

LENGTH_CORR = 0.01 / INCH_TO_M  

FOOT_RADIUS = 0.006   # slimmer feet
Z_OFFSET    = FOOT_RADIUS

# ========= 2D plan view geometry in INCHES at theta = 0 =========
# Shared M and B
M_2D = np.array([0.0, 0.0])
B_2D = np.array([1.0, 0.0])

# Back leg on each side (D_left)
D1_2D = np.array([-2.1, 0.0])
A1_2D = np.array([-5.2, 0.0])
C1_2D = np.array([-2.1, 2.833725])
E1_2D = np.array([-3.65, 1.416863])
F1_2D = np.array([-0.55, 1.416863])

# Front leg on each side (D_right)
D2_2D = np.array([2.1, 0.0])
A2_2D = np.array([3.2, 0.0])
C2_2D = np.array([2.1, 4.053394])
E2_2D = np.array([2.65, 2.026697])
F2_2D = np.array([1.55, 2.026697])
</code></pre></div>
<div class="highlight"><pre><span></span><code>def inch2m_xz(p_inch: np.ndarray) -&gt; np.ndarray:
    """Convert [x,z]_inch in drawing plane -&gt; [x,z]_meter with ground offset."""
    x_m = p_inch[0] * INCH_TO_M
    z_m = p_inch[1] * INCH_TO_M + Z_OFFSET
    return np.array([x_m, z_m])

# Convert to meters (x,z)
M = inch2m_xz(M_2D)
B = inch2m_xz(B_2D)

D1 = inch2m_xz(D1_2D)
A1 = inch2m_xz(A1_2D)
C1 = inch2m_xz(C1_2D)
E1 = inch2m_xz(E1_2D)
F1 = inch2m_xz(F1_2D)

D2 = inch2m_xz(D2_2D)
A2 = inch2m_xz(A2_2D)
C2 = inch2m_xz(C2_2D)
E2 = inch2m_xz(E2_2D)
F2 = inch2m_xz(F2_2D)

# Shared crank vector (in x–z)
MB_vec = B - M

#The following is the 3D geometry block:
# Back leg relative vectors
BC1_vec = C1 - B
AC1_vec = A1 - C1
E1_rel_from_C = E1 - C1
F1_rel_from_B = F1 - B
D1_rel = np.array([D1[0] - M[0], 0.0, D1[1] - M[1]])
DE1_vec = np.array([E1[0] - D1[0], 0.0, E1[1] - D1[1]])
DF1_vec = np.array([F1[0] - D1[0], 0.0, F1[1] - D1[1]])

# Front leg relative vectors
BC2_vec = C2 - B
AC2_vec = A2 - C2
E2_rel_from_C = E2 - C2
F2_rel_from_B = F2 - B
D2_rel = np.array([D2[0] - M[0], 0.0, D2[1] - M[1]])
DE2_vec = np.array([E2[0] - D2[0], 0.0, E2[1] - D2[1]])
DF2_vec = np.array([F2[0] - D2[0], 0.0, F2[1] - D2[1]])

# 3D versions (x, y, z); y is lateral
M_rel = np.zeros(3)
B_rel = np.array([MB_vec[0], 0.0, MB_vec[1]])   # M -&gt; B

C1_rel_from_B = np.array([BC1_vec[0], 0.0, BC1_vec[1]])
A1_rel_from_C = np.array([AC1_vec[0], 0.0, AC1_vec[1]])
E1_rel_from_C_3d = np.array([E1_rel_from_C[0], 0.0, E1_rel_from_C[1]])
F1_rel_from_B_3d = np.array([F1_rel_from_B[0], 0.0, F1_rel_from_B[1]])

C2_rel_from_B = np.array([BC2_vec[0], 0.0, BC2_vec[1]])
A2_rel_from_C = np.array([AC2_vec[0], 0.0, AC2_vec[1]])
E2_rel_from_C_3d = np.array([E2_rel_from_C[0], 0.0, E2_rel_from_C[1]])
F2_rel_from_B_3d = np.array([F2_rel_from_B[0], 0.0, F2_rel_from_B[1]])

Y_OFF = 0.03   # lateral offset for left/right sides

# ---------------- mass / density assumptions ----------------
DENS_LEG  = 350.0   # kg/m^3, black &amp; green bars
DENS_FOOT = 500.0   # kg/m^3
MASS_BASE = 0.010   # chassis box [kg]
MASS_MOTOR = 0.067  # motor block [kg]

# ---------------- motor specs ----------------
MAX_TORQUE_REAL = 0.07845           # 800 gf·cm in N·m
MAX_TORQUE_SIM  = 1 * MAX_TORQUE_REAL

# Slightly faster target RPM
RPM_3V   = 100.0
OMEGA_DES = RPM_3V / 60.0 * 2.0 * math.pi   # rad/s target speed

# Stronger gain but still not full
KP_VEL   = 0.7 * (MAX_TORQUE_SIM / OMEGA_DES)
</code></pre></div>
<div class="highlight"><pre><span></span><code># ----------------------------------------------------------------------
#  Helper: quaternion -&gt; roll, pitch, yaw
# ----------------------------------------------------------------------
def quat_to_rpy(q: np.ndarray) -&gt; np.ndarray:
    """Convert [w, x, y, z] quaternion -&gt; [roll, pitch, yaw] (rad), ZYX."""
    w, x, y, z = q
    # roll (x)
    sinr_cosp = 2.0 * (w * x + y * z)
    cosr_cosp = 1.0 - 2.0 * (x * x + y * y)
    roll = math.atan2(sinr_cosp, cosr_cosp)
    # pitch (y)
    sinp = 2.0 * (w * y - z * x)
    if abs(sinp) &gt;= 1.0:
        pitch = math.copysign(math.pi / 2.0, sinp)
    else:
        pitch = math.asin(sinp)
    # yaw (z)
    siny_cosp = 2.0 * (w * z + x * y)
    cosy_cosp = 1.0 - 2.0 * (y * y + z * z)
    yaw = math.atan2(siny_cosp, cosy_cosp)
    return np.array([roll, pitch, yaw])
</code></pre></div>
<div class="highlight"><pre><span></span><code># ======================================================================
# INSERTED: XML generator for parameter sweeps
# ======================================================================

def generate_fourleg_xml(crank_scale: float = 1.0,
                         max_torque: float | None = None,
                         foot_radius: float | None = None) -&gt; str:
    """
    Generate the MuJoCo XML string using the geometry and constants already
    defined in this module (MB_vec, M_rel, B_rel, DENS_LEG, etc.).
    Place this function after those definitions.
    """
    MB_scaled = np.array([MB_vec[0], MB_vec[1]]) * float(crank_scale)
    mt = float(MAX_TORQUE_SIM if max_torque is None else max_torque)
    fr = float(FOOT_RADIUS if foot_radius is None else foot_radius)

# ---------------- MuJoCo XML: 4 legs, 6 feet, 1 motor ---------------- 
    xml = f"""
&lt;mujoco model="fourbar_fourlegs"&gt;
  &lt;option timestep="0.0002" gravity="0 0 -9.81"&gt;
    &lt;flag contact="enable"/&gt;
  &lt;/option&gt;

  &lt;visual&gt;
    &lt;global offwidth="{WIDTH}" offheight="{HEIGHT}"/&gt;
  &lt;/visual&gt;

  &lt;worldbody&gt;

    &lt;!-- ground --&gt;
    &lt;geom name="floor" type="plane" pos="0 0 0"
          size="2 2 0.02"
          friction="0.5 0.005 0.0005"
          contype="1" conaffinity="0"
          rgba="0.4 0.4 0.4 1"/&gt;

    &lt;!-- light and camera --&gt;
    &lt;light name="top" pos="0 0 1" dir="0 0 -1"
           diffuse="1 1 1" specular="0.2 0.2 0.2"/&gt;

    &lt;camera name="cam" mode="fixed"
            pos="0 -0.5 0.10"
            axisangle="1 0 0 90"/&gt;

    &lt;!-- CHASSIS at M, centered between left/right legs (y=0) --&gt;
    &lt;body name="chassis" pos="{M[0]:.5f} 0 {M[1]:.5f}"&gt;
      &lt;joint name="chassis_free" type="free"/&gt;

      &lt;!-- base + motor block (smaller) --&gt;
      &lt;geom name="chassis_base" type="box" size="0.007 0.007 0.0045"
            mass="{MASS_BASE:.4f}" rgba="0.6 0.6 0.6 1"/&gt;
      &lt;geom name="motor_block" type="box" size="0.009 0.006 0.015"
            mass="{MASS_MOTOR:.4f}" pos="0 0 0.03"
            rgba="1 1 0.3 1"/&gt;

      &lt;!-- ========== D anchors (fixed on chassis) ========== --&gt;

      &lt;!-- Left-back D1_L --&gt;
      &lt;body name="D1_L_body" pos="{D1_rel[0]:.5f} {-Y_OFF:.5f} {D1_rel[2]:.5f}"&gt;
        &lt;geom name="D1_L_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.3 0.8 0.1 1"/&gt;
        &lt;site name="D1_L_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE1_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE1_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE1_L_bar" type="capsule"
                fromto="0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE1_L_end_site"
                pos="{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF1_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF1_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF1_L_bar" type="capsule"
                fromto="0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF1_L_end_site"
                pos="{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- Left-front D2_L --&gt;
      &lt;body name="D2_L_body" pos="{D2_rel[0]:.5f} {-Y_OFF:.5f} {D2_rel[2]:.5f}"&gt;
        &lt;geom name="D2_L_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.3 0.8 0.6 1"/&gt;
        &lt;site name="D2_L_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE2_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE2_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE2_L_bar" type="capsule"
                fromto="0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE2_L_end_site"
                pos="{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF2_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF2_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF2_L_bar" type="capsule"
                fromto="0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF2_L_end_site"
                pos="{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- Right-back D1_R --&gt;
      &lt;body name="D1_R_body" pos="{D1_rel[0]:.5f} {Y_OFF:.5f} {D1_rel[2]:.5f}"&gt;
        &lt;geom name="D1_R_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.1 0.6 0.9 1"/&gt;
        &lt;site name="D1_R_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE1_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE1_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE1_R_bar" type="capsule"
                fromto="0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE1_R_end_site"
                pos="{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF1_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF1_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF1_R_bar" type="capsule"
                fromto="0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF1_R_end_site"
                pos="{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- Right-front D2_R --&gt;
      &lt;body name="D2_R_body" pos="{D2_rel[0]:.5f} {Y_OFF:.5f} {D2_rel[2]:.5f}"&gt;
        &lt;geom name="D2_R_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.3 0.6 0.9 1"/&gt;
        &lt;site name="D2_R_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE2_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE2_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE2_R_bar" type="capsule"
                fromto="0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE2_R_end_site"
                pos="{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF2_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF2_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF2_R_bar" type="capsule"
                fromto="0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF2_R_end_site"
                pos="{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- ========== SINGLE crank root (ONE motor driving both MBs) ========== --&gt;
      &lt;body name="crank_root" pos="{M_rel[0]:.5f} 0 {M_rel[2]:.5f}"&gt;
        &lt;!-- single joint, single motor --&gt;
        &lt;joint name="joint_L" type="hinge"
               axis="0 1 0" range="-720 720" damping="0.01"/&gt;

        &lt;!-- ===== LEFT side: B_L ===== --&gt;
        &lt;body name="B_L_body" pos="{B_rel[0]:.5f} {-Y_OFF:.5f} {B_rel[2]:.5f}"&gt;
          &lt;!-- rod from B_L back to M --&gt;
          &lt;geom name="MB_L_bar" type="capsule"
                fromto="0 0 0   {-MB_scaled[0]:.5f} 0 {-MB_scaled[1]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0028"
                rgba="0.1 0.1 0.1 1"/&gt;

          &lt;geom name="B_L_foot" type="sphere"
                pos="0 0 0"
                size="{fr:.4f}"
                density="{DENS_FOOT:.1f}"
                friction="0.5 0.005 0.0005"
                contype="0" conaffinity="1"
                rgba="0.8 0.2 0.2 1"/&gt;

          &lt;!-- back left leg --&gt;
          &lt;body name="BC1_L_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC1_L" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC1_L_bar" type="capsule"
                  fromto="0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F1_L_site"
                  pos="{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C1_L_body"
                  pos="{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C1_L_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC1_L_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA1_L" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC1_L_bar" type="capsule"
                      fromto="0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E1_L_site"
                      pos="{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A1_L_body"
                      pos="{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A1_L_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.8 0.2 0.2 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;

          &lt;!-- front left leg --&gt;
          &lt;body name="BC2_L_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC2_L" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC2_L_bar" type="capsule"
                  fromto="0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F2_L_site"
                  pos="{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C2_L_body"
                  pos="{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C2_L_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC2_L_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA2_L" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC2_L_bar" type="capsule"
                      fromto="0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E2_L_site"
                      pos="{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A2_L_body"
                      pos="{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A2_L_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.8 0.2 0.2 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;
        &lt;/body&gt;

        &lt;!-- ===== RIGHT side: B_R, 180° around shaft ===== --&gt;
        &lt;body name="B_R_body"
              pos="{-B_rel[0]:.5f} {Y_OFF:.5f} {-B_rel[2]:.5f}"&gt;
          &lt;!-- rod from B_R back to M (opposite direction) --&gt;
          &lt;geom name="MB_R_bar" type="capsule"
                fromto="0 0 0   {MB_scaled[0]:.5f} 0 {MB_scaled[1]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0028"
                rgba="0.1 0.1 0.1 1"/&gt;

          &lt;geom name="B_R_foot" type="sphere"
                pos="0 0 0"
                size="{FOOT_RADIUS:.4f}"
                density="{DENS_FOOT:.1f}"
                friction="0.5 0.005 0.0005"
                contype="0" conaffinity="1"
                rgba="0.2 0.8 0.4 1"/&gt;

          &lt;!-- back right leg --&gt;
          &lt;body name="BC1_R_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC1_R" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC1_R_bar" type="capsule"
                  fromto="0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F1_R_site"
                  pos="{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C1_R_body"
                  pos="{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C1_R_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC1_R_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA1_R" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC1_R_bar" type="capsule"
                      fromto="0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E1_R_site"
                      pos="{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A1_R_body"
                      pos="{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A1_R_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.2 0.8 0.4 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;

          &lt;!-- front right leg --&gt;
          &lt;body name="BC2_R_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC2_R" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC2_R_bar" type="capsule"
                  fromto="0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F2_R_site"
                  pos="{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C2_R_body"
                  pos="{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C2_R_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC2_R_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA2_R" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC2_R_bar" type="capsule"
                      fromto="0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E2_R_site"
                      pos="{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A2_R_body"
                      pos="{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A2_R_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.2 0.8 0.4 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;
        &lt;/body&gt;
      &lt;/body&gt;

    &lt;/body&gt; &lt;!-- end chassis --&gt;

  &lt;/worldbody&gt;

  &lt;!-- 4-bar equality constraints (DE/DF only) --&gt;
  &lt;equality&gt;
    &lt;!-- Left-back leg --&gt;
    &lt;connect name="DE1_L_eq"
             site1="DE1_L_end_site" site2="E1_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF1_L_eq"
             site1="DF1_L_end_site" site2="F1_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;

    &lt;!-- Left-front leg --&gt;
    &lt;connect name="DE2_L_eq"
             site1="DE2_L_end_site" site2="E2_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF2_L_eq"
             site1="DF2_L_end_site" site2="F2_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;

    &lt;!-- Right-back leg --&gt;
    &lt;connect name="DE1_R_eq"
             site1="DE1_R_end_site" site2="E1_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF1_R_eq"
             site1="DF1_R_end_site" site2="F1_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;

    &lt;!-- Right-front leg --&gt;
    &lt;connect name="DE2_R_eq"
             site1="DE2_R_end_site" site2="E2_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF2_R_eq"
             site1="DF2_R_end_site" site2="F2_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
  &lt;/equality&gt;

  &lt;actuator&gt;
    &lt;!-- one motor, one joint, positive torque only --&gt;
    &lt;motor name="hip_motor" joint="joint_L"
           gear="1.0" ctrlrange="0 {mt:.5f}"/&gt;
  &lt;/actuator&gt;

&lt;/mujoco&gt;
"""
    return xml
</code></pre></div>
<div class="highlight"><pre><span></span><code># MuJoCo XML: 4 legs, 6 feet, 1 motor

DYN_FOURLEG_XML = f"""
&lt;mujoco model="fourbar_fourlegs"&gt;
  &lt;option timestep="0.0002" gravity="0 0 -9.81"&gt;
    &lt;flag contact="enable"/&gt;
  &lt;/option&gt;

  &lt;visual&gt;
    &lt;global offwidth="{WIDTH}" offheight="{HEIGHT}"/&gt;
  &lt;/visual&gt;

  &lt;worldbody&gt;

      &lt;!-- ground --&gt;
    &lt;geom name="floor" type="plane" pos="0 0 0"
          size="2 2 0.02"
          friction="0.5 0.005 0.0005"
          contype="1" conaffinity="0"
          rgba="0.4 0.4 0.4 1"/&gt;

    &lt;!-- light and camera --&gt;
    &lt;light name="top" pos="0 0 1" dir="0 0 -1"
           diffuse="1 1 1" specular="0.2 0.2 0.2"/&gt;

    &lt;camera name="cam" mode="fixed"
            pos="0 -0.5 0.10"
            axisangle="1 0 0 90"/&gt;

    &lt;!-- CHASSIS at M, centered between left/right legs (y=0) --&gt;
    &lt;body name="chassis" pos="{M[0]:.5f} 0 {M[1]:.5f}"&gt;
      &lt;joint name="chassis_free" type="free"/&gt;

      &lt;!-- base + motor block (smaller) --&gt;
      &lt;geom name="chassis_base" type="box" size="0.007 0.007 0.0045"
            mass="{MASS_BASE:.4f}" rgba="0.6 0.6 0.6 1"/&gt;
      &lt;geom name="motor_block" type="box" size="0.009 0.006 0.015"
            mass="{MASS_MOTOR:.4f}" pos="0 0 0.03"
            rgba="1 1 0.3 1"/&gt;

      &lt;!-- ========== D anchors (fixed on chassis) ========== --&gt;

      &lt;!-- Left-back D1_L --&gt;
      &lt;body name="D1_L_body" pos="{D1_rel[0]:.5f} {-Y_OFF:.5f} {D1_rel[2]:.5f}"&gt;
        &lt;geom name="D1_L_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.3 0.8 0.1 1"/&gt;
        &lt;site name="D1_L_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE1_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE1_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE1_L_bar" type="capsule"
                fromto="0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE1_L_end_site"
                pos="{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF1_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF1_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF1_L_bar" type="capsule"
                fromto="0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF1_L_end_site"
                pos="{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- Left-front D2_L --&gt;
      &lt;body name="D2_L_body" pos="{D2_rel[0]:.5f} {-Y_OFF:.5f} {D2_rel[2]:.5f}"&gt;
        &lt;geom name="D2_L_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.3 0.8 0.6 1"/&gt;
        &lt;site name="D2_L_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE2_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE2_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE2_L_bar" type="capsule"
                fromto="0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE2_L_end_site"
                pos="{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF2_L_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF2_L" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF2_L_bar" type="capsule"
                fromto="0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF2_L_end_site"
                pos="{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- Right-back D1_R --&gt;
      &lt;body name="D1_R_body" pos="{D1_rel[0]:.5f} {Y_OFF:.5f} {D1_rel[2]:.5f}"&gt;
        &lt;geom name="D1_R_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.1 0.6 0.9 1"/&gt;
        &lt;site name="D1_R_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE1_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE1_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE1_R_bar" type="capsule"
                fromto="0 0 0   {DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE1_R_end_site"
                pos="{DE1_vec[0]:.5f} 0 {DE1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF1_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF1_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF1_R_bar" type="capsule"
                fromto="0 0 0   {DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF1_R_end_site"
                pos="{DF1_vec[0]:.5f} 0 {DF1_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- Right-front D2_R --&gt;
      &lt;body name="D2_R_body" pos="{D2_rel[0]:.5f} {Y_OFF:.5f} {D2_rel[2]:.5f}"&gt;
        &lt;geom name="D2_R_marker" type="sphere" size="0.0018"
              density="1000" rgba="0.3 0.6 0.9 1"/&gt;
        &lt;site name="D2_R_site" pos="0 0 0" size="0.001" rgba="0 0 0 0"/&gt;

        &lt;body name="DE2_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DE2_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DE2_R_bar" type="capsule"
                fromto="0 0 0   {DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DE2_R_end_site"
                pos="{DE2_vec[0]:.5f} 0 {DE2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;

        &lt;body name="DF2_R_body" pos="0 0 0"&gt;
          &lt;joint name="joint_DF2_R" type="hinge"
                 axis="0 1 0" damping="0.001"/&gt;
          &lt;geom name="DF2_R_bar" type="capsule"
                fromto="0 0 0   {DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0022"
                contype="0" conaffinity="0"
                rgba="0.0 0.7 0.0 1"/&gt;
          &lt;site name="DF2_R_end_site"
                pos="{DF2_vec[0]:.5f} 0 {DF2_vec[2]:.5f}"
                size="0.001" rgba="0 0 0 0"/&gt;
        &lt;/body&gt;
      &lt;/body&gt;

      &lt;!-- ========== SINGLE crank root (ONE motor driving both MBs) ========== --&gt;
      &lt;body name="crank_root" pos="{M_rel[0]:.5f} 0 {M_rel[2]:.5f}"&gt;
        &lt;!-- single joint, single motor --&gt;
        &lt;joint name="joint_L" type="hinge"
               axis="0 1 0" range="-720 720" damping="0.01"/&gt;

        &lt;!-- ===== LEFT side: B_L ===== --&gt;
        &lt;body name="B_L_body" pos="{B_rel[0]:.5f} {-Y_OFF:.5f} {B_rel[2]:.5f}"&gt;
          &lt;!-- rod from B_L back to M --&gt;
          &lt;geom name="MB_L_bar" type="capsule"
                fromto="0 0 0   {-MB_vec[0]:.5f} 0 {-MB_vec[1]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0028"
                rgba="0.1 0.1 0.1 1"/&gt;

          &lt;geom name="B_L_foot" type="sphere"
                pos="0 0 0"
                size="{FOOT_RADIUS:.4f}"
                density="{DENS_FOOT:.1f}"
                friction="0.5 0.005 0.0005"
                contype="0" conaffinity="1"
                rgba="0.8 0.2 0.2 1"/&gt;

          &lt;!-- back left leg --&gt;
          &lt;body name="BC1_L_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC1_L" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC1_L_bar" type="capsule"
                  fromto="0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F1_L_site"
                  pos="{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C1_L_body"
                  pos="{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C1_L_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC1_L_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA1_L" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC1_L_bar" type="capsule"
                      fromto="0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E1_L_site"
                      pos="{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A1_L_body"
                      pos="{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A1_L_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.8 0.2 0.2 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;

          &lt;!-- front left leg --&gt;
          &lt;body name="BC2_L_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC2_L" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC2_L_bar" type="capsule"
                  fromto="0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F2_L_site"
                  pos="{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C2_L_body"
                  pos="{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C2_L_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC2_L_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA2_L" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC2_L_bar" type="capsule"
                      fromto="0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E2_L_site"
                      pos="{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A2_L_body"
                      pos="{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A2_L_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.8 0.2 0.2 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;
        &lt;/body&gt;

        &lt;!-- ===== RIGHT side: B_R, 180° around shaft ===== --&gt;
        &lt;body name="B_R_body"
              pos="{-B_rel[0]:.5f} {Y_OFF:.5f} {-B_rel[2]:.5f}"&gt;
          &lt;!-- rod from B_R back to M (opposite direction) --&gt;
          &lt;geom name="MB_R_bar" type="capsule"
                fromto="0 0 0   {MB_vec[0]:.5f} 0 {MB_vec[1]:.5f}"
                density="{DENS_LEG:.1f}" size="0.0028"
                rgba="0.1 0.1 0.1 1"/&gt;

          &lt;geom name="B_R_foot" type="sphere"
                pos="0 0 0"
                size="{FOOT_RADIUS:.4f}"
                density="{DENS_FOOT:.1f}"
                friction="0.5 0.005 0.0005"
                contype="0" conaffinity="1"
                rgba="0.2 0.8 0.4 1"/&gt;

          &lt;!-- back right leg --&gt;
          &lt;body name="BC1_R_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC1_R" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC1_R_bar" type="capsule"
                  fromto="0 0 0   {C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F1_R_site"
                  pos="{F1_rel_from_B_3d[0]:.5f} 0 {F1_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C1_R_body"
                  pos="{C1_rel_from_B[0]:.5f} 0 {C1_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C1_R_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC1_R_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA1_R" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC1_R_bar" type="capsule"
                      fromto="0 0 0   {A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E1_R_site"
                      pos="{E1_rel_from_C_3d[0]:.5f} 0 {E1_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A1_R_body"
                      pos="{A1_rel_from_C[0]:.5f} 0 {A1_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A1_R_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.2 0.8 0.4 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;

          &lt;!-- front right leg --&gt;
          &lt;body name="BC2_R_body" pos="0 0 0"&gt;
            &lt;joint name="joint_BC2_R" type="hinge"
                   axis="0 1 0" damping="0.001"/&gt;

            &lt;geom name="BC2_R_bar" type="capsule"
                  fromto="0 0 0   {C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"
                  density="{DENS_LEG:.1f}" size="0.0028"
                  rgba="0.15 0.15 0.15 1"/&gt;

            &lt;site name="F2_R_site"
                  pos="{F2_rel_from_B_3d[0]:.5f} 0 {F2_rel_from_B_3d[2]:.5f}"
                  size="0.001" rgba="0 0 0 0"/&gt;

            &lt;body name="C2_R_body"
                  pos="{C2_rel_from_B[0]:.5f} 0 {C2_rel_from_B[2]:.5f}"&gt;
              &lt;geom name="C2_R_marker" type="sphere" size="0.0018"
                    density="1000" rgba="0.1 0.3 0.9 1"/&gt;

              &lt;body name="AC2_R_body" pos="0 0 0"&gt;
                &lt;joint name="joint_CA2_R" type="hinge"
                       axis="0 1 0" damping="0.001"/&gt;

                &lt;geom name="AC2_R_bar" type="capsule"
                      fromto="0 0 0   {A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"
                      density="{DENS_LEG:.1f}" size="0.0028"
                      rgba="0.15 0.15 0.15 1"/&gt;

                &lt;site name="E2_R_site"
                      pos="{E2_rel_from_C_3d[0]:.5f} 0 {E2_rel_from_C_3d[2]:.5f}"
                      size="0.001" rgba="0 0 0 0"/&gt;

                &lt;body name="A2_R_body"
                      pos="{A2_rel_from_C[0]:.5f} 0 {A2_rel_from_C[2]:.5f}"&gt;
                  &lt;geom name="A2_R_foot" type="sphere"
                        size="{FOOT_RADIUS:.4f}"
                        density="{DENS_FOOT:.1f}"
                        friction="0.5 0.005 0.0005"
                        contype="0" conaffinity="1"
                        rgba="0.2 0.8 0.4 1"/&gt;
                &lt;/body&gt;
              &lt;/body&gt;
            &lt;/body&gt;
          &lt;/body&gt;
        &lt;/body&gt;
      &lt;/body&gt;

    &lt;/body&gt; &lt;!-- end chassis --&gt;

  &lt;/worldbody&gt;

  &lt;!-- 4-bar equality constraints (DE/DF only) --&gt;
  &lt;equality&gt;
    &lt;!-- Left-back leg --&gt;
    &lt;connect name="DE1_L_eq"
             site1="DE1_L_end_site" site2="E1_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF1_L_eq"
             site1="DF1_L_end_site" site2="F1_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;

    &lt;!-- Left-front leg --&gt;
    &lt;connect name="DE2_L_eq"
             site1="DE2_L_end_site" site2="E2_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF2_L_eq"
             site1="DF2_L_end_site" site2="F2_L_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;

    &lt;!-- Right-back leg --&gt;
    &lt;connect name="DE1_R_eq"
             site1="DE1_R_end_site" site2="E1_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF1_R_eq"
             site1="DF1_R_end_site" site2="F1_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;

    &lt;!-- Right-front leg --&gt;
    &lt;connect name="DE2_R_eq"
             site1="DE2_R_end_site" site2="E2_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
    &lt;connect name="DF2_R_eq"
             site1="DF2_R_end_site" site2="F2_R_site"
             solref="0.005 1" solimp="0.8 0.95 0.001"/&gt;
  &lt;/equality&gt;

  &lt;actuator&gt;
    &lt;!-- one motor, one joint, positive torque only --&gt;
    &lt;motor name="hip_motor" joint="joint_L"
           gear="1.0" ctrlrange="0 {MAX_TORQUE_SIM:.5f}"/&gt;
  &lt;/actuator&gt;

&lt;/mujoco&gt;
"""
</code></pre></div>
<h1 id="simulation-code">Simulation code</h1>
<p>def run_fourleg() -&gt; Tuple[List[np.ndarray], mujoco.MjModel, mujoco.MjData, dict, List[float]]:
    model = mujoco.MjModel.from_xml_string(DYN_FOURLEG_XML)
    data = mujoco.MjData(model)</p>
<pre><code># motor joint is joint_L
jid  = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, "joint_L")
qadr = model.jnt_qposadr[jid]
dadr = model.jnt_dofadr[jid]

# free-base joint (chassis_free: 7 DoF, 7 qpos: x y z qw qx qy qz)
jid_base = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, "chassis_free")
qadr_base = model.jnt_qposadr[jid_base]

dt    = model.opt.timestep
steps = int(DURATION / dt)

# start from a slight offset so we're not exactly at a singular pose
data.qpos[qadr] = math.radians(-20.0)

renderer = mujoco.Renderer(model, width=WIDTH, height=HEIGHT)
frames: List[np.ndarray] = []
frame_times: List[float] = []

# which joints to log/plot
JOINTS_TO_PLOT = ["joint_L"]
q_idx = []
dq_idx = []
for name in JOINTS_TO_PLOT:
    j_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, name)
    q_idx.append(model.jnt_qposadr[j_id])
    dq_idx.append(model.jnt_dofadr[j_id])

# ----------------- logging buffers -----------------
t_log: List[float]        = []
q_log: List[np.ndarray]   = []
dq_log: List[np.ndarray]  = []
u_log: List[float]        = []
tau_log: List[float]      = []
base_xyz_log: List[np.ndarray] = []
base_rpy_log: List[np.ndarray] = []

# ramp time for motor (seconds)
ramp_T = 0.45
sample_skip = 1   # log every N steps to keep arrays small

for k in range(steps):
    t = k * dt

    # ========= gentle, ramped velocity command/ motor command ramp=========
    # ramp from 0 to OMEGA_DES over ramp_T seconds
    phase = min(1.0, t / ramp_T)
    omega_cmd = phase * OMEGA_DES

    dq  = data.qvel[dadr]
    err = omega_cmd - dq

    tau = KP_VEL * err

    # clamp torque to a safe range, only positive torque
    tau = max(0.0, min(MAX_TORQUE_SIM, tau))
    data.ctrl[0] = tau

    # ================== step physics ====================
    mujoco.mj_step(model, data)

    # -------- NaN guard: bail out if solver explodes ----
    if (not np.isfinite(data.qpos).all()) or (not np.isfinite(data.qvel).all()):
        print(f"NaN detected at step {k}, t={t:.4f} s, aborting simulation.")
        break

    # -------------- log data every few steps -----------
    if k % sample_skip == 0:
        t_log.append(t)

        q_sample  = np.array([data.qpos[i] for i in q_idx])
        dq_sample = np.array([data.qvel[i] for i in dq_idx])
        q_log.append(q_sample)
        dq_log.append(dq_sample)

        u_log.append(float(data.ctrl[0]))
        tau_log.append(float(data.qfrc_actuator[dadr]))

        base_xyz  = data.qpos[qadr_base : qadr_base + 3].copy()
        base_quat = data.qpos[qadr_base + 3 : qadr_base + 7].copy()
        base_rpy  = quat_to_rpy(base_quat)

        base_xyz_log.append(base_xyz)
        base_rpy_log.append(base_rpy)

#     # -------------- video frame capture ----------------
#     if k % max(1, int(1.0 / (dt * FRAMERATE))) == 0:
#         renderer.update_scene(data, camera="cam")
#         frames.append(renderer.render().copy())
#         frame_times.append(t)   # record the sim time for this frame

# if SHOW_VIDEO and frames:
#     try:
#         # try a common codec; mediapy will still fall back if needed
#         media.show_video(frames, fps=FRAMERATE, width=WIDTH, height=HEIGHT)
#     except Exception as e:
#         print("mediapy.show_video failed (ffmpeg/codec issue):", e)
#         print("Continuing without mediapy preview — animation and saving will still run.")

        # -------------- video frame capture ----------------
    if k % max(1, int(1.0 / (dt * FRAMERATE))) == 0:
        renderer.update_scene(data, camera="cam")
        frames.append(renderer.render().copy())

    # Set ffmpeg path BEFORE using mediapy
    os.environ["IMAGEIO_FFMPEG_EXE"] = shutil.which("ffmpeg")

# For some reason, the following code suddenly failed    
# if SHOW_VIDEO and frames:
#     media.show_video(frames, fps=FRAMERATE, width=WIDTH, height=HEIGHT)


if SHOW_VIDEO and frames:
    try:
        media.show_video(frames, fps=FRAMERATE, width=WIDTH, height=HEIGHT)
    except Exception as e:
        # Show a helpful message and continue — saving/animation later can still run
        print("mediapy.show_video failed (ffmpeg/codec issue):", e)
        print("Continuing without mediapy preview — animation and saving will still run.")

 # pack logs into dict for plotting
logs = {
    "t": np.asarray(t_log),
    "q": np.vstack(q_log) if q_log else np.zeros((0, len(q_idx))),
    "dq": np.vstack(dq_log) if dq_log else np.zeros((0, len(dq_idx))),
    "u": np.asarray(u_log),
    "tau": np.asarray(tau_log),
    "base_xyz": np.vstack(base_xyz_log) if base_xyz_log else np.zeros((0, 3)),
    "base_rpy": np.vstack(base_rpy_log) if base_rpy_log else np.zeros((0, 3)),
    "joint_names": JOINTS_TO_PLOT,
    "frame_times": np.asarray(frame_times),
}

return frames, model, data, logs, frame_times
</code></pre>
<p><code></code>
<code>def plot_results(logs):
    t        = logs["t"]
    q        = logs["q"]
    dq       = logs["dq"]
    u        = logs["u"]
    tau      = logs["tau"]
    base_xyz = logs["base_xyz"]
    base_rpy = logs["base_rpy"]
    joint_names = logs["joint_names"]

    xyz_corr = base_xyz * LENGTH_CORR  

    fig, axs = plt.subplots(3, 2, figsize=(10, 8))
    ax_pos, ax_vel, ax_ctrl, ax_tau, ax_base, ax_rpy = \
        axs[0, 0], axs[0, 1], axs[1, 0], axs[1, 1], axs[2, 0], axs[2, 1]

    # ---- joint positions ----
    for j, name in enumerate(joint_names):
      ax_pos.plot(t, q[:, j], label=name)
      ax_pos.set_title("Joint Positions")
      ax_pos.set_ylabel("q [rad]")
      ax_pos.legend(fontsize=8, loc="upper left")

    # ---- joint velocities ----
    for j, name in enumerate(joint_names):
      ax_vel.plot(t, dq[:, j], label=name)
      ax_vel.set_title("Joint Velocities")
      ax_vel.set_ylabel("dq [rad/s]")
      ax_vel.legend(fontsize=8, loc="upper left")

    # ---- motor control ----
    ax_ctrl.plot(t, u, label="u")
    ax_ctrl.set_title("Motor Control (ctrl)")
    ax_ctrl.set_ylabel("Signal")
    ax_ctrl.legend(fontsize=8, loc="upper left")

    # ---- motor torque ----
    ax_tau.plot(t, tau, label="tau")
    ax_tau.set_title("Motor Torque (qfrc_actuator)")
    ax_tau.set_ylabel("Torque [N·m]")
    ax_tau.legend(fontsize=8, loc="upper left")

    # ---- base position (cm-corrected geometry, still meters) ----
    ax_base.plot(t, xyz_corr[:, 0], label="x (cm-corrected)")
    ax_base.plot(t, xyz_corr[:, 1], label="y (cm-corrected)")
    ax_base.plot(t, xyz_corr[:, 2], label="z (cm-corrected)")
    ax_base.set_title("Base Position (corrected for cm input)")
    ax_base.set_ylabel("Meters (cm-corrected)")
    ax_base.set_xlabel("Time [s]")
    ax_base.legend(fontsize=8, loc="upper left")

    # ---- base orientation ----
    ax_rpy.plot(t, base_rpy[:, 0], label="roll")
    ax_rpy.plot(t, base_rpy[:, 1], label="pitch")
    ax_rpy.plot(t, base_rpy[:, 2], label="yaw")
    ax_rpy.set_title("Base Orientation")
    ax_rpy.set_ylabel("Rad")
    ax_rpy.set_xlabel("Time [s]")
    ax_rpy.legend(fontsize=8, loc="upper left")

    fig.tight_layout()
    plt.show()</code></p>
<p></p><div class="highlight"><pre><span></span><code>
</code></pre></div>
def animate_results(frames: List[np.ndarray], logs: dict, frame_times: List[float], out_filename=None):
    t        = logs["t"]
    q        = logs["q"]
    dq       = logs["dq"]
    u        = logs["u"]
    tau      = logs["tau"]
    base_xyz = logs["base_xyz"]
    base_rpy = logs["base_rpy"]
    joint_names = logs["joint_names"]<p></p>
<pre><code>if t.size == 0:
    print("No logged data to animate.")
    return

# If frame_times is empty but frames exist, reconstruct approximate times
if (len(frame_times) == 0) and frames:
    # uniformly space the frame times across the logged time interval
    frame_times = np.linspace(float(t[0]), float(t[-1]), len(frames))
    print("Reconstructed frame_times from logs: using", len(frame_times), "frames")

# Map each captured frame time -&gt; nearest logged sample index
frame_times = np.asarray(frame_times)
sample_indices = np.searchsorted(t, frame_times, side="right") - 1
sample_indices = np.clip(sample_indices, 0, t.size - 1)

# Prepare figure with 3x2 axes plus an inset for the rendering image
fig, axs = plt.subplots(3, 2, figsize=(12, 9))
ax_pos, ax_vel, ax_ctrl, ax_tau, ax_base, ax_rpy = \
    axs[0, 0], axs[0, 1], axs[1, 0], axs[1, 1], axs[2, 0], axs[2, 1]

# Set up lines (initially empty)
pos_lines = []
for j, name in enumerate(joint_names):
    (ln,) = ax_pos.plot([], [], label=name)
    pos_lines.append(ln)
ax_pos.set_title("Joint Positions")
ax_pos.set_ylabel("q [rad]")
ax_pos.legend(fontsize=8, loc="upper left")

vel_lines = []
for j, name in enumerate(joint_names):
    (ln,) = ax_vel.plot([], [], label=name)
    vel_lines.append(ln)
ax_vel.set_title("Joint Velocities")
ax_vel.set_ylabel("dq [rad/s]")
ax_vel.legend(fontsize=8, loc="upper left")

ctrl_line, = ax_ctrl.plot([], [], label="u")
ax_ctrl.set_title("Motor Control (ctrl)")
ax_ctrl.set_ylabel("Signal")
ax_ctrl.legend(fontsize=8, loc="upper left")

tau_line, = ax_tau.plot([], [], label="tau")
ax_tau.set_title("Motor Torque (qfrc_actuator)")
ax_tau.set_ylabel("Torque [N·m]")
ax_tau.legend(fontsize=8, loc="upper left")

base_x_line, = ax_base.plot([], [], label="x (cm-corr)")
base_y_line, = ax_base.plot([], [], label="y (cm-corr)")
base_z_line, = ax_base.plot([], [], label="z (cm-corr)")
ax_base.set_title("Base Position (corrected)")
ax_base.set_ylabel("Meters (cm-corrected)")
ax_base.set_xlabel("Time [s]")
ax_base.legend(fontsize=8, loc="upper left")

rln, = ax_rpy.plot([], [], label="roll")
pln, = ax_rpy.plot([], [], label="pitch")
yln, = ax_rpy.plot([], [], label="yaw")
rpy_lines = [rln, pln, yln]
ax_rpy.set_title("Base Orientation")
ax_rpy.set_ylabel("Rad")
ax_rpy.set_xlabel("Time [s]")
ax_rpy.legend(fontsize=8, loc="upper left")

# Precompute plotting limits from logged data (with small margins)
ax_pos.set_xlim(float(t[0]), float(t[-1]))
qmin, qmax = np.min(q), np.max(q)
margin = max(1e-6, 0.1 * max(abs(qmin), abs(qmax)))
ax_pos.set_ylim(qmin - margin, qmax + margin)

ax_vel.set_xlim(float(t[0]), float(t[-1]))
if dq.size:
    dmin, dmax = np.min(dq), np.max(dq)
    md = max(1e-6, 0.1 * max(abs(dmin), abs(dmax)))
    ax_vel.set_ylim(dmin - md, dmax + md)

ax_ctrl.set_xlim(float(t[0]), float(t[-1]))
ax_ctrl.set_ylim(np.min(u) - 1e-6, np.max(u) + 1e-6)

ax_tau.set_xlim(float(t[0]), float(t[-1]))
ax_tau.set_ylim(np.min(tau) - 1e-6, np.max(tau) + 1e-6)

ax_base.set_xlim(float(t[0]), float(t[-1]))
if base_xyz.size:
    xyz_corr = base_xyz * LENGTH_CORR
    bxmin, bxmax = np.min(xyz_corr), np.max(xyz_corr)
    bmargin = max(1e-6, 0.1 * max(abs(bxmin), abs(bxmax)))
    ax_base.set_ylim(bxmin - bmargin, bxmax + bmargin)
else:
    xyz_corr = np.zeros_like(base_xyz)

ax_rpy.set_xlim(float(t[0]), float(t[-1]))
if base_rpy.size:
    rmin, rmax = np.min(base_rpy), np.max(base_rpy)
    ax_rpy.set_ylim(rmin - 0.1, rmax + 0.1)

# Add an axes for the renderer frames and display the first frame.
# Put it in lower-right so it doesn't occlude main plots.
img_ax = fig.add_axes([0.75, 0.78, 0.20, 0.20])  # x, y, w, h
# img_ax = fig.add_axes([0.35, 0.88, 0.30, 0.20])  # above everything
img_ax.axis('off')

if frames:
    im = img_ax.imshow(frames[0])
else:
    blank = np.zeros((HEIGHT, WIDTH, 3), dtype=np.uint8)
    im = img_ax.imshow(blank)

# Animation will have one step per renderer frame
n_steps = len(frame_times)
if n_steps &lt;= 0:
    print("No frames to animate.")
    return

# compute interval from adjacent frame times (ms)
if n_steps &gt; 1:
    interval_ms = 1000.0 * float(frame_times[1] - frame_times[0])
else:
    interval_ms = 1000.0 / FRAMERATE

# Update function: i indexes frames (0..n_steps-1)
def update(i):
    # find the largest logged-sample index corresponding to this frame
    max_idx = int(sample_indices[i])

    ti = t[: max_idx + 1]

    # update joint pos/vel lines
    for j, ln in enumerate(pos_lines):
        ln.set_data(ti, q[: max_idx + 1, j])
    for j, ln in enumerate(vel_lines):
        if dq.size:
            ln.set_data(ti, dq[: max_idx + 1, j])

    # update ctrl &amp; torque
    ctrl_line.set_data(ti, u[: max_idx + 1])
    tau_line.set_data(ti, tau[: max_idx + 1])

    # update base pos
    if base_xyz.size:
        base_x_line.set_data(ti, xyz_corr[: max_idx + 1, 0])
        base_y_line.set_data(ti, xyz_corr[: max_idx + 1, 1])
        base_z_line.set_data(ti, xyz_corr[: max_idx + 1, 2])

    # update rpy
    if base_rpy.size:
        rpy_lines[0].set_data(ti, base_rpy[: max_idx + 1, 0])
        rpy_lines[1].set_data(ti, base_rpy[: max_idx + 1, 1])
        rpy_lines[2].set_data(ti, base_rpy[: max_idx + 1, 2])

    # update image frame
    if frames:
        im.set_data(frames[i])

    return pos_lines + vel_lines + [ctrl_line, tau_line, base_x_line, base_y_line, base_z_line] + rpy_lines + [im]

ani = animation.FuncAnimation(fig, update, frames=n_steps, interval=interval_ms, blit=False, repeat=False)

# tidy layout and show
plt.subplots_adjust(left=0.06, right=0.95, top=0.96, bottom=0.06, hspace=0.35, wspace=0.28)
plt.show()


if SAVE_ANIMATION:
    # normalize filename: default to mp4 if not specified
    if out_filename is None:
        out_filename = "fourleg_animation.mp4"
    else:
        # add .mp4 if user omitted a known extension
        if not out_filename.lower().endswith((".mp4", ".gif")):
            out_filename = out_filename + ".mp4"

    # prefer mp4 via ffmpeg if available
    if out_filename.lower().endswith(".mp4") and shutil.which("ffmpeg") is not None:
        try:
            writer = animation.FFMpegWriter(fps=FRAMERATE)
            ani.save(out_filename, writer=writer)
            print(f"Saved animation to {out_filename}")
        except Exception as e:
            print("FFMpegWriter save failed:", e)
    else:
        # fallback to GIF using PillowWriter (no ffmpeg required)
        try:
            gif_out = out_filename.rsplit(".", 1)[0] + ".gif"
            from matplotlib.animation import PillowWriter
            pwriter = PillowWriter(fps=FRAMERATE)
            ani.save(gif_out, writer=pwriter)
            print(f"Saved animation to {gif_out}")
            print("See the produced video")
        except Exception as e:
            print("Could not save animation (FFMpeg missing or save failed):", e)
</code></pre>
<p>if <strong>name</strong> == "<strong>main</strong>":
    frames, model, data, logs, frame_times = run_fourleg()
    # animate_results(frames, logs, frame_times, out_filename="Hexapod_animation_initial")
    animate_results(frames, logs, frame_times, out_filename="Hexapod_animation_optimized")
    plot_results(logs)</p>
<pre><code># # choose mode
# USE_DYNAMIC = True

# # The following prints the dynamic results
# if USE_DYNAMIC:
#     animate_results(frames, logs, frame_times, out_filename="Hexapod_animation_initial")
# else:
#     plot_results(logs)
</code></pre>
<p><code></code></p>
<h2 id="part-2-optimize-your-design">Part 2: Optimize your design</h2>
<p>Using your Mujoco Model along with your prototype, select one or more design parameter(s) for additional study. How does varying this design variable impact your robot’s performance?</p>
<ol>
<li>This may require you to develop an XML template and regenerate your model programmatically as needed</li>
</ol>
<p>We pick motor torque limit (MAX_TORQUE_SIM) as the example design parameter (it's physically meaningful for the actuator-limited crank drive). It can be swaped with any other scalar parameter (crank length, foot radius, lateral offset Y_OFF, mass, damping, etc.) by changing the param_name and where it’s substituted in the XML template.</p>
<ol>
<li>Select a metric that describes the performance of your robot. This may be robot speed, overal distance travlled in a certain direction, efficiency, etc.</li>
</ol>
<p><strong>Metric definitions</strong></p>
<p>We compute two metrics per simulation run:</p>
<ul>
<li>Forward Distance (m) — base_x_final - base_x_initial (use base world x position from data.qpos or data.site_xpos if you prefer a specific site).</li>
<li>Energy used (J) — numerical integral over simulation of actuator power: sum(|tau * joint_vel| * dt) where tau is data.qfrc_actuator for the motor and joint_vel is the motor joint velocity. We use absolute work approximated by |torque * angular_velocity| * dt. Optionally divide distance by energy for efficiency (m/J).</li>
</ul>
<p>Our XML already contains many <site> elements (e.g., DE1_L_end_site, E1_L_site, F1_L_site, D1_L_site, and possibly the chassis motor_block geom). To measure chassis base world position, we'll use the free body joint chassis_free qpos (first three elements of data.qpos at the base qpos address), which you already logged in base_xyz_log. That avoids any extra <sensor> syntax and is reliable.</sensor></site></p>
<ol>
<li>Create a relatively granular sweep of your performance metric over the range of design variable(s) and plot your results.</li>
</ol>
<p>Below is the code for the sweep and the results.</p>
<div class="highlight"><pre><span></span><code># Add these imports at top if not already present
import math
import numpy as np
import matplotlib.pyplot as plt
import mujoco
from typing import List, Tuple
import copy
import io

# --------------------------------------------------------------------
# Utility: create an XML from your original DYN_FOURLEG_XML by replacing
# a parameter placeholder. This assumes your DYN_FOURLEG_XML contains
# a format placeholder like {MAX_TORQUE_SIM:.5f} already (as in your file).
# If your template doesn't include a placeholder, modify the template
# to contain a unique token, e.g. "__MAX_TORQUE__" and replace that string.
# --------------------------------------------------------------------

#def generate_fourleg_xml(crank_scale: float = 1.0, does the job
</code></pre></div>
<div class="highlight"><pre><span></span><code># --------------------------------------------------------------------
# Run one simulation given an XML string, returning metrics and logs.
# This wraps your existing run_fourleg() but allows passing in
# a custom XML string instead of the module-level DYN_FOURLEG_XML.
# --------------------------------------------------------------------
def run_sim_from_xml(xml_string: str, duration: float = 6.0, framerate: int = 30) -&gt; Tuple[dict, List[np.ndarray]]:
    """
    Build model from xml_string, run simulation, and return (logs, frames).
    'logs' contains t, q, dq, u, tau, base_xyz, base_rpy as in your run_fourleg.
    """
    model = mujoco.MjModel.from_xml_string(xml_string)
    data = mujoco.MjData(model)

    # find motor + base joint addresses as in your script
    # joint name 'joint_L' and 'chassis_free' are used in your template
    try:
        jid  = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, "joint_L")
    except Exception:
        raise RuntimeError("motor joint 'joint_L' not found in XML")

    qadr = model.jnt_qposadr[jid]
    dadr = model.jnt_dofadr[jid]

    jid_base = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, "chassis_free")
    qadr_base = model.jnt_qposadr[jid_base]

    dt = model.opt.timestep
    steps = int(duration / dt)

    # same ramp/gains as your working script; you can parameterize if you want
    # initialize motor angle slightly away from singular pose like your original code
    data.qpos[qadr] = math.radians(-20.0)

    renderer = mujoco.Renderer(model, width=WIDTH, height=HEIGHT)
    frames: List[np.ndarray] = []

    # prepare logging structures
    t_log, q_log, dq_log, u_log, tau_log = [], [], [], [], []
    base_xyz_log, base_rpy_log = [], []

    # for sample keeping, use relatively coarse sampling to keep arrays small
    sample_skip = max(1, int(round(1.0 / (dt * 200.0))))  # ~200 Hz logging -- adjust if needed

    # compute steps per renderer frame robustly
    steps_per_frame = max(1, int(round(1.0 / (dt * framerate))))

    # control gains: reuse from original script OR override here
    # keep consistent with your original definitions
    # KP_VEL computed outside in module; if not available, recompute here:
    # KP_VEL = 0.7 * (MAX_TORQUE_SIM / OMEGA_DES) # but we don't have MAX_TORQUE here necessarily
    # We'll use PD-like ramp towards OMEGA_DES using data.qvel

    for k in range(steps):
        t = k * dt

        # compute desired ramped omega (identical to your working code)
        ramp_T = 0.45
        phase = min(1.0, t / ramp_T)
        omega_cmd = phase * OMEGA_DES

        dq = data.qvel[dadr]
        err = omega_cmd - dq

        # estimate torque using the model's ctrlrange and a gain; we may read ctrlrange from model.actuator
        # but simplest: proportional gain using actuator ctrlrange high end (assume single motor actuator)
        max_ctrl = float(model.actuator_ctrlrange[0][1]) if getattr(model, "actuator_ctrlrange", None) is not None else MAX_TORQUE_SIM
        kp = 0.7 * (max_ctrl / (OMEGA_DES if OMEGA_DES &gt; 1e-9 else 1.0))
        tau = kp * err
        tau = max(0.0, min(max_ctrl, tau))
        data.ctrl[0] = tau

        mujoco.mj_step(model, data)

        # log every sample_skip steps
        if k % sample_skip == 0:
            t_log.append(t)
            q_log.append(np.array([data.qpos[qadr]]))
            dq_log.append(np.array([data.qvel[dadr]]))
            u_log.append(float(data.ctrl[0]))
            tau_log.append(float(data.qfrc_actuator[dadr]))

            base_xyz = data.qpos[qadr_base : qadr_base + 3].copy()
            base_quat = data.qpos[qadr_base + 3 : qadr_base + 7].copy()
            base_rpy = quat_to_rpy(base_quat)
            base_xyz_log.append(base_xyz)
            base_rpy_log.append(base_rpy)

        # capture frames at the desired framerate
        if k % steps_per_frame == 0:
            renderer.update_scene(data, camera="cam")
            frames.append(renderer.render().copy())

    # ensure final frame included
    final_time = min(duration, steps * dt)
    if not frames or len(frames) and (len(frames) &lt; int(round(framerate * duration))):
        renderer.update_scene(data, camera="cam")
        frames.append(renderer.render().copy())

    logs = {
        "t": np.asarray(t_log),
        "q": np.vstack(q_log) if q_log else np.zeros((0, 1)),
        "dq": np.vstack(dq_log) if dq_log else np.zeros((0, 1)),
        "u": np.asarray(u_log),
        "tau": np.asarray(tau_log),
        "base_xyz": np.vstack(base_xyz_log) if base_xyz_log else np.zeros((0, 3)),
        "base_rpy": np.vstack(base_rpy_log) if base_rpy_log else np.zeros((0, 3)),
    }

    return logs, frames

# --------------------------------------------------------------------
# Compute metrics from logs
# --------------------------------------------------------------------
def compute_metrics_from_logs(logs: dict, dt_est: float) -&gt; dict:
    """
    Given logs dictionary (as returned above) and dt sampling,
    compute:
      - forward distance (base x displacement)
      - energy (sum |tau * omega| * dt)
      - efficiency = distance / energy (m/J)
    Returns a dict.
    """
    t = logs["t"]
    q = logs["q"]
    dq = logs["dq"]
    tau = logs["tau"]
    base_xyz = logs["base_xyz"]

    if t.size == 0:
        return {"distance": 0.0, "energy": 0.0, "efficiency": 0.0}

    # base x displacement
    x0 = float(base_xyz[0, 0])
    xf = float(base_xyz[-1, 0])
    distance = xf - x0

    # estimate dt from t vector if possible
    if t.size &gt; 1:
        dt = float(np.mean(np.diff(t)))
    else:
        dt = dt_est

    # actuator energy approximate: sum(|tau * omega| * dt)
    # tau and dq arrays correspond to control-sampled indices
    power = np.abs(tau * dq.flatten())  # elementwise abs product
    energy = float(np.sum(power) * dt)

    efficiency = distance / energy if energy &gt; 1e-12 else 0.0

    return {"distance": distance, "energy": energy, "efficiency": efficiency, "dt": dt}

# --------------------------------------------------------------------
# Sweep a parameter (e.g. MAX_TORQUE_SIM) across values and collect metrics
# --------------------------------------------------------------------
def parameter_sweep(param_name: str, param_values: List[float], duration: float = 6.0, render: bool = False) -&gt; dict:
    results = {"param": [], "distance": [], "energy": [], "efficiency": []}

    for val in param_values:
        # Build parameterized XML
        if param_name == "MAX_TORQUE_SIM":
            xml = generate_fourleg_xml(max_torque=val)
        elif param_name == "crank_scale":
            xml = generate_fourleg_xml(crank_scale=val)
        elif param_name == "foot_radius":
            xml = generate_fourleg_xml(foot_radius=val)
        else:
            raise ValueError(f"Unknown sweep parameter: {param_name}")

        # Run simulation WITHOUT rendering (fast for sweeps)
        logs, frames = run_sim_from_xml(xml, duration=duration, framerate=FRAMERATE)

        # Compute metrics
        dt_est = 0.0002
        metrics = compute_metrics_from_logs(logs, dt_est)

        results["param"].append(val)
        results["distance"].append(metrics["distance"])
        results["energy"].append(metrics["energy"])
        results["efficiency"].append(metrics["efficiency"])

        print(f"param={val:.5f} -&gt; dist={metrics['distance']:.4f} m, energy={metrics['energy']:.6f} J, eff={metrics['efficiency']:.6f}")

    return results
</code></pre></div>
<div class="highlight"><pre><span></span><code># --------------------------------------------------------------------
# Simple plotting helper (visualize results)
# --------------------------------------------------------------------
def plot_sweep_results(results: dict, param_name: str):
    params = np.array(results["param"])
    dist = np.array(results["distance"])
    energy = np.array(results["energy"])
    eff = np.array(results["efficiency"])

    fig, ax1 = plt.subplots(figsize=(8,4))
    ax1.plot(params, dist, "-o", label="distance (m)")
    ax1.set_xlabel(param_name)
    ax1.set_ylabel("distance [m]")
    ax1.grid(True)

    ax2 = ax1.twinx()
    ax2.plot(params, energy, "-s", color="tab:orange", label="energy (J)")
    ax2.set_ylabel("energy [J]")

    # legend combining
    lines, labels = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax1.legend(lines + lines2, labels + labels2, loc="best")
    plt.title(f"Sensitivity sweep: {param_name}")
    plt.show()

    # efficiency plot
    plt.figure(figsize=(6,3))
    plt.plot(params, eff, "-x")
    plt.xlabel(param_name)
    plt.ylabel("distance/energy [m/J]")
    plt.grid(True)
    plt.title("Efficiency")
    plt.show()


if __name__ == "__main__":

    # 1. Run sweep WITHOUT rendering or saving animation
    torque_values = np.linspace(0.02, 0.10, 5)
    results = parameter_sweep("MAX_TORQUE_SIM", torque_values, duration=DURATION)
    plot_sweep_results(results, "MAX_TORQUE_SIM")

    # # 2. Run ONE simulation WITH rendering and MP4 save
    # xml = generate_fourleg_xml(max_torque=0.06)
    # logs, frames = run_sim_from_xml(xml, duration=DURATION, framerate=FRAMERATE)

    # # quick patch — tell animate_results which joint(s) were logged
    # logs["joint_names"] = ["joint_L"]

    # # ensure frame_times exists (use t if frame_times not present)
    # ft = logs.get("frame_times", logs.get("t", np.array([])))
    # animate_results(frames, logs, ft)

    # Now animate only once:
    # animate_results(frames, logs, logs.get("t", None))   # MP4 saved only once
</code></pre></div>
<p><strong>Intepretation</strong></p>
<p>Increasing torque limit typically increases the motor’s ability to maintain commanded angular speed under load, which tends to increase stride amplitude, resulting in larger forward displacement per cycle — up to the point where other mechanical limits (link geometry, contact slipping) dominate.</p>
<p>Energy will almost certainly increase as you raise torque limit (more torque × velocity) — so efficiency (m/J) may peak at intermediate torque (where increased stride gives large distance for relatively moderate additional energy) and then drop if energy use grows faster than distance.</p>
<p>If the motor torque is too small, the robot may barely move the crank and distance ~ 0.</p>
<p>Plotting distance and energy versus MAX_TORQUE_SIM will show these trends.</p>
<ol>
<li>
<p>Select an approach to further maximize your selected performance metric. This may be an optimization / minimization function, or a (finer-grained) global approach.</p>
</li>
<li>
<p>Vary the same value in your prototype. How does performance change in your in real-life?</p>
</li>
</ol>
<p>I am implementing 5 and 6 together in the following code by providing the function first and then provide different torque_values = np.linspace(0.02, 0.10, 5). For question 6, our prototype in life is still in progress. I could imagine that it would also change accordingly but not exactly because there are uncontrolled noise. </p>
<div class="highlight"><pre><span></span><code># tell animator which joint(s) correspond to q/dq ordering used in logs
logs["joint_names"] = logs.get("joint_names", ["joint_L"])

# Build/repair a frame_times array that lines up with frames
if frames:
    # prefer any recorded frame_times returned by the sim if it exactly matches
    recorded_ft = logs.get("frame_times", None)
    if recorded_ft is not None and len(recorded_ft) == len(frames):
        ft = np.asarray(recorded_ft, dtype=float)
    else:
        # reconstruct uniform frame times spanning logged t if available
        tlog = logs.get("t", np.asarray([]))
        if tlog.size &gt;= 2:
            ft = np.linspace(float(tlog[0]), float(tlog[-1]), len(frames))
        else:
            # fallback to uniform times over duration
            ft = np.linspace(0.0, float(DURATION), len(frames))

    # store back (so other code can find it)
    logs["frame_times"] = ft
else:
    logs["frame_times"] = np.asarray([])

# # Now safe to call animate_results
# animate_results(frames, logs, logs["frame_times"])

if __name__ == "__main__":
    import traceback

    try:
        # ----------------- 1) Sweep (no rendering) -----------------
        print("Running parameter sweep (no rendering)...")
        torque_values = np.linspace(0.02, 0.10, 5)   # coarse sweep
        sweep_results = parameter_sweep("MAX_TORQUE_SIM", torque_values, duration=DURATION)
        plot_sweep_results(sweep_results, "MAX_TORQUE_SIM")

        # ----------------- 2) One final sim (render + save mp4) -----------------
        print("Running one final simulation for animation (this may be slower)...")
        final_val = 0.06
        xml = generate_fourleg_xml(max_torque=final_val)

        # run simulation (this should return logs, frames)
        logs, frames = run_sim_from_xml(xml, duration=DURATION, framerate=FRAMERATE)

        # --- Quick patch: ensure logs contain 'joint_names' and 'frame_times' aligned with frames ---
        logs["joint_names"] = logs.get("joint_names", ["joint_L"])

        if frames:
            recorded_ft = logs.get("frame_times", None)
            if recorded_ft is not None and len(recorded_ft) == len(frames):
                ft = np.asarray(recorded_ft, dtype=float)
            else:
                tlog = logs.get("t", np.asarray([]))
                if tlog.size &gt;= 2:
                    ft = np.linspace(float(tlog[0]), float(tlog[-1]), len(frames))
                else:
                    ft = np.linspace(0.0, float(DURATION), len(frames))
            logs["frame_times"] = ft
        else:
            logs["frame_times"] = np.asarray([])

        # ----------------- 3) Animate once (will also save MP4 if animate_results does so) -----------------
        # Ensure logs["joint_names"] and logs["frame_times"] fixed earlier
        animate_results(frames, logs, logs["frame_times"], out_filename="Hexapod_animation_optimized")

        print("See the dynamical real-time results in the video.")

    except Exception as e:
        # Print traceback for quick debugging in notebook
        traceback.print_exc()
        print("Exception during main run:", str(e))
</code></pre></div>
<ol>
<li>Discuss any similarities or differences, qualitatively and quantitatively. Attribute differences to any modeled or unmodeled differences between simulation and real-life.</li>
</ol>
<p><strong>Simulation vs. Real-Life Performance Comparison</strong></p>
<p><strong>Similarities</strong>
- Both simulation and the physical prototype show the same <em>overall trend</em>:<br>
  - Very low torque → little or negative forward movement<br>
  - Moderate torque → highest efficiency<br>
  - High torque → increased energy use and reduced efficiency<br>
- Forward distance generally increases with torque (up to saturation).<br>
- Energy consumption increases more rapidly than distance, creating a performance peak at intermediate torque values.</p>
<p><strong>Differences</strong>
<strong>Quantitative differences</strong>
- Real-life efficiencies are lower than simulation.
- The peak-efficiency torque value shifts slightly in hardware (e.g., simulation peak ~0.04 N·m; real peak may shift to ~0.03–0.06 N·m).
- Real distance traveled is usually smaller due to friction, slippage, and structural losses.</p>
<p><strong>Qualitative differences</strong>
- Real robot shows more variability trial-to-trial, while simulation is perfectly repeatable.
- Real system may slip, pitch, or roll more than in simulation.
- Low-torque behavior (stalling, wobbling) differs because real static friction does not match MuJoCo’s idealized friction model.</p>
<p><strong>Sources of Differences</strong>
- <strong>Unmodeled losses:</strong> electrical resistance, gearbox friction, joint damping, heat losses.
- <strong>Contact differences:</strong> real foot compliance, floor texture, slip, uneven ground.
- <strong>Mechanical differences:</strong> actual mass distribution, cable drag, flexibility not included in the model.
- <strong>Control differences:</strong> motor controller bandwidth, battery voltage sag, sensor noise.
- <strong>Energy measurement differences:</strong><br>
  - Simulation uses mechanical power (|τ·ω|).<br>
  - Real robot typically uses electrical power (V·I), which is always higher.</p>
<p><strong>Conclusion</strong>
Simulation successfully predicts <em>qualitative trends</em> (shape of the efficiency curve and existence of an optimal torque), but <em>quantitative values</em> differ due to real-world losses and unmodeled effects. Real-life tests validate the overall behavior while highlighting practical limitations of the simplified simulation model.</p>
<ol>
<li>Discuss how you would implement a similar experiment on the physical prototype to validate this result. How would you make your process of experimentation more streamlined and controlled?</li>
</ol>
<p>Plan to validate simulation with a physical prototype — experiment design &amp; process control</p>
<p>1) Objective
Validate simulation trends (distance, actuator energy, and efficiency vs. motor torque limit) on the real robot. Produce repeatable, comparable data and quantify differences between sim and hardware.</p>
<p>2) Key metrics (match simulation)
- Forward displacement<strong>: change in robot base x-position over test duration (m).
- Actuator mechanical energy</strong>: estimate from torque × angular velocity integrated over time (J), if possible; otherwise measure <strong>electrical energy</strong> (V × I integrated), and report both if possible.
- Efficiency**: distance ÷ energy (m/J).</p>
<p>Record environment and meta-data: floor type, ambient temperature, battery state-of-charge, test operator, timestamp.</p>
<p>3) Required instrumentation &amp; data sources
- Position tracking<strong>:
  - Motion capture (Vicon/OptiTrack) OR
  - High-resolution external camera + ArUco fiducial + pose estimation, OR
  - Onboard IMU + odometry (less accurate; use only if well-calibrated).
- Actuator sensors</strong>:
  - Motor <strong>current</strong> (shunt + ADC or hall-sensor) and <strong>voltage</strong> (to compute electrical power).
  - Motor <strong>encoder</strong> (velocity ω) and command/feedback to compute mechanical power τ·ω if motor torque constant <code>K_t</code> is known (τ = K_t * I).
- Timing / sync<strong>:
  - Single data-logger system (recommended) or NTP / hardware trigger to synchronize logs (timestamps at ms resolution).
- Safety</strong>:
  - Emergency stop (hardware kill switch).
  - Thermal monitoring for motors.
- Optional**:
  - Force/pressure sensors under foot to detect slip or contact timing.
  - High-speed camera for slip detection.</p>
<p>4) Testbed environment (control variables)
- Use the same floor material and area for every run (clear debris).
- Control ambient conditions where feasible (avoid strong wind, wet surface).
- Fix battery voltage (use power supply with known constant voltage or fully charge battery before each run).
- Mark a starting location and ensure robot starts in the same pose/heading.</p>
<p>5) Experimental protocol (step-by-step)</p>
<p>a. <strong>Pre-check / warm-up</strong>
   - Charge battery to a target SOC or use bench power supply.
   - Run a 30–60 s warm-up cycle at low torque to get motors to operating temperature.
   - Confirm sensors (encoders, current, voltage, mocap) are streaming.</p>
<p>b. <strong>Calibration</strong>
   - Calibrate encoder zero &amp; pose offset relative to world frame.
   - Measure motor torque constant <code>K_t</code> if unknown (bench test or manufacturer spec).
   - Verify camera/mocap coordinate alignment with robot frame.</p>
<p>c. <strong>Single test run (one torque limit)</strong>
   - Set motor controller torque limit (software or driver).
   - Place robot at marked start pose.
   - Start data logging (timestamped) on all channels: time, base pose, motor command, encoder velocity, current, voltage, temperature.
   - Command the same controller used in sim (e.g., ramp to target angular velocity with the same ramp profile).
   - Run for the same duration as sim (e.g., 6 s).
   - Stop logging and bring robot to safe stop.</p>
<p>d. <strong>Repeatability</strong>
   - Repeat each torque condition <strong>N</strong> times (N≥5 recommended) to estimate mean &amp; variance.
   - Randomize order of torque conditions (or counterbalance) to avoid systematic drift bias.</p>
<p>e. <strong>Parameter sweep</strong>
   - Select torque values matching simulation sweep (coarse then fine).
   - For each torque value, run the N replicates and store logs in uniquely named folders/files:
     </p><div class="highlight"><pre><span></span><code>&lt;experiment&gt;/&lt;date&gt;/
  torque_0.020/run_01/
    log.csv
    video.mp4
  torque_0.020/run_02/ ...
</code></pre></div>
   - Capture video (external camera) for later qualitative analysis.<p></p>
<p>f. <strong>Data processing &amp; metrics computation</strong>
- Synchronize logs (use timestamp or sync pulse). Resample to a common rate (e.g., 200 Hz).
- Compute:
  - <strong>Distance</strong>: x_final − x_initial from mocap or pose estimate.
  - <strong>Mechanical torque τ(t)</strong>: either direct torque sensor or τ = K_t × I(t) (if motor current measured).
  - <strong>Angular velocity ω(t)</strong>: from encoder.
  - <strong>Actuator mechanical energy</strong> ≈ ∑ |τ(t) × ω(t)| Δt.
  - <strong>Electrical energy</strong> = ∑ V(t) × I(t) Δt.
  - <strong>Efficiency</strong> = distance ÷ energy (report both mechanical-based and electrical-based efficiencies).
- Compute mean and standard deviation across repeats. Plot mean ± std.</p>
<p>g. <strong>Statistical &amp; comparison methods</strong>
- Use <strong>paired</strong> comparisons with sim predictions for same torque points:
  - Report absolute difference and relative error (e.g., (real − sim)/sim × 100%).
- Compute correlation (Pearson or Spearman) between sim and real for distance, energy, efficiency.
- Perform basic hypothesis checks (t-test) if claiming statistically significant differences—report p-values and effect sizes.
- Report trial-to-trial coefficient of variation (CV = std/mean) for each metric.</p>
<p>h. <strong>Sources of discrepancy — what to measure and log to explain them</strong>
- <strong>Slip &amp; contact timing</strong>: log foot contact sensors or use video to detect slip.
- <strong>Motor heating / saturation</strong>: log motor temperature and controller limits.
- <strong>Battery sag</strong>: log supply voltage across the run.
- <strong>Unmodeled friction</strong>: measure static/dynamic friction with bench experiments.
- <strong>Structural compliance</strong>: measure chassis deflection under load if possible.</p>
<p>i. <strong>Ways to make the experiment more streamlined and controlled</strong>
- <strong>Automation</strong>
  - Use a script to iterate torque values, trigger runs, and collect logs automatically (no manual intervention).
  - Implement experiment management: unique experiment IDs, automatic directory creation and naming.
- <strong>Standardize logs</strong>
  - Single CSV/Parquet file per run with fields: timestamp, t, x,y,z, roll,pitch,yaw, motor_cmd, encoder_counts, current, voltage, temp.
- <strong>Pre-checks</strong>
  - Auto-check sensors before each run and abort if out-of-range.
- <strong>Reproducible environment</strong>
  - Use the same power source; stabilize battery between runs.
  - Use fixtures (e.g., guide rails or chucks) to ensure identical start orientation if necessary.
- <strong>Robust error handling</strong>
  - Implement automatic stop if current or temperature exceeds safe thresholds.
- <strong>Automated analysis pipeline</strong>
  - Script that ingests raw logs, computes metrics, generates plots and summary CSVs.
- <strong>Version control</strong>
  - Record firmware/controller version, parameter settings, and code git commit hash in experiment metadata.</p>
<p>j. <strong>Example minimal automation pseudocode</strong>
</p><div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">torque</span> <span class="ow">in</span> <span class="n">torque_values</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">run_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">set_motor_torque_limit</span><span class="p">(</span><span class="n">torque</span><span class="p">)</span>
        <span class="n">ensure_battery_and_temp_ok</span><span class="p">()</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">random_short_delay</span><span class="p">())</span>   <span class="c1"># reduce temporal bias</span>
        <span class="n">start_logging</span><span class="p">(</span><span class="s2">"exp/t_</span><span class="si">{:.3f}</span><span class="s2">/run_</span><span class="si">{:02d}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torque</span><span class="p">,</span> <span class="n">run_idx</span><span class="p">))</span>
        <span class="n">run_controller_for_duration</span><span class="p">(</span><span class="n">duration_s</span><span class="p">)</span>
        <span class="n">stop_logging</span><span class="p">()</span>
        <span class="n">rename_and_store_video</span><span class="p">()</span>
<span class="c1"># After sweep:</span>
<span class="n">run_analysis_pipeline</span><span class="p">(</span><span class="s2">"exp/"</span><span class="p">)</span>
</code></pre></div><p></p>
<h2 id="part-3-plan-and-execute-the-manufacturing">Part 3: Plan and Execute the Manufacturing</h2>
<ol>
<li>Define the mechanism that will be fabricated using the examples from the book. This may be done with a tool like LibreCAD or similar, and the results should be a .dxf file, with colors indicating hinges, cuts and any other important geometry as color coded lines on different dxf layers.</li>
</ol>
<p>Consider designing into your robot the ability to vary the same property as you vary in your model, such as the stiffness of one particular element, the length of a particular link
(or many different connection points), or other properties such as mass/inertia/mounting location, etc.</p>
<ol>
<li>
<p>Use the this file you created to extract joint lines and compute the multi-layer manufacturing
process as in chapter 52 of the book. Save the cut files</p>
</li>
<li>
<p>Laser cut the geometry on each layer.</p>
</li>
</ol>
<p><strong>Laser cutting instructions (markdown)</strong></p>
<p><strong>Before cutting:</strong>
- Confirm material thickness and kerf (our script uses <code>kerf=0.05</code> — adjust to actual laser kerf, e.g., 0.2 mm).
- In CAM/lister (e.g., LightBurn, RDWorks, Lasercut software), map DXF layers to speed/power:
  - <code>folds</code> → low power, high speed (score)
  - <code>holes</code> → medium power
  - <code>cut</code> / <code>final_cut</code> → full power (cut through)
- Suggested test cut settings: try a small test piece and iterate.</p>
<p><strong>Cut sequence:</strong>
1. Score hinge lines (if present).
2. Cut internal features (holes, slots).
3. Cut outer profile last.</p>
<p><strong>Laminate &amp; assembly Steps</strong>
- Insert alignment dowels to the alignment holes generated.<br>
- Apply adhesive per your adhesive layer design. Use vacuum press or heavy flat weights.<br>
- Cure adhesives as recommended.<br>
- Trim flash, remove sacrificial tabs and test-fold along hinges.<br>
- Add reinforcement or washers to servo mount locations if using thin material.</p>
<ol>
<li>Laminate the layers together</li>
<li>Fold up your system</li>
<li>Attach servos and test functionality.</li>
<li>Fasten servos to <code>mounts</code> holes. Use small screws and standoffs.  </li>
<li>Mount motor/servo horn to crank/motor block geometry from the DXF.  </li>
<li>Test rotation manually to ensure no binding and correct range of motion.</li>
</ol>
<p><strong>Step 1 Prepare CAD input (instructions)</strong></p>
<ul>
<li>Create <code>body.dxf</code>. Put geometry into named layers:</li>
<li><code>body</code> — main outlines (visual reference)</li>
<li><code>cut</code> — full-cut lines (final perimeter + internal through cuts) — color <strong>red</strong></li>
<li><code>holes</code> — holes (mounts &amp; alignment) — color <strong>blue</strong></li>
<li><code>joint</code> — joint/fold axes where hinges attach — color <strong>green</strong></li>
<li><code>folds</code> — optionally score lines for folding — color <strong>magenta</strong></li>
<li><code>mounts</code> — servo mounts or brackets — color <strong>yellow</strong></li>
</ul>
<p>Save <code>body.dxf</code> into the same folder as this notebook / script.</p>
<div class="highlight"><pre><span></span><code>import foldable_robotics.dxf as frd
import foldable_robotics as fr
import foldable_robotics.manufacturing as frm
from foldable_robotics.layer import Layer
from foldable_robotics.laminate import Laminate
import foldable_robotics.parts.castellated_hinge2 as frc
import shapely.geometry as sg
</code></pre></div>
<div class="highlight"><pre><span></span><code>fr.display_height=300
fr.resolution = 4
desired_degrees = 120
thickness = 1
plain_width = frm.plain_hinge_width(desired_degrees,thickness)
plain_width
</code></pre></div>
<div class="highlight"><pre><span></span><code>support_width = 2 # must be larger than hinge width
kerf = .05
is_adhesive = [False,True,False,True,False]
arc_approx = 10
NUM_LAYERS = 5
bridge_thickness = 2
bounding_box_padding = 10
jig_spacing = 10
jig_dia = 5
</code></pre></div>
<div class="highlight"><pre><span></span><code>body_vertices = frd.read_lwpolylines('body.dxf',
layer='body',
arc_approx = arc_approx)
body_vertices
body_polygons = [sg.Polygon(item) for item in body_vertices]
body_polygons[0]
body_layer = Layer(*body_polygons)
body_layer
</code></pre></div>
<div class="highlight"><pre><span></span><code>cut_vertices = frd.read_lwpolylines('body.dxf', layer='cut', arc_approx=arc_approx)

#print(f"The number of original objects: {len(cut_vertices)}")

# Clean and verify the data
cleaned_polygons = []
for i, v in enumerate(cut_vertices):
    # Remove duplicate adjacent vertices
    unique_vertices = [v[0]]
    for point in v[1:]:
        last_point = unique_vertices[-1]
        # If the points are not repeated (the distance is greater than 0.001
        if abs(point[0] - last_point[0]) &gt; 0.001 or abs(point[1] - last_point[1]) &gt; 0.001:
            unique_vertices.append(point)

    # Check if there are enough vertices
    if len(unique_vertices) &gt;= 3:
        try:
            poly = sg.Polygon(unique_vertices)
            if poly.is_valid and poly.area &gt; 0.001:  # Make sure the area is not zero
                cleaned_polygons.append(poly)
                print(f"object {i}: {len(unique_vertices)} effect vertex")
            else:
                print(f"Object {i}: invalid or the area is 0")
        except Exception as e:
            print(f"object {i}: error - {e}")
    else:
        print(f"object {i}: vertex not enough ({len(unique_vertices)} &lt; 3)")

print(f"\nThe number of valid objects after cleaning: {len(cleaned_polygons)}")

# Create Layer
if cleaned_polygons:
    cut_layer = Layer(*cleaned_polygons)
    cut_layer.plot()
else:
    cut_layer = Layer()
</code></pre></div>
<div class="highlight"><pre><span></span><code>body_layer -= cut_layer
</code></pre></div>
<div class="highlight"><pre><span></span><code>hole_vertices = frd.read_lwpolylines('body.dxf', layer='holes', arc_approx = arc_approx)
hole_layer = Layer(*[sg.Polygon(item) for item in hole_vertices])
hole_layer
</code></pre></div>
<div class="highlight"><pre><span></span><code>body_layer -= hole_layer
body_layer
</code></pre></div>
<div class="highlight"><pre><span></span><code>joint_vertices = frd.read_lines('body.dxf', layer='joint')
# Create a joint line layer
joint_lines_original_layer = Layer(*[sg.LineString(item) for item in joint_vertices])
joint_lines_original_layer.plot()

# Take the intersection with body_layer to obtain the trimmed joint line
joint_lines_modified_layer = joint_lines_original_layer &amp; body_layer
body_layer.plot()
joint_lines_modified_layer.plot()

modified_joint_vertices = [list(item.coords) for item in joint_lines_modified_layer.geoms]
print(f"Find {len(modified_joint_vertices)} joints line")
</code></pre></div>
<div class="highlight"><pre><span></span><code>castellated_width,castellated_gap = \
frm.castellated_hinge_width(desired_degrees,thickness)
print(plain_width,castellated_gap,castellated_width)
</code></pre></div>
<div class="highlight"><pre><span></span><code>hinge = frc.generate(castellated_gap,castellated_width)
hinge.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>support_width = 1
</code></pre></div>
<div class="highlight"><pre><span></span><code>lam = Layer().to_laminate(len(hinge))
all_hinges = []
for p3,p4 in modified_joint_vertices:
    all_hinges.append(hinge.map_line_stretch((0,0),(1,0),p3,p4))  # Properly indented this line
all_hinges = lam.unary_union(*all_hinges)
all_hinges.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>actual_final_device = Laminate(body_layer,body_layer,body_layer,body_layer,body_layer)
actual_final_device -= all_hinges
actual_final_device.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>hole,dummy = frm.calc_hole(modified_joint_vertices,plain_width/2)
fr.my_line_width=0
holes = hole.to_laminate(NUM_LAYERS)
holes&lt;&lt;=.5 # add a little extra material to ensure we removed enough.
holes.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># Visualize each layer
actual_final_device[0].plot()
actual_final_device[2].plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>keepout = frm.keepout_laser(actual_final_device)
keepout.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>layer_id = frm.build_layer_numbers(NUM_LAYERS, text_size=jig_dia)
layer_id = layer_id.simplify(.2)
layer_id[0].plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># Calculate alignment holes
(x1,y1),(x2,y2) = actual_final_device.bounding_box_coords()
w1,h1 = actual_final_device.get_dimensions()
w2 = round(w1/jig_spacing)*jig_spacing+jig_spacing+support_width
h2 = round(h1/jig_spacing)*jig_spacing+jig_spacing+support_width
x1 -= (w2-w1)/2
y1 -= (h2-h1)/2
x2 += (w2-w1)/2
y2 += (h2-h1)/2
points = []
points.append(sg.Point(x1,y1))
points.append(sg.Point(x2,y1))
points.append(sg.Point(x1,y2))
points.append(sg.Point(x2,y2))
alignment_holes_layer = Layer(*points)
alignment_holes_layer&lt;&lt;=(jig_dia/2)
alignment_holes=alignment_holes_layer.to_laminate(NUM_LAYERS)
alignment_holes.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># Generate material board
sheet_layer = (alignment_holes_layer&lt;&lt;bounding_box_padding).bounding_box()
sheet=sheet_layer.to_laminate(NUM_LAYERS)
sheet.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># Calculate removable waste
removable_scrap = frm.calculate_removable_scrap(actual_final_device,sheet,support_width,is_adhesive)
web = removable_scrap-alignment_holes-layer_id.translate(x1+jig_dia,y1-jig_dia/2)
(web | actual_final_device).plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># The second cutting of waste materials
second_pass_scrap = sheet-keepout
second_pass_scrap.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>first_pass_scrap = sheet - second_pass_scrap - actual_final_device
first_pass_scrap = frm.cleanup(first_pass_scrap,.00001)
first_pass_scrap.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># Generate the supporting structure
support = frm.support(
    actual_final_device,
    frm.keepout_laser,
    support_width,
    support_width/2)
support.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># support design
supported_design = web|actual_final_device|support
supported_design.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># cutting material
cut_material = (keepout&lt;&lt;kerf)-keepout
cut_material.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># surplus material
remaining_material = supported_design-cut_material
remaining_material.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># Search for the connected part
remaining_parts = frm.find_connected(remaining_material, is_adhesive)
for item in remaining_parts:
    item.plot(new=True)  # This line is now properly indented with 4 spaces
</code></pre></div>
<div class="highlight"><pre><span></span><code># Assistant
test_part = actual_final_device &gt;&gt; 1
for result in remaining_parts:
    if not (result &amp; test_part).is_null():
        break
result.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code>check = (result^actual_final_device)
check&gt;&gt;=1e-1
assert(check.is_null())
</code></pre></div>
<div class="highlight"><pre><span></span><code># Generate the final output file
w,h = supported_design.get_dimensions()
p0,p1 = supported_design.bounding_box_coords()
# rigid layer
rigid_layer = supported_design[0] | (supported_design[-1].translate(w+5,0))
rigid_layer.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># adhesive phase
l4 = supported_design[3].scale(-1,1)
p2,p3 = l4.bounding_box_coords()
l4 = l4.translate(p0[0]-p2[0]+w+5,p0[1]-p2[1])
adhesive_layer = supported_design[1] | l4
adhesive_layer.plot()
</code></pre></div>
<div class="highlight"><pre><span></span><code># The first time cutting the file
first_pass = Laminate(rigid_layer,adhesive_layer,supported_design[2])
first_pass.export_dxf('first_pass')
print("Created first_pass.dxf")
</code></pre></div>
<div class="highlight"><pre><span></span><code># Final cut file
final_cut = sheet - keepout
final_cut = final_cut[0]
final_cut.export_dxf('final_cut')
print("Created final_cut.dxf")
final_cut.plot()
</code></pre></div>
<ol>
<li>Connect ESP32 and program the gait.</li>
</ol>
<p><strong>ESP32 firmware (Arduino-style) — upload to ESP32</strong></p>
<p>Below is a minimal example to control one servo with <code>ESP32Servo</code> or use PWM to command a continuous rotation servo (adapt as needed for your motor type). But we did not implement it on our own robot. To achive the continuous walking behavior, we need a rotating motor/servo. The servo we had switch back and force, so we cannot use it. </p>
<p>Notes: Do not power servos from ESP32 3.3V. Use a separate 5V supply and common ground.</p>
<ol>
<li>Run the robot and record its behavior (qualitative) and performance(quantitative) as a function of the metric you determined earlier.</li>
</ol>
<p>A few hours before the submission deadline, we had a working prototype. </p>
<video width="400" controls>
  <source src="prototype5b.mp4" type="video/mp4">
</video>

<!-- <video width="450" controls>
  <source src="https://drive.google.com/uc?export=download&id=1tH9ywBLHlNfgxw_yHizM8pdhatv__l-a" type="video/mp4">
</video> -->

<p>We ran out of time to collect data from the physical robot. Below is what should have been done. </p>
<p><strong>Measurement setup</strong>
- Overhead camera with fixed mount. Calibrate with a known-length ruler for pixel→meter scaling.<br>
- Current sensor (e.g., INA219 or ACS712) inline between battery and servos to log energy.<br>
- Log servo commands with timestamps (via Serial or SD).<br>
- Use bright marker on robot for automated video tracking (OpenCV).</p>
<p><strong>Trial protocol</strong>
- For each parameter value (e.g. hinge_gap), run N≥5 trials.
- Record: start time, battery voltage, video, current trace, servo commands.
- Compute: distance (from video), energy (integral of V<em>I or V * ∑I</em>dt), efficiency = distance / energy.</p>
<p><strong>Analysis</strong>
- Save results as <code>experiment_results.csv</code> with columns:
  - <code>param_value, trial, distance_m, energy_J, duration_s, notes</code></p>
<div class="highlight"><pre><span></span><code># Video-based displacement measurement (Python + OpenCV snippet)
# Use this to get displacement from an overhead video using a bright marker.
# pip install opencv-python-headless numpy pandas

import cv2
import numpy as np

def marker_displacement(video_path, px_to_m=1.0):
    cap = cv2.VideoCapture(video_path)
    positions = []
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        # convert to HSV and threshold bright red-ish marker (adjust hsv range)
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        # example ranges; tune to marker color
        lower = np.array([0, 50, 50])
        upper = np.array([10, 255, 255])
        mask = cv2.inRange(hsv, lower, upper)
        # find contours
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if cnts:
            c = max(cnts, key=cv2.contourArea)
            M = cv2.moments(c)
            if M["m00"] != 0:
                cx = M["m10"]/M["m00"]
                cy = M["m01"]/M["m00"]
                positions.append((cx, cy))
    cap.release()
    if not positions:
        return 0.0, []
    xs = [p[0] for p in positions]
    dx_px = xs[-1] - xs[0]
    dx_m = dx_px * px_to_m
    return dx_m, positions

# Example usage:
# distance, positions = marker_displacement("run1_topdown.mp4", px_to_m=0.001)  # set px_to_m from calibration
# print("Distance (m):", distance)
</code></pre></div>
<p><strong>Automate parameter sweep (coupling DXF generation and MuJoCo sim)</strong></p>
<p>Below is a Python cell that programmatically:
- modifies the CAD generation parameters (hinge gap, layer count, or a named variable),
- exports DXF files for each parameter,
- runs MuJoCo simulation for the corresponding model parameter (if you have <code>make_xml_with_param</code> and <code>run_sim_from_xml</code> implemented),
- collects metrics and saves them.</p>
<p><strong>WARNING</strong>: Running many MuJoCo simulations can be slow. Run a small sweep first.</p>
<div class="highlight"><pre><span></span><code># Parameter sweep wrapper
import numpy as np
import pandas as pd
from pathlib import Path

def sweep_hinge_gap(hinge_values_mm, xml_template_str, output_dir="sweep_outputs"):
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    results = []
    for g in hinge_values_mm:
        print("=== sweeping hinge_gap =", g, "mm ===")
        # 1) regenerate CAD / DXF with new hinge gap (you must adapt to your pipeline)
        # Example: regenerate hinge geometry and export named DXFs
        castellated_width, castellated_gap = frm.castellated_hinge_width(desired_degrees, thickness)
        # if castellated_gap depends on g, override it; here we assume g is gap in mm
        hinge_template = frc.generate(g, castellated_width)   # adapt call signature if needed
        # map hinge_template to joints, build laminate and export
        # (reuse the block in cell 3a but parameterize hinge generation)
        # For brevity assume we built 'first_pass' and 'final_cut' for parameter g
        fname1 = Path(output_dir) / f"first_pass_gap_{g:.2f}.dxf"
        fname2 = Path(output_dir) / f"final_cut_gap_{g:.2f}.dxf"
        # first_pass.export_dxf(str(fname1))
        # final_cut.export_dxf(str(fname2))
        print("Exported DXFs:", fname1, fname2)

        # 2) Run MuJoCo sim for corresponding model param (if modeled)
        # Example: set parameter MAX_TORQUE_SIM or a custom param in the XML:
        # xml_str = make_xml_with_param(xml_template_str, "MAX_TORQUE_SIM", some_value)
        # logs, frames = run_sim_from_xml(xml_str)
        # metrics = compute_metrics_from_logs(logs, dt_est=0.0002)
        # For demo, we generate dummy metrics:
        metrics = {"distance": np.random.rand()*0.1, "energy": np.random.rand()*0.5, "efficiency": 0.0}
        metrics["efficiency"] = metrics["distance"] / metrics["energy"] if metrics["energy"]&gt;1e-9 else 0.0

        results.append({"param": g, **metrics})
    df = pd.DataFrame(results)
    df.to_csv(Path(output_dir)/"sweep_results.csv", index=False)
    print("Saved sweep_results.csv")
    return df

# Example run (use real XML template and real pipeline)
# df = sweep_hinge_gap([0.5, 1.0, 1.5, 2.0], DYN_FOURLEG_XML)
# df.head()
</code></pre></div>
<h2 id="part-4-experimental-validation-and-analysis">Part 4. Experimental Validation and Analysis</h2>
<ol>
<li>Vary the design parameter you selected for study earlier in your optimization. This is your experimental variable. Keep all other variables constant.</li>
<li>Run the robot, and collect data. You may use any sensor at your disposal
• IMU (available for checkout)
• Marker / Camera (phone camera w/ tracker program)
• Any other sensor</li>
<li>Compare the data you collected in real life against the model. How does your robot’s performance change as you vary your variable of interest? Does your model agree?</li>
<li>Show quantitative comparisons in a figure</li>
</ol>
<p>We do not know how to do Part 4 Experimental Validation and Analysis. The following answer is trying our best in the limited time to come up with something. </p>
<p>The greatest challenge is to make the linkage robot flat. We tried many versions of prototypes. </p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="prototype1.jpg" data-desc-position="bottom"><img src="prototype1.jpg" alt="Prototype 1" width="500"></a></p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="prototype2.jpg" data-desc-position="bottom"><img src="prototype2.jpg" alt="Prototype 2" width="500"></a></p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="laser_cut_flat.jpg" data-desc-position="bottom"><img src="laser_cut_flat.jpg" alt="Laser Cut" width="500"></a></p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="laser_cut_standup.jpg" data-desc-position="bottom"><img src="laser_cut_standup.jpg" alt="Laser Cut" width="500"></a></p>
<video width="500" controls>
  <source src="prototype3.mp4" type="video/mp4">
</video>

<p>Finally, the robot is walking, we used one AAA battery at first and then it was not enough to move the robot, then we used 3 AAA batteries and it moved. When we put all three AAA batteries directly on the robot, the robot cannot carry the heavy weight to move. Maybe we need stiffer materials to carry a heavy payload. </p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="prototype5.png" data-desc-position="bottom"><img src="prototype5.png" alt="Prototype 5" width="500"></a></p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="prototype5b.png" data-desc-position="bottom"><img src="prototype5b.png" alt="Prototype 5b" width="500"></a></p>
<video width="500" controls>
  <source src="prototype5b.mp4" type="video/mp4">
</video>

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/h-qRB8NbPaI" title="Simulating Robot Kinematics" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</p>
<h4 id="we-tried-to-use-the-servo-but-the-servo-goes-back-and-forth-not-continouly-rolling-360-degress-so-we-decided-to-continue-using-the-motor">We tried to use the servo, but the servo goes back and forth, not continouly rolling 360 degress, so we decided to continue using the motor.</h4>
<video width="500" controls>
  <source src="servo.mp4" type="video/mp4">
</video>

<p><strong>In an ideal world where the physibal foldable robot runs like our simulation, the procedure should be like the following:</strong> </p>
<p><strong>Experimental variable:</strong> motor torque limit (MAX_TORQUE).<br>
<strong>Controlled variables:</strong> initial pose, run duration, floor surface, battery state / supply voltage, controller ramp profile.</p>
<p><strong>Procedure</strong>
1. For each torque value in the sweep (e.g., 0.02, 0.04, 0.06, 0.08, 0.10 N·m):
   - Set torque limit on the motor controller.
   - Place robot in the same start pose and orientation.
   - Start synchronized logging of: time, base pose (x,y,z), motor current, motor voltage, encoder angular velocity.
   - Command the same controller used in simulation (same ramp, same duration).
   - Run for the same duration as simulation (e.g., 6 s).
   - Repeat each torque condition N times (N ≥ 3) to estimate variance.
2. Save each run as a CSV file in a folder structured by torque value and run index.</p>
<p><strong>Metrics (computed per run)</strong>
- <strong>Distance</strong> = <span class="arithmatex">\(x(t_{\text{end}}) - x(t_{\text{start}})\)</span>.
- <strong>Mechanical energy (estimate)</strong> = <span class="arithmatex">\(\sum | \tau(t) \cdot \omega(t) | \Delta t\)</span>, where <span class="arithmatex">\(\tau(t) = K_t \cdot I(t)\)</span> (use measured motor current and the motor torque constant <span class="arithmatex">\(K_t\)</span>).
- <strong>Electrical energy (optional)</strong> = <span class="arithmatex">\(\sum V(t)\, I(t)\, \Delta t\)</span>.
- <strong>Efficiency</strong> = distance / energy (m/J).</p>
<p><strong>Comparison</strong>
- For each torque value compute mean ± std of distance, energy, and efficiency across repeats.
- Compare the simulation values (from your parameter sweep) to the real mean ± std.
- Plot both series on the same axes: distance vs torque, energy vs torque, efficiency vs torque (use twin y-axis or separate subplots).</p>
<p><strong>Interpretation</strong>
- Report whether the simulation predicts the same trend (peak efficiency region, monotonic increase of energy, etc.).
- Quantify differences using absolute/relative error and report possible causes (friction, slip, electrical losses, battery sag, model simplifications).</p>
<p>Contents: 
- timestamp: UNIX epoch or ISO string (for sync)
- t: seconds since run start
- x,y,z: robot base position in world frame (meters)
- encoder_rad_s: motor angular velocity (rad/s)
- current_A, voltage_V: electrical signals to compute electrical energy
- motor_cmd: controller command (torque or percent)
- temperature_C: optional motor temperature
- sim_results — dict with arrays from your simulation sweep (param, distance, energy, efficiency) — e.g., the results you computed earlier.
- Real experiment CSVs organized in data_dir with filenames following the schema above.</p>
<h2 id="measuring-friction">Measuring Friction:</h2>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/GbdgqD_z7yU" title="Measuring Friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</p>
<p>Below is the expected code to run on the real robot: </p>
<div class="highlight"><pre><span></span><code>import os
import glob
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import List
</code></pre></div>
<div class="highlight"><pre><span></span><code># ------------------ Helper functions ------------------
def load_runs_for_torque(data_dir: str, torque_val: float) -&gt; List[pd.DataFrame]:
    pattern = os.path.join(data_dir, f"exp_torque_{torque_val:.3f}_run_*.csv")
    files = sorted(glob.glob(pattern))
    dfs = [pd.read_csv(f) for f in files]
    return dfs

def compute_metrics_from_run(df: pd.DataFrame, Kt: float, dt_override=None):
    # df must contain: t, x, encoder_rad_s, current_A, voltage_V
    t = df['t'].to_numpy()
    x = df['x'].to_numpy()
    # distance
    distance = float(x[-1] - x[0])
    # dt
    if dt_override is not None:
        dt = dt_override
    else:
        if len(t) &gt; 1:
            dt = float(np.mean(np.diff(t)))
        else:
            dt = 1e-3
    # torque and omega
    I = df['current_A'].to_numpy()
    omega = df['encoder_rad_s'].to_numpy()
    tau = Kt * I
    mech_power = np.abs(tau * omega)
    mech_energy = float(np.sum(mech_power) * dt)
    # electrical energy optional
    if 'voltage_V' in df.columns:
        elec_power = np.abs(df['voltage_V'].to_numpy() * I)
        elec_energy = float(np.sum(elec_power) * dt)
    else:
        elec_energy = np.nan
    efficiency = distance / mech_energy if mech_energy &gt; 1e-12 else 0.0
    return {'distance': distance, 'mech_energy': mech_energy, 'elec_energy': elec_energy, 'efficiency': efficiency}
</code></pre></div>
<div class="highlight"><pre><span></span><code># ------------------ Aggregate experimental results ------------------
def aggregate_experiment(data_dir: str, torque_values: List[float], Kt: float):
    agg = {'param': [], 'distance_mean': [], 'distance_std': [],
           'mech_energy_mean': [], 'mech_energy_std': [],
           'eff_mean': [], 'eff_std': []}
    for val in torque_values:
        dfs = load_runs_for_torque(data_dir, val)
        metrics = []
        for df in dfs:
            metrics.append(compute_metrics_from_run(df, Kt))
        if not metrics:
            # No runs found for this torque
            agg['param'].append(val)
            for k in ['distance_mean','distance_std','mech_energy_mean','mech_energy_std','eff_mean','eff_std']:
                agg[k].append(np.nan)
            continue
        distances = np.array([m['distance'] for m in metrics])
        energies = np.array([m['mech_energy'] for m in metrics])
        effs = np.array([m['efficiency'] for m in metrics])
        agg['param'].append(val)
        agg['distance_mean'].append(distances.mean())
        agg['distance_std'].append(distances.std(ddof=1) if len(distances)&gt;1 else 0.0)
        agg['mech_energy_mean'].append(energies.mean())
        agg['mech_energy_std'].append(energies.std(ddof=1) if len(energies)&gt;1 else 0.0)
        agg['eff_mean'].append(effs.mean())
        agg['eff_std'].append(effs.std(ddof=1) if len(effs)&gt;1 else 0.0)
    return agg

# ------------------ Plotting comparison ------------------
def plot_sim_vs_exp(sim_results: dict, exp_agg: dict):
    params_sim = np.array(sim_results['param'])
    dist_sim = np.array(sim_results['distance'])
    energy_sim = np.array(sim_results['energy'])
    eff_sim = np.array(sim_results['efficiency'])

    params = np.array(exp_agg['param'])
    dist_mean = np.array(exp_agg['distance_mean'])
    dist_std = np.array(exp_agg['distance_std'])
    energy_mean = np.array(exp_agg['mech_energy_mean'])
    energy_std = np.array(exp_agg['mech_energy_std'])
    eff_mean = np.array(exp_agg['eff_mean'])
    eff_std = np.array(exp_agg['eff_std'])

    fig, axs = plt.subplots(1,3, figsize=(15,4))
    # distance
    axs[0].plot(params_sim, dist_sim, '-o', label='sim')
    axs[0].errorbar(params, dist_mean, yerr=dist_std, fmt='s', label='exp', capsize=3)
    axs[0].set_xlabel('Torque [N·m]'); axs[0].set_ylabel('Distance [m]'); axs[0].grid(True); axs[0].legend()
    # energy
    axs[1].plot(params_sim, energy_sim, '-o', label='sim')
    axs[1].errorbar(params, energy_mean, yerr=energy_std, fmt='s', label='exp', capsize=3)
    axs[1].set_xlabel('Torque [N·m]'); axs[1].set_ylabel('Mechanical Energy [J]'); axs[1].grid(True); axs[1].legend()
    # efficiency
    axs[2].plot(params_sim, eff_sim, '-o', label='sim')
    axs[2].errorbar(params, eff_mean, yerr=eff_std, fmt='s', label='exp', capsize=3)
    axs[2].set_xlabel('Torque [N·m]'); axs[2].set_ylabel('Efficiency [m/J]'); axs[2].grid(True); axs[2].legend()

    fig.tight_layout()
    plt.show()

# ------------------ Example usage ------------------
# sim_results variable should come from your earlier simulation sweep
# data_dir should contain the CSVs for experimental runs
# torque_values should be the same list used in the sim sweep
#
# Kt = motor torque constant [N·m / A]  (set from datasheet or bench test)
#
# Example:
# data_dir = "exp_data"
# torque_values = [0.02, 0.04, 0.06, 0.08, 0.10]
# exp_agg = aggregate_experiment(data_dir, torque_values, Kt=0.015)
# plot_sim_vs_exp(sim_results, exp_agg)
</code></pre></div>
<h2 id="downloading-the-dxf-file">Downloading the .dxf file:</h2>
<p><a href="https://drive.google.com/file/d/1LF2AlNSIYC5J-23TM4jydFAAj1r5O-O3/view?usp=drive_link">Download the layser cutting .dxf file</a></p>
<h2 id="downloading-the-file-making-process-instructions">Downloading the file making process instructions</h2>
<p><a href="../Project%20Laser%20Cut.pdf">Download the file making instructions</a></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"></path></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer">
        
          
          <a href=".." class="md-footer__link md-footer__link--prev" aria-label="Previous: Assignment 1">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Assignment 1
              </div>
            </div>
          </a>
        
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2024 team-name-here
    </div>
  
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="/2025_fall" target="_blank" rel="noopener" title="2025 Site" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M64 464c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16h160v80c0 17.7 14.3 32 32 32h80v288c0 8.8-7.2 16-16 16H64zM64 0C28.7 0 0 28.7 0 64v384c0 35.3 28.7 64 64 64h256c35.3 0 64-28.7 64-64V154.5c0-17-6.7-33.3-18.7-45.3l-90.6-90.5C262.7 6.7 246.5 0 229.5 0H64zm97 289c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0L79 303c-9.4 9.4-9.4 24.6 0 33.9l48 48c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-31-31 31-31zm96-34c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l31 31-31 31c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l48-48c9.4-9.4 9.4-24.6 0-33.9l-48-48z"></path></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.tabs.sticky", "toc.follow", "navigation.top", "navigation.path", "navigation.indexes", "navigation.prune", "content.action.edit", "navigation.footer"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.3220b9d7.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(()=>{ lightbox.reload(); });
</script></body></html>